

#include <stdlib.h>
#include <errno.h>
#include <vector>
#include <string>
#include <string.h>
#include <math.h>
#include "ProcServerThread.h"
#include "utility/os.h"
#include "logs.h"
#include "os.h"
#include "memguard.h"
#include "utils.h"
#include <algorithm>
#include "FightScriptBuilder.h"
#include "pthread_mutex_auto_unlock.h"
#include "CS_Common.h"
#include "SuitPool.h"
#include "bob_hash.h"
#include "robot_creater/PlayerNameFactory.h"


//装备属性配置key字符串
#define ZB_Key_gailv       "gailv"
#define ZB_Key_count       "count"
#define ZB_Key_kangxing    "kx"
#define ZB_Key_mingjie     "mj"
#define ZB_Key_zhili       "zl"
#define ZB_Key_liliang     "ll"
#define ZB_Key_tineng      "tn"
#define ZB_Key_baoji       "bj"
#define ZB_Key_baoshang    "bs"
#define ZB_Key_hp_ration   "hp"
#define ZB_Key_gedanglv    "gdlv"
#define ZB_Key_gedangzhi   "gdzi"
#define ZB_Key_gongji_min_add  "gjmin"
#define ZB_Key_gongji_max_add  "gjmax"
//#define ZB_Key_skill_ratio_add  "sklrt"
#define ZB_Key_hujia_add  "hujia"
#define ZB_Key_skill_zhouqi "sklzq"
#define ZB_Key_skill_turn "skltn"
#define ZB_Key_skill_result "sklst"
#define ZB_Key_actor_gongji_add_ratio "gjadd"
#define ZB_Key_actor_hp_add_ratio "hpadd"




//每日系统刷新时间
#define SystemDailyTask_Hour 4

//多长时间加一点体力 
#define VitalityUpdateTimeGap 300

//增加一次探索次数所需时间
#define Discover_Times_Update_Gap 360

//主线任务当前实现到了多少
#define MainTaskId_Implemented_Max 40

//初始英雄
#define Hero_init_gold 500
#define Hero_init_silver 500

//任务棋盘精英关卡数量范围
#define ChessBoard_JingYin_Min 3
#define ChessBoard_JingYin_Max 3
//精英关卡掉落率倍数
#define Jingying_Diaoluo_Factor 3.0





//#竞技场
//竞技场积分
#define ArenaChallenge_HighJifen 20
#define ArenaChallenge_NormalJifen 16
#define ArenaChallenge_LowJifen 12


//组队超时时间(秒)
#define ArenaCreateTeamTimeOut 10
//竞技场体力消耗 
#define ArenaVittalityNeed     3
//随机组队竞技每日最大次数
#define ArenaFreeJingji_Oneday_max_time 5
#define ArenaChallenge_Oneday_init_time 10

//地狱副本每日最多挑战多少次
#define HellTaskBattle_MaxTime 5

//地狱副本每个关卡怪物攻击轮数 
#define HellTask_GuaiwuAttackTime 6


//团队boss
//组队超时时间(秒)
#define TeamBossCreateTeamTimeOut ArenaCreateTeamTimeOut
//体力消耗 
#define TeamBossVittalityNeed     2
//团队boss战复活冷却轮数
#define TeamBossRestartCDTime 3


//巅峰对决小组赛从哪天开始
#define TopArenaOpen_WeekDay 3
//竞猜从每日的几点开始
#define TopArenaGuessOpen_Hour 4
//竞猜在每日的几点几分结束
//#define TopArenaGuessClose_Hour 19
//#define TopArenaGuessClose_Min  59
//巅峰对决的实际比赛完成的时间
#define TopArenaProcessBegin_Hour 20


//分支任务id
#define SubtaskId_Richang_jingjichang_duanzaocailiao 1
#define SubtaskId_Richang_teamboss_duanzaocailiao 2

//守城开放时间
#define CITYGUARD_OPEN_HOUR_1 12
#define CITYGUARD_OPEN_HOUR_2 20
//#define CITYGUARD_OPEN_MIN 30
//#define CITYGUARD_OPEN_SEC 1

//赠送体力时间段
#define VITALITY_ACTIVITY_OPEN_HOUR_1 12
#define VITALITY_ACTIVITY_CLOSE_HOUR_1 14
#define VITALITY_ACTIVITY_OPEN_HOUR_2 18
#define VITALITY_ACTIVITY_CLOSE_HOUR_2 20

//血色教堂开启关闭时间
#define SELF_CHALLENGE_OPEN_HOUR 8
#define SELF_CHALLENGE_CLOSE_HOUR 0 //第二天的0点

//英雄榜挑战失败冷却时间
#define TOP_HERO_CHALLENGE_LOSE_CD_Time 120

//战斗最大回合 超过回合直接a负
#define BATTLE_ROUND_LIMIT 20

//洗炼默认次数
#define PURIFY_DEFAULT_TIMES 3



//
#define Mysql_Thread_Conn ((CMysql*)pthread_getspecific(m_mysql_key))


//血色教堂自我挑战难度系数
static const float self_chlg_coefficient[4] = {1, 1.5, 2, 3};

//系统名称
static const char* system_name = "地狱小暗";

static std::vector<__PurifyAttr> m_purify_attr_vec;

//稀有装备鉴定所需材料装表
static std::map<unsigned int, unsigned int> m_assess_weapon_map;


ProcServerThread::ProcServerThread(PacketQueue* import_q
        , PacketQueue* outport_q
        , std::string db_ip
		, std::string db_username
		, std::string db_psw)
:SDTwinThreadPool(1,1)
{
    m_import_q = import_q;
    m_outport_q = outport_q;

    m_db_ip = db_ip;
    m_db_username = db_username;
    m_db_psw = db_psw;

    pthread_mutex_init(&m_arena_gift_pool_mutex, NULL);
    pthread_mutex_init(&m_teamboss_gift_pool_mutex, NULL);
    
    //线程专有数据，存储各线程自己的mysql连接句柄
    if(pthread_key_create (&m_mysql_key, NULL) != 0)
    {
        LogMsg("%s, line %d, pthread_key_create  failed. "
                    , __FILE__, __LINE__);
    }
}

ProcServerThread::~ProcServerThread()
{
    pthread_mutex_destroy(&m_arena_gift_pool_mutex);
    pthread_mutex_destroy(&m_teamboss_gift_pool_mutex);
    
}


void ProcServerThread::create_robots(int count/*=10000*/)
{
    if(count < 1) 
        return ;
    
    CMysql* mysql = 0;
    //connect db
    try
    {
        mysql = new CMysql(m_db_ip.c_str(), m_db_username.c_str()
            , m_db_psw.c_str(), true);
        mysql->Connect();

    }
    catch(CMysqlException& e)
    {
         LogMsg("%s, line %d, mysql connect failed. abort. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());

        exit(1);
        return;
    }

    //存储线程专有数据
    if(pthread_setspecific(m_mysql_key, mysql) != 0)
    {
        LogMsg("%s, line %d, pthread_setspecific  failed. "
                    , __FILE__, __LINE__);
    }

    //
    {
        char sql[1024];
        sprintf(sql, "set names utf8;");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //加载数据库所有模板表
    load_database_template();
    //加载神兵 
    loadShenbing();
    //加载套装
    loadSuit();


    Profession prof_arr[3] = {Profession_Yemanren, Profession_Chike, Profession_Fashi};
    const int max_level = 29;
    const int min_level = 6;
    int level_zone = max_level -min_level +1;
    int prof_num, level_num, power_num;
    unsigned int fight_capacity, hero_id;

    //记录机器人的战斗力 完成以后直接插入到英雄榜里面去
    std::multimap<unsigned int, unsigned int> fgt_cpt_map;


    LogMsg("create robot begin.");
    LogMsg("==================================================");

    time_t old_time = time(NULL);
    for(int i=0; i<count; ++i) {
        prof_num = Utl::auto_random()%3;
        level_num = min_level + Utl::auto_random()%level_zone;
        power_num = Utl::auto_random()%3 +1;

        hero_id = create_robot(prof_arr[prof_num], level_num, (robot_power)power_num, fight_capacity);
        fgt_cpt_map.insert(std::pair<unsigned int, unsigned int>(fight_capacity, hero_id));

        if((i+1) %500 == 0) {
            LogMsg("create %d robots cast time %ds.", i+1, (int)(time(NULL) - old_time));
        }
    }

    LogMsg("==================================================");
    LogMsg("create %d robots finish", count);
    LogMsg("******************************************************");
    LogMsg("******************************************************");
    LogMsg("******************************************************");

    
    unsigned int max_hero_order = 0;
    { //英雄榜 放到最后面
        char sql[1024];
        sprintf(sql, "select max(hero_order) max_order from hellgate.top_hero_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                char* v = Mysql_Thread_Conn->GetField("max_order");
                if(v == NULL) {
                    max_hero_order = 0;
                }
                else {
                    max_hero_order = atoi(v);
                }
                
            }
            else {
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    max_hero_order++;
    std::multimap<unsigned int, unsigned int>::iterator p = fgt_cpt_map.begin();
    
    LogMsg("insert top hero list begin.");
    LogMsg("==================================================");
    old_time = time(NULL);
    for(int i=0; p!=fgt_cpt_map.end(); ++p, ++max_hero_order, ++i){ //插入排名
        hero_id = p->second;
        
        char sql[1024];
        sprintf(sql, "insert into hellgate.top_hero_list "
            " set hero_id=%u, hero_order=%u"
            , hero_id, max_hero_order);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
    }
    
    LogMsg("==================================================");
    LogMsg("insert %d robots order cast time %ds.",  count, (int)(time(NULL) - old_time));
    LogMsg("insert top hero list finish.");

    /*
    for(unsigned int level=29; level>=6; --level)
    {
        create_robot(Profession_Yemanren, level,robot_power_hard);
        create_robot(Profession_Chike, level,robot_power_hard);
        create_robot(Profession_Fashi, level,robot_power_hard);

        create_robot(Profession_Yemanren, level,robot_power_mid);
        create_robot(Profession_Chike, level,robot_power_mid);
        create_robot(Profession_Fashi, level,robot_power_mid);

        create_robot(Profession_Yemanren, level,robot_power_mid);
        create_robot(Profession_Chike, level,robot_power_mid);
        create_robot(Profession_Fashi, level,robot_power_mid);

        create_robot(Profession_Yemanren, level,robot_power_easy);
        create_robot(Profession_Chike, level,robot_power_easy);
        create_robot(Profession_Fashi, level,robot_power_easy);

        create_robot(Profession_Yemanren, level,robot_power_easy);
        create_robot(Profession_Chike, level,robot_power_easy);
        create_robot(Profession_Fashi, level,robot_power_easy);

        create_robot(Profession_Yemanren, level,robot_power_easy);
        create_robot(Profession_Chike, level,robot_power_easy);
        create_robot(Profession_Fashi, level,robot_power_easy);
    }
    */


    mysql->Close();

    return ;
}


unsigned int ProcServerThread::create_robot(Profession prof, unsigned int level, robot_power power
    , unsigned int &fight_capacity)
{    
    fight_capacity = 0;
    if(level >= HERO_MAX_LEVEL)
    {
        //暂时不支持
        assert(false);
        return 0;
    }
    
    //需要生成hero ID
    unsigned hero_id;
    char sql[1024];
    sprintf(sql, "select max(hero_id) max_hero_id "
        " from hellgate.hero_infor");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            hero_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    hero_id++;

    
    std::string hero_name; //name
    unsigned int position = 0;  //posistion
    if(prof == Profession_Yemanren
        || prof == Profession_Chike)
    {
        position = 1;
        hero_name  = PlayerNameFactory::getFactory()->getRandomName(true);
    }
    else if(prof == Profession_Fashi)
    {
        position = 3;
        hero_name  = PlayerNameFactory::getFactory()->getRandomName(false);
    }
    else
    {
        assert(false);
        return 0;
    }

    //
    
    std::string name_str;
    Mysql_Thread_Conn->Escape(name_str, (char*)hero_name.c_str(), hero_name.length());
    sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, is_unlocked=1, " 
        " is_unlock_able=1, parent_hero_id=0, profession_id=%u, "
        " level=%u, hero_name='%s', exp_current=0, position=%u, vit_current=%u, vit_last_modify_time=%u"
        , hero_id, (unsigned int)prof, level, name_str.c_str(), position, Vitality_Total, (unsigned int)time(0));
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }


    //创建英雄vip信息
    sprintf(sql, "insert into hellgate.hero_vip_info set hero_id=%u "
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }


    //初始化机器人
    init_robot(hero_id, prof, level, power, fight_capacity);

    return hero_id;
}

void ProcServerThread::init_robot(unsigned int hero_id
    , Profession prof,unsigned int level,robot_power power, unsigned int &fight_capacity)
{
    //初始装备
    init_robot_zb(hero_id, hero_id, prof, level, power);

    //初始技能
    unsigned int init_skill = 0;
    if(prof == Profession_Yemanren)
    {
        init_skill = SkillType_BaoLieZhan;
    }
    else if(prof == Profession_Chike)
    {
        init_skill = SkillType_ShaLu;
    }
    else if(prof == Profession_Fashi)
    {
        init_skill = SkillType_ShanDian;
    }
    else
    {
        assert(false);
    }
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.skill_in_team set "
            " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=1"
            , hero_id, hero_id, (unsigned int)1, init_skill);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    /*
    //英雄榜 放到最后面
    {
        unsigned int max_hero_order = 0;
        char sql[1024];
        //
        sprintf(sql, "select max(hero_order) max_order from hellgate.top_hero_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                char* v = Mysql_Thread_Conn->GetField("max_order");
                if(v == NULL)
                {
                    max_hero_order = 0;
                }
                else
                {
                    max_hero_order = atoi(v);
                }
                
            }
            else
            {
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        max_hero_order++;
        
        //
        sprintf(sql, "insert into hellgate.top_hero_list "
            " set hero_id=%u, hero_order=%u"
            , hero_id, max_hero_order);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */

    fight_capacity  = this->calculate_fight_capacity(hero_id);

    //助手
    if(prof == Profession_Yemanren)
    {
        //秘术
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_MiShu, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 4, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

        //游侠
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_YouXia, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 2, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

        //猎手
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_LieShou, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 3, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
        

    }
    else if(prof == Profession_Chike)
    {
        //秘术
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_MiShu, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 4, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

        //游侠
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_YouXia, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 2, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

        //猎手
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_LieShou, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 3, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

    }
    else if(prof == Profession_Fashi)
    {
        //骑士
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_Qishi, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 1, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

        //游侠
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_YouXia, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 2, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }

        //猎手
        {
            unsigned int assit_id = create_robot_assist(hero_id, Profession_LieShou, level, power);
            fight_capacity += this->calculate_fight_capacity(assit_id);
            {
                char sql[1024];
                sprintf(sql, "update hellgate.hero_infor set position=%u "
                            "where hero_id=%u"
                            , 4, assit_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
        

    }
    else
    {
        assert(false);
    }

    
}

void ProcServerThread::init_robot_zb(unsigned int main_hero_id
    , unsigned int hero_id,Profession prof,unsigned int level,robot_power power)
{
    switch(prof)
    {
        case Profession_Yemanren:
            init_robot_yemanren_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_Chike:
            init_robot_cike_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_Fashi:
            init_robot_fashi_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_Qishi:
            init_robot_qishi_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_YouXia:
            init_robot_youxia_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_MiShu:
            init_robot_mishu_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_LieShou:
            init_robot_lieshou_zb(main_hero_id, hero_id, level, power);
            break;
        case Profession_ShenJianShou:
            init_robot_shenjianshou_zb(main_hero_id, hero_id, level, power);
            break;
        default:
            assert(0);
        
    }
}

void ProcServerThread::create_robot_zb(
    unsigned int main_hero_id
    , unsigned int hero_id,unsigned int hero_level, Profession hero_prof
    , ZhuangbeiType zb_type,ZhuangbeiColour zb_color
    ,unsigned int qianghua_goldstar_num,unsigned int qianghua_silverstar_num)
{
    //找模板
    unsigned int zb_name_id = 0;
    unsigned int zb_group_id = 0;
    unsigned int zb_level = 0;
    
    if(hero_level <= 6 && zb_color==ZhuangbeiColour_Xiyou) { //6级以下没有稀有装
        zb_color = ZhuangbeiColour_Fumo;
    }
    
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_name_id, group_id, zhuangbei_level "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_level<=%u and "
            " zhuangbei_colour=%u and zhuangbei_type=%u"
            " and (bind_profession_id=%u or bind_profession_id=0) "
            " order by zhuangbei_level desc limit 1"
            , hero_level, zb_color
            , (unsigned int)zb_type
            , (unsigned int )hero_prof);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                zb_group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                zb_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
            }
            else
            {
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //创建装备
    __ZhuangbeiDetail detail;
    if(!createZhuangbei(zb_name_id, zb_group_id,main_hero_id, detail))
    {
        assert(false);
    }
    unsigned long long zb_id = ObtainZhuangbei(main_hero_id, zb_name_id, detail);

    //穿装备
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=%u "
            " where zhuangbei_id=%llu"
            , hero_id, zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //强化
    {
        unsigned int gold_num = qianghua_goldstar_num;
        unsigned int silver_num = qianghua_silverstar_num;
        //先查能强几次
        unsigned int qianghua_count = getQianghuaMaxTime(zb_type,zb_color, zb_level);

        std::string qh_str;
        for(int i=0; i<qianghua_count; ++i)
        {
            char str[64];
            if(gold_num > 0)
            {
                sprintf(str, ", qianghua_level_%u=%u, qianghua_percent_%u=%u "
                    , i+1, (unsigned int)QianghuaLevel_jin, i+1, QianghuaPercent_jin);

                gold_num--;
            }
            else if(silver_num > 0)
            {
                sprintf(str, ", qianghua_level_%u=%u, qianghua_percent_%u=%u "
                    , i+1, (unsigned int)QianghuaLevel_yin, i+1, QianghuaPercent_yin);

                silver_num--;
            }
            else
            {
                unsigned int is_tong = Utl::auto_random()%2;
                if(is_tong == 0)
                {
                    sprintf(str, ", qianghua_level_%u=%u, qianghua_percent_%u=%u "
                    , i+1, (unsigned int)QianghuaLevel_tie, i+1, QianghuaPercent_tie);
                }
                else
                {
                    sprintf(str, ", qianghua_level_%u=%u, qianghua_percent_%u=%u "
                    , i+1, (unsigned int)QianghuaLevel_tong, i+1, QianghuaPercent_tong);
                }
            }

            qh_str = qh_str + str;
        }

        {
            char sql[1024];
            sprintf(sql, "update hellgate.zhuangbei_list set qianghua_count=%u %s "
                " where zhuangbei_id=%llu"
                , qianghua_count, qh_str.c_str(), zb_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
}

void ProcServerThread::init_robot_yemanren_zb(unsigned int main_hero_id
    , unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_Yemanren;
    
    //斧
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Chuanqi;
        ZhuangbeiType zb_type = ZhuangbeiType_ShuangshouFu;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaZhong;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Chuanqi;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_cike_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    
    Profession prof = Profession_Chike;
    
    //匕首
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Chuanqi;
        ZhuangbeiType zb_type = ZhuangbeiType_ShuangshouBishou;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaZhong;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Chuanqi;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_fashi_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_Fashi;
    
    //法杖
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Chuanqi;
        ZhuangbeiType zb_type = ZhuangbeiType_DanshouFazhang;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //法器
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Faqi;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaQin;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Chuanqi;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_qishi_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_Qishi;
    
    //剑
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_DanshouJian;

        
        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盾
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_Dunpai;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaZhong;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_youxia_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_YouXia;
    
    //剑
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_DanshouJian;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //法器
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_Dunpai;

        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaZhong;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_mishu_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_MiShu;
    
    //法杖
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_ShuangshouFazhang;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaQin;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_lieshou_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_LieShou;
    
    //弓
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_Gong;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaQin;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}
void ProcServerThread::init_robot_shenjianshou_zb(unsigned int main_hero_id, unsigned int hero_id, unsigned int level, robot_power power)
{
    Profession prof = Profession_ShenJianShou;
    
    //弓
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_Gong;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //盔甲
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Baizhuang;
        ZhuangbeiType zb_type = ZhuangbeiType_KuijiaQin;

        if(power == robot_power_mid)
        {
            zb_color = ZhuangbeiColour_Fumo;
        }
        else if(power == robot_power_hard)
        {
            zb_color = ZhuangbeiColour_Xiyou;
        }
        
        unsigned int qianghua_goldstar_num = 0;
        unsigned int qianghua_silverstar_num = 0;
        get_robot_zb_qianghua_level(power, qianghua_goldstar_num, qianghua_silverstar_num);
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,qianghua_goldstar_num,qianghua_silverstar_num);
    }
    //护身符
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Hushenfu;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指1
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
    //戒指2
    {
        ZhuangbeiColour zb_color = ZhuangbeiColour_Fumo;
        ZhuangbeiType zb_type = ZhuangbeiType_Jiezhi;
        
        create_robot_zb(main_hero_id, hero_id,level, prof, zb_type, zb_color
            ,0,0);
    }
}

unsigned int ProcServerThread::create_robot_assist(unsigned int main_hero_id
    ,Profession prof,unsigned int level,robot_power power)
{
    //需要生成hero ID
    unsigned int assit_hero_id;
    char sql[1024];
    sprintf(sql, "select max(hero_id) max_hero_id "
        " from hellgate.hero_infor");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            assit_hero_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    assit_hero_id++;

    //
    sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, "
        " is_unlocked=%u, is_unlock_able=%u, "
        " parent_hero_id=%u, profession_id=%u, "
        " level=%u, hero_name='', exp_current=0"
        , assit_hero_id
        , 1, 1
        , main_hero_id, prof
        , level);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    //初始化装备
    init_robot_zb(main_hero_id, assit_hero_id, prof, level,power);

    //初始技能
    unsigned int init_skill = 0;
    if(prof == Profession_Qishi)
    {
        init_skill = SkillType_JianShou;
    }
    else if(prof == Profession_YouXia)
    {
        init_skill = SkillType_LiRenHuiXuan;
    }
    else if(prof == Profession_ShenJianShou)
    {
        init_skill = SkillType_LieGong;
    }
    else if(prof == Profession_LieShou)
    {
        init_skill = SkillType_JianYu;
    }
    else if(prof == Profession_MiShu)
    {
        init_skill = SkillType_HuoQiuShu;
    }
    else
    {
        assert(false);
    }
    //生成skill_id
    unsigned skill_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select max(skill_id) max_skill_id "
            " from hellgate.skill_in_team where main_hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_id = atoi(Mysql_Thread_Conn->GetField("max_skill_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    skill_id++;
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.skill_in_team set "
            " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=1"
            , main_hero_id, assit_hero_id, skill_id, init_skill);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    this->calculate_fight_capacity(assit_hero_id);
    return assit_hero_id;
}

void ProcServerThread::get_robot_zb_qianghua_level(robot_power power
    ,unsigned int & qianghua_goldstar_num,unsigned int & qianghua_silverstar_num)
{
    if(power == robot_power_easy)
    {
        qianghua_goldstar_num = 0;
        qianghua_silverstar_num = 0;
    }
    else if(power == robot_power_mid)
    {
        qianghua_goldstar_num = 0;
        qianghua_silverstar_num = 1;
    }
    else
    {
        qianghua_goldstar_num = 1;
        qianghua_silverstar_num = 1;
    }
}

//临时
void ProcServerThread::change_robot_zb_qianghua()
{
    CMysql* mysql = 0;
    //connect db
    try
    {
        mysql = new CMysql(m_db_ip.c_str(), m_db_username.c_str()
            , m_db_psw.c_str(), true);
        mysql->Connect();

    }
    catch(CMysqlException& e)
    {
         LogMsg("%s, line %d, mysql connect failed. abort. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());

        exit(1);
        return;
    }

    //存储线程专有数据
    if(pthread_setspecific(m_mysql_key, mysql) != 0)
    {
        LogMsg("%s, line %d, pthread_setspecific  failed. "
                    , __FILE__, __LINE__);
    }

    //
    {
        char sql[1024];
        sprintf(sql, "set names utf8;");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //先查询出机器人所带的所有带强化的装备
    std::vector<unsigned long long> zb_id_vec;
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_id "
            " from hellgate.zhuangbei_list, hellgate.hero_infor "
            " where hero_name like 'rb_%%' and owner_hero_id=hero_id "
            " and qianghua_count>0"
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned long long id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_id"));

                zb_id_vec.push_back(id);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //逐个修改强化级别
    for(int i=0; i<zb_id_vec.size(); ++i)
    {
        unsigned int owner_id;
        __ZhuangbeiDetail detail;
        getZhuangbeiDetail(zb_id_vec[i], owner_id, detail);

        unsigned int jin_count = 0;
        unsigned int yin_count = 0;
        for(int index=0; index<detail.qianghua_data.qianghua_count; ++index)
        {
            if(detail.qianghua_data.info_arr[index].level == QianghuaLevel_jin)
            {
                jin_count++;
            }
            else if(detail.qianghua_data.info_arr[index].level == QianghuaLevel_yin)
            {
                yin_count++;
            }
        }

        //如果是两个金星两个银星则调整为一金一银
        if(jin_count == 2)
        {
            for(int index=0; index<detail.qianghua_data.qianghua_count; ++index)
            {
                if(detail.qianghua_data.info_arr[index].level == QianghuaLevel_jin
                    && jin_count == 2)
                {
                    detail.qianghua_data.info_arr[index].level= QianghuaLevel_tong;
                    detail.qianghua_data.info_arr[index].percent = 6;
                    jin_count--;
                }
                else if(detail.qianghua_data.info_arr[index].level == QianghuaLevel_yin
                    && yin_count == 2)
                {
                    detail.qianghua_data.info_arr[index].level= QianghuaLevel_tong;
                    detail.qianghua_data.info_arr[index].percent = 6;
                    yin_count--;
                }
            }
        }
        //如果是一个金星一个银星则调整为一银
        else if(jin_count == 1)
        {
            for(int index=0; index<detail.qianghua_data.qianghua_count; ++index)
            {
                if(detail.qianghua_data.info_arr[index].level == QianghuaLevel_jin)
                {
                    detail.qianghua_data.info_arr[index].level= QianghuaLevel_tong;
                    detail.qianghua_data.info_arr[index].percent = 6;
                    jin_count--;
                }
            }
        }

        //入库
        {
            std::string level_percent_str;

            for(int i=0; i<detail.qianghua_data.qianghua_count; ++i)
            {
                char str[64];
                sprintf(str, ", qianghua_level_%u=%u, qianghua_percent_%u=%u "
                    , i+1, detail.qianghua_data.info_arr[i].level, i+1, detail.qianghua_data.info_arr[i].percent);

                level_percent_str += str;
            }
        
            char sql[2048];
            sprintf(sql, "update hellgate.zhuangbei_list "
                " set qianghua_count=%u %s"
                " where zhuangbei_id=%llu"
                , detail.qianghua_data.qianghua_count, level_percent_str.c_str(), detail.zhuangbei_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    
    
}


int ProcServerThread::create_top_hero(Profession prof, char *account, char *passwd, char *heroname)
{
    CMysql* mysql = 0;
    try
    {
        mysql = new CMysql(m_db_ip.c_str(), m_db_username.c_str()
            , m_db_psw.c_str(), true);
        mysql->Connect();

    }
    catch(CMysqlException& e)
    {
         LogMsg("%s, line %d, mysql connect failed. abort. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());

        exit(1);
        return 0;
    }

    if(pthread_setspecific(m_mysql_key, mysql) != 0)
    {
        LogMsg("%s, line %d, pthread_setspecific  failed. "
                    , __FILE__, __LINE__);
    }

    {
        char sql[1024];
        sprintf(sql, "set names utf8;");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    
    //验证账号密码
    unsigned int client_id = 0;
    std::string psw;
    {
        
        std::string account_str;
        Mysql_Thread_Conn->Escape(account_str, account, strlen(account));
        char sql[1024];
        sprintf(sql, "select client_id, psw "
            " from hellgate.client_id where account='%s'"
            , account_str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                client_id = atoi(Mysql_Thread_Conn->GetField("client_id"));
                psw = std::string(Mysql_Thread_Conn->GetField("psw"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(psw.length() == 0 || psw != std::string(passwd))
    {
        return 1;
    }

    //需要生成hero ID
    unsigned hero_id;
    {
        char sql[1024];
        sprintf(sql, "select max(hero_id) max_hero_id "
            " from hellgate.hero_infor");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
        hero_id++;

        unsigned int position = 0;
        if(prof == Profession_Yemanren || prof == Profession_Chike)
        {
            position = 1;
        }
        else if(prof == Profession_Fashi)
        {
            position = 3;
        }
        else
        {
            LogMsg("%s, line %d, profession[%u] invalide. create hero failed"
                        , __FILE__, __LINE__, prof);
            return 1;
        }

        //
        std::string name_str;
        Mysql_Thread_Conn->Escape(name_str, heroname, strlen(heroname));
        sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, is_unlocked=1, " 
            " is_unlock_able=1, parent_hero_id=0, profession_id=%u, "
            " level=30, stage=10, hero_name='%s', exp_current=0, position=%u, vit_current=%u, vit_last_modify_time=%u"
            , hero_id, prof, name_str.c_str(), position, Vitality_Total*2, (unsigned int)time(0));
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //创建英雄vip信息
        sprintf(sql, "insert into hellgate.hero_vip_info set hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        //
        //
        sprintf(sql, "insert into hellgate.hero_list set client_id=%u, hero_id=%u"
            , client_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    {
        //主线进程
        char sql[1024];
        //
        sprintf(sql, "insert into hellgate.hero_maintask_progress "
            " set hero_id=%u, maintask_last_actived=40, status=4"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        //
        sprintf(sql, "insert into hellgate.hero_progress_subtask_daily_zhuangbei "
            " set hero_id=%u, status=0"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        //
        sprintf(sql, "insert into hellgate.hero_progress_subtask_daily_baoshi "
            " set hero_id=%u, status=0"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        //gold 
        sprintf(sql, "insert into hellgate.items_in_team "
            " set hero_id=%u, item_type=%u, item_count=%u"
            , hero_id, ItemsType_Gold, Hero_init_gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        //silver 
        sprintf(sql, "insert into hellgate.items_in_team "
            " set hero_id=%u, item_type=%u, item_count=%u"
            , hero_id, ItemsType_Silver, Hero_init_silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //初始技能
        unsigned int init_skill = 0;
        if(prof == Profession_Yemanren)
        {
            init_skill = SkillType_BaoLieZhan;
        }
        else if(prof == Profession_Chike)
        {
            init_skill = SkillType_ShaLu;
        }
        else if(prof == Profession_Fashi)
        {
            init_skill = SkillType_ShanDian;
        }
        else
        {
            LogMsg("%s, line %d, profession[%d] not supported"
                        , __FILE__, __LINE__, (int)prof);
            assert(false);
        }
        {
            char sql[1024];
            sprintf(sql, "insert into hellgate.skill_in_team set "
                " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=1"
                , hero_id, hero_id, (unsigned int)1, init_skill);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        //英雄榜 
        {
            //unsigned int max_hero_order = 0;
            char sql[1024];
            //
            sprintf(sql, "update hellgate.top_hero_list set hero_order=hero_order+1 "
            " where hero_order>0 ");
            //sprintf(sql, "select max(hero_order) max_order from hellgate.top_hero_list ");
            try
            {
                Mysql_Thread_Conn->Query(sql);
                /*
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    char* v = Mysql_Thread_Conn->GetField("max_order");
                    if(v == NULL)
                    {
                        max_hero_order = 0;
                    }
                    else
                    {
                        max_hero_order = atoi(v);
                    }
                    
                }
                else
                {
                    assert(false);
                }
                */
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
            //max_hero_order++;
            
            //
            sprintf(sql, "insert into hellgate.top_hero_list "
                " set hero_id=%u, hero_order=1"
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    for(int i=0; i<MAX_TASK_NUM; i++) {
        refreshChessBoard(hero_id, i+1);
        std::string grid_str = " grid_id_0=1 ";
        
        char sql[1024];
        sprintf(sql, "update hellgate.task_chessboard set  "
            " %s "
            " where hero_id=%u and task_id=%u"
            , grid_str.c_str(), hero_id, i+1);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    { //教学
        char sql[1024];
        sprintf(sql, "insert into hellgate.instruction_info set  "
            " hero_id=%u, progress=%llu"
            , hero_id, 0xFFFFFFFFFFFFFFFFull);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<MAX_TASK_NUM; i++) {
        updateRateTaskStarStat(RateStarType_Task, hero_id, i+1, 3);
    }
    for(int i=0; i<MAX_CHAPTER_NUM; i++) {
        updateRateTaskStarStat(RateStarType_Chapter, hero_id, i+1, 2);
    }
    
    //加载数据库所有模板表
    load_database_template();
    //加载神兵 
    loadShenbing();
    //加载套装
    loadSuit();

    create_top_assist(prof, hero_id, 0, false);
    if(prof == Profession_Yemanren) {
        create_top_assist(Profession_Qishi, hero_id, 2);
        create_top_assist(Profession_MiShu, hero_id, 3);
        create_top_assist(Profession_LieShou, hero_id, 4);
        create_top_assist(Profession_ShenJianShou, hero_id, 0);
        create_top_assist(Profession_YouXia, hero_id, 0);
        create_top_assist(Profession_WuSeng, hero_id, 0);
        create_top_assist(Profession_WuShi, hero_id, 0);
    }
    else if(prof == Profession_Chike) {
        create_top_assist(Profession_Qishi, hero_id, 0);
        create_top_assist(Profession_MiShu, hero_id, 0);
        create_top_assist(Profession_LieShou, hero_id, 0);
        create_top_assist(Profession_ShenJianShou, hero_id, 3);
        create_top_assist(Profession_YouXia, hero_id, 0);
        create_top_assist(Profession_WuSeng, hero_id, 2);
        create_top_assist(Profession_WuShi, hero_id, 4);
    }
    else if(prof == Profession_Fashi) {
        create_top_assist(Profession_Qishi, hero_id, 1);
        create_top_assist(Profession_MiShu, hero_id, 0);
        create_top_assist(Profession_LieShou, hero_id, 0);
        create_top_assist(Profession_ShenJianShou, hero_id, 4);
        create_top_assist(Profession_YouXia, hero_id, 2);
        create_top_assist(Profession_WuSeng, hero_id, 0);
        create_top_assist(Profession_WuShi, hero_id, 0);
    }
    

    //create_all_zhuangbei(hero_id, prof);
    return 0;
}


int ProcServerThread::create_top_assist(Profession prof, unsigned int main_hero_id, 
    unsigned int pos, bool b_assist/*=true*/)
{
    std::vector<unsigned int> group_vec;
    {
        char sql[1024];
        sprintf(sql, "select group_id from hellgate.zhuangbei_name_list_copy "
            " where bind_profession_id=%u and zhuangbei_level=30 "
            , prof);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int group = atoi(Mysql_Thread_Conn->GetField("group_id"));
                group_vec.push_back(group);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int diamond_type =0;
    if(prof == Profession_Yemanren || prof == Profession_Qishi 
        || prof == Profession_WuSeng) {
        diamond_type = 37;
    }
    else if(prof == Profession_Fashi || prof == Profession_MiShu
        || prof == Profession_WuShi) {
        diamond_type = 77;
    }
    else if(prof == Profession_Chike || prof == Profession_LieShou
        || prof == Profession_ShenJianShou || prof == Profession_YouXia) {
        diamond_type = 17;
    }

    QianghuaData qianghua_data;
    qianghua_data.max_qianghua_time = Qianghua_time_max;
    qianghua_data.qianghua_count = Qianghua_time_max;

    for(int i=0; i<qianghua_data.qianghua_count; i++){
        qianghua_data.info_arr[i].id = i+1;
        qianghua_data.info_arr[i].level = QianghuaLevel_jin_special;
        qianghua_data.info_arr[i].percent = QianghuaPercent_jin;
    }
    

    unsigned int assist_id = 0;
    {
        if(!b_assist) {
            assist_id = main_hero_id;
        }
        else {//生成助手
            char sql[1024];
            sprintf(sql, "select max(hero_id) max_hero_id "
                " from hellgate.hero_infor");
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    assist_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
            assist_id++;

            //
            sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, "
                " is_unlocked=1, is_unlock_able=1, "
                " parent_hero_id=%u, profession_id=%u, "
                " level=30, stage=10, hero_name='', position=%u, exp_current=0"
                , assist_id
                , main_hero_id, prof, pos);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
            //初始技能
            unsigned int init_skill = 0;
            if(prof == Profession_Qishi)
            {
                init_skill = SkillType_JianShou;
            }
            else if(prof == Profession_WuSeng)
            {
                init_skill = SkillType_ShenZhiXingNian;
            }
            else if(prof == Profession_YouXia)
            {
                init_skill = SkillType_LiRenHuiXuan;
            }
            else if(prof == Profession_ShenJianShou)
            {
                init_skill = SkillType_LieGong;
            }
            else if(prof == Profession_LieShou)
            {
                init_skill = SkillType_JianYu;
            }
            else if(prof == Profession_MiShu)
            {
                init_skill = SkillType_HuoQiuShu;
            }
            else if(prof == Profession_WuShi)
            {
                init_skill = SkillType_WenYi;
            }
            else
            {
                LogMsg("%s, line %d, profession[%d] not supported"
                            , __FILE__, __LINE__, (int)prof);
            }
            //生成skill_id
            unsigned skill_id = 0;
            {
                char sql[1024];
                sprintf(sql, "select max(skill_id) max_skill_id "
                    " from hellgate.skill_in_team where main_hero_id=%u"
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        skill_id = atoi(Mysql_Thread_Conn->GetField("max_skill_id"));
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
            skill_id++;
            {
                char sql[1024];
                sprintf(sql, "insert into hellgate.skill_in_team set "
                    " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=1"
                    , main_hero_id, assist_id, skill_id, init_skill);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
            
        }
        
    }

    for(int i=0; i<group_vec.size(); i++) {//生成助手装备
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(group_vec[i]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            continue;
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, group_vec[i], main_hero_id, detail))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            continue;
        }

        detail.jinglian_level = CS::getJingLianMaxTimes(detail.zhuangbei_colour, detail.zhuangbei_level);
        if(detail.hole == 1){
            detail.diamond_type_1 = diamond_type;
        }
        else if(detail.hole == 3){
            detail.diamond_type_1 = diamond_type;
            detail.diamond_type_2 = diamond_type;
            detail.diamond_type_3 = diamond_type;
        }

        if(CS::canZBTypeBeQianghua(detail.zhuangbei_type)) {
            detail.qianghua_data = qianghua_data;
        }

        unsigned int max_hole = CS::getPurifyMaxHoles(detail.zhuangbei_type, detail.zhuangbei_colour, detail.zhuangbei_level);
        if(max_hole > 0) {
            detail.purify_attr.clear();
            for(int i=0; i<max_hole; ++i) {
                ZBAttr attr;
                attr.cuiqu_suc_ratio = 0;
                attr.attr_value = m_purify_attr_vec[m_purify_attr_vec.size()-1].max_value;
                switch(i) {
                    case 0:
                        attr.attr_type = AttrType_baoshang;
                        break;
                    case 1:
                        attr.attr_type = AttrType_tineng;
                        break;
                    case 2:
                        attr.attr_type = AttrType_skillresult;
                        break;
                    case 3:
                        for(int i=0; i<detail.attr_vec.size(); ++i) {
                            if(detail.attr_vec[i].attr_type <= AttrType_tineng) {
                                attr.attr_type = detail.attr_vec[i].attr_type;
                                break;
                            }
                        }
                        break;
                    default:
                        continue;
                }

                detail.purify_attr.push_back(attr);
            }
        }
        
        //入库
        detail.zhuangbei_id = obtain_top_zhuangbei(main_hero_id, zb_name_id, detail);
        //__equipZhuangbeiToHero(detail.zhuangbei_id, assist_id);
        { //穿装
            char sql[1024];
            sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=%u "
                "where zhuangbei_id=%llu"
                , assist_id, detail.zhuangbei_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }


    unsigned int yuanshen_id = 0;
    {
        yuanshen_id = createYuanshen(assist_id);
        
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set "
        " level=25, stage=5 where hero_id=%u "
        , yuanshen_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<group_vec.size(); i++) {//生成助手装备
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(group_vec[i]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, group_vec[i], main_hero_id, detail))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            return false;
        }

        detail.jinglian_level = CS::getJingLianMaxTimes(detail.zhuangbei_colour, detail.zhuangbei_level);
        if(detail.hole == 1){
            detail.diamond_type_1 = diamond_type;
        }
        else if(detail.hole == 3){
            detail.diamond_type_1 = diamond_type;
            detail.diamond_type_2 = diamond_type;
            detail.diamond_type_3 = diamond_type;
        }

        if(CS::canZBTypeBeQianghua(detail.zhuangbei_type)) {
            detail.qianghua_data = qianghua_data;
        }
        
        unsigned int max_hole = CS::getPurifyMaxHoles(detail.zhuangbei_type, detail.zhuangbei_colour, detail.zhuangbei_level);
        if(max_hole > 0) {
            detail.purify_attr.clear();
            for(int i=0; i<max_hole; ++i) {
                ZBAttr attr;
                attr.cuiqu_suc_ratio = 0;
                attr.attr_value = m_purify_attr_vec[m_purify_attr_vec.size()-1].max_value;
                switch(i) {
                    case 0:
                        attr.attr_type = AttrType_baoshang;
                        break;
                    case 1:
                        attr.attr_type = AttrType_tineng;
                        break;
                    case 2:
                        attr.attr_type = AttrType_skillresult;
                        break;
                    case 3:
                        for(int i=0; i<detail.attr_vec.size(); ++i) {
                            if(detail.attr_vec[i].attr_type <= AttrType_tineng) {
                                attr.attr_type = detail.attr_vec[i].attr_type;
                                break;
                            }
                        }
                        break;
                    default:
                        continue;
                }

                detail.purify_attr.push_back(attr);
            }
        }
        //入库
        detail.zhuangbei_id = obtain_top_zhuangbei(main_hero_id, zb_name_id, detail);
        //__equipZhuangbeiToHero(detail.zhuangbei_id, yuanshen_id);
        { //穿装
            char sql[1024];
            sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=%u "
                "where zhuangbei_id=%llu"
                , yuanshen_id, detail.zhuangbei_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    this->calculate_fight_capacity(yuanshen_id);

    return 0;
}


unsigned long long ProcServerThread::obtain_top_zhuangbei(unsigned int hero_id
    , unsigned int zhuangbei_name_id, __ZhuangbeiDetail detail)
{
    //先找zhuangbei_id最大值
    unsigned long long max_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select max(zhuangbei_id) max_id from hellgate.zhuangbei_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                max_id = atoll(Mysql_Thread_Conn->GetField("max_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    max_id++;

    //
    {
        std::string attr_str;
        char str[64];
        for(int i=0; i<detail.attr_vec.size(); ++i)
        {
            sprintf(str, "attr_type_%d=%u, attr_value_%d=%u, cuiqu_suc_ratio_%d=%u, "
                , i+1, detail.attr_vec[i].attr_type, i+1, detail.attr_vec[i].attr_value
                , i+1, detail.attr_vec[i].cuiqu_suc_ratio);

            attr_str += str;
        }
        
        std::string purify_str;
        sprintf(str, "purify_hole=%u, ", (unsigned int)detail.purify_attr.size());
        purify_str += str;
        for(int i=0; i<detail.purify_attr.size(); ++i) {
            sprintf(str, "purify_attr_type_%d=%u, purify_attr_value_%d=%u, "
                , i+1, detail.purify_attr[i].attr_type, i+1, detail.purify_attr[i].attr_value);
            purify_str += str;
        }
        
        std::string level_percent_str;

        for(int i=0; i<detail.qianghua_data.qianghua_count; ++i)
        {
            char str[64];
            sprintf(str, " qianghua_level_%u=%u, qianghua_percent_%u=%u, "
                , i+1, detail.qianghua_data.info_arr[i].level
                , i+1, detail.qianghua_data.info_arr[i].percent);

            level_percent_str += str;
        }
        
        char sql[2048];
        sprintf(sql, "insert into hellgate.zhuangbei_list set "
            " zhuangbei_id=%llu, zhuangbei_name_id=%u, owner_hero_id=%u, "
            " zhuangbei_hero_id=0, is_unlocked=1, "
            " hole=%u, diamond_type_1=%u, diamond_type_2=%u, diamond_type_3=%u, "
            " gongji_min=%u, gongji_max=%u, hujia=%u, "
            " attr_count=%u, "
            " %s "
            " qianghua_count=%u, "
            " %s "
            " %s "
            " has_fumo=0, "
            " jinglian_level = %u "
            , max_id, zhuangbei_name_id, hero_id
            , detail.hole
            , detail.diamond_type_1, detail.diamond_type_2, detail.diamond_type_3
            , detail.gongji_min, detail.gongji_max, detail.hujia
            , (unsigned int)detail.attr_vec.size()
            , attr_str.c_str()
            , detail.qianghua_data.qianghua_count
            , level_percent_str.c_str()
            , purify_str.c_str()
            , detail.jinglian_level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return max_id;
}


void ProcServerThread::create_all_zhuangbei(unsigned int hero_id, Profession prof)
{
    std::vector<unsigned int> group_vec;
    {
        char sql[1024];
        sprintf(sql, "select distinct(group_id) from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_colour<%u or (zhuangbei_colour=%u and zhuangbei_level<30) "
            , ZhuangbeiColour_Chuanqi, ZhuangbeiColour_Chuanqi);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int group = atoi(Mysql_Thread_Conn->GetField("group_id"));
                group_vec.push_back(group);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    group_vec = filterZBGroupCannotUse(prof, group_vec);

    for(int i=0; i<group_vec.size(); i++) {//生成助手装备
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(group_vec[i]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            continue;
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, group_vec[i], hero_id, detail, false))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            continue;
        }
        
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(hero_id, zb_name_id, detail);
    }
}



void ProcServerThread::doIt()
{
    CMysql* mysql = 0;
    //connect db
    try
    {
        mysql = new CMysql(m_db_ip.c_str(), m_db_username.c_str()
            , m_db_psw.c_str(), true);
        mysql->Connect();

    }
    catch(CMysqlException& e)
    {
         LogMsg("%s, line %d, mysql connect failed. abort. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());

        exit(1);
        return;
    }

    //存储线程专有数据
    if(pthread_setspecific(m_mysql_key, mysql) != 0)
    {
        LogMsg("%s, line %d, pthread_setspecific  failed. "
                    , __FILE__, __LINE__);
    }

    //
    /*{
        char sql[1024];
        sprintf(sql, "set names utf8;");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }*/

    //加载数据库所有模板表
    load_database_template();

    /* 2014.06.30 屏蔽巅峰对决功能 */
    //加载巅峰对决数据
    //loadTopArenaData_8_4();
    //loadTopArenaData_4_2();
    //loadTopArenaData_2_1();

    //加载神兵 
    loadShenbing();
    //加载套装
    loadSuit();
    //加载守城
    loadCityGuardData();

    //清空自我挑战排名表
    clear_self_challenge_order();

    //测试代码
    test_function();
    
    while(true)
    {
        Packet* pack;
        m_import_q->pop(pack);

        DealwithPacket(pack);
        delete pack;
    }

    delete Mysql_Thread_Conn;
}

//定时器
void ProcServerThread::doIt2()
{
    sleep(1);

    CMysql* mysql = 0;
    //connect db
    try
    {
        mysql = new CMysql(m_db_ip.c_str(), m_db_username.c_str()
            , m_db_psw.c_str(), true);
        mysql->Connect();

    }
    catch(CMysqlException& e)
    {
         LogMsg("%s, line %d, mysql connect failed. abort. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());

        exit(1);
        return;
    }

    //存储线程专有数据
    if(pthread_setspecific(m_mysql_key, mysql) != 0)
    {
        LogMsg("%s, line %d, pthread_setspecific  failed. "
                    , __FILE__, __LINE__);
    }

    //
    /*{
        char sql[1024];
        sprintf(sql, "set names utf8;");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }*/
    
    while(true)
    {
        sleep(1);

        //系统每日刷新
        SystemRefreshTimer();
        
        //竞技场循环处理
        arenaTimer();

        //团队boss循环处理
        teamBossTimer();

        //守城
        cityGuardTimer();

        /* 2014.06.30 屏蔽巅峰对决功能 */
        //巅峰对决
        //topArenaTimer();

        //自我挑战
        self_challenge_timer();
    }

    delete Mysql_Thread_Conn;
    
}


/*
void ProcServerThread::StubOptMysql()
{
    
    char sql[1024];
    sprintf(sql, "select client_id from hellgate.client_id limit 1");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        Mysql_Thread_Conn->FetchRow();

        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        return;
    }
}
*/

void ProcServerThread::DealwithPacket(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithNormalPacket", __FILE__, __LINE__);
#endif //_DEBUG

    SPHead* head = (SPHead*)(pack->packdata);

    if(pack->client_id == 0)
    {
        //新接收到的包
        switch(ntohs(head->cmd))
        {
            case Register:
                DealwithRegister(pack);
                break;
            case clientLogin:
                DealwithClientLogin(pack);
                break;
            case Reconnect:
                DealwithReconnect(pack);
                break;
            case heartBeat:
                DealwithHeartBeat(pack);
                break;
            default:
                LogMsg("%s, line %d,client_id=0 req_cmd=[%u]"
                    , __FILE__, __LINE__, int(ntohs(head->cmd)));
                break;
        }
    }
    else if(pack->main_hero_id == 0)
    {
        //新接收到的包
        switch(ntohs(head->cmd))
        {
            case Register:
                DealwithRegister(pack);
                break;
            case clientLogin:
                DealwithClientLogin(pack);
                break;
            case Reconnect:
                DealwithReconnect(pack);
                break;
            case createHero:
                DealwithCreateHero(pack);
                break;
            case getHerosInTeam:
                DealwithGetHerosInTeam(pack);
                break;
            case heartBeat:
                DealwithHeartBeat(pack);
                break;
            case queryNotice:
                DealwithQueryNotice(pack);
                break;
            default:
                LogMsg("%s, line %d,main_hero_id=0 req_cmd=[%u]"
                    , __FILE__, __LINE__, int(ntohs(head->cmd)));
                break;
        }
    }
    else
    {
        //只要一经选择了主英雄，无论发送什么请求包都触发更新操作
        {
            updateHeroVitality(pack->main_hero_id);
        }
        
        //新接收到的包
        switch(ntohs(head->cmd))
        {
            case Register:
                DealwithRegister(pack);
                break;
            case clientLogin:
                DealwithClientLogin(pack);
                break;
            case Reconnect:
                DealwithReconnect(pack);
                break;
            case createHero:
                DealwithCreateHero(pack);
                break;
            case createAssit:
                DealwithCreateAssit(pack);
                break;
            case getHerosInTeam:
                DealwithGetHerosInTeam(pack);
                break;
            case getZhuangbeiInTeam:
                DealwithGetZhuangbeiInTeam(pack);
                break;
            case equipZhuangbei:
                DealwithEquipZhuangbei(pack);
                break;
            case adjustFormation:
                DealwithAdjustFormation(pack);
                break;
            case getTaskList:
                DealwithGetTaskList(pack);
                break;
            case GetTaskChessboard:
                DealwithGetTaskChessBoard(pack);
                break;
            case flopTaskGrid:
                DealwithFlopTaskGrid(pack);
                break;
            case getItemsInTeam:
                DealwithGetItemsInTeam(pack);
                break;
            case ZBQianghua:
                DealwithZhuangbeiQianghua(pack);
                break;
            case ZBQianghuaHuitui:
                DealwithZhuangbeiQianghuaHuitui(pack);
                break;
            case ZBChaijie:
                DealwithZhuangbeiChaijie(pack);
                break;
            case ZBXiangBaoshi:
                DealwithXiangBaoshi(pack);
                break;
            case ZBChaiBaoshi:
                DealwithChaiBaoshi(pack);
                break;
            case BaoshiHecheng:
                DealwithBaoshiHecheng(pack);
                break;
            case Battle:
                DealwithBattle(pack);
                break;
            case changeTaskStat:
                DealwithChangeTaskStat(pack);
                break;
            case heartBeat:
                DealwithHeartBeat(pack);
                break;
            case queryAnotherTeamInfo:
                DealwithQueryAnotherTeamInfo(pack);
                break;
            case chargeVitality:
                DealwithChargeVitality(pack);
                break;
            case queryAllSuitName:
                DealwithQueryAllSuitName(pack);
                break;
            case queryAllMofaJinghua:
                DealwithQueryAllMofaJinghua(pack);
                break;
            case ZBCuiqu:
                DealwithZBCuiqu(pack);
                break;
            case ZBFumo:
                DealwithZBFumo(pack);
                break;
            case queryFubenDiaoluo:
                DealwithQueryFubenDiaoluo(pack);
                break;
            case queryMainTaskReward:
                DealwithQueryMainTaskReward(pack);
                break;
            case chargeGold:
                DealwithChargeGold(pack);
                break;
            case queryTeamSkillList:
                DealwithQueryTeamSkillList(pack);
                break;
            case equipSkill:
                DealwithEquipSkill(pack);
                break;
            case actorLearnSkill:
                DealwithActorLearnSkill(pack);
                break;
            case arenaEnter:
                DealwithArenaEnter(pack);
                break;
            case arenaGetGift:
                DealwithArenaGetGift(pack);
                break;
            case queryArenaTeamBasicInfo:
                DealwithQueryArenaTeamBasicInfo(pack);
                break;
            case queryArenaMarket:
                DealwithQueryArenaMarket(pack);
                break;
            case refreshArenaChlgList:
                DealwithRefreshArenaChlgList(pack);
                break;
            case queryArenaChlgList:
                DealwithQueryArenaChlgList(pack);
                break;
            case arenaChallenge:
                DealwithArenaChallenge(pack);
                break;
            case arenaMarketBuy:
                DealwithArenaMarketBuy(pack);
                break;
            case arenaBuyChlgTime:
                DealwithArenaBuyChlgTime(pack);
                break;
            case teamBossEnter:
                DealwithTeamBossEnter(pack);
                break;
            case teamBossGetGift:
                DealwithTeamBossGetGift(pack);
                break;
            case cityGuardEnter:
                DealwithCityGuardEnter(pack);
                break;
            case cityGuardGetNextMonster:
                DealwithCityGuardGetNextMonster(pack);
                break;
            case cityGuardFight:
                DealwithCityGuardFight(pack);
                break;
            case topHeroGetList:
                DealwithTopHeroGetList(pack);
                break;
            case topHeroChallenge:
                DealwithTopHeroChallenge(pack);
                break;
            case topHeroClearCDTime:
                DealwithTopHeroClearCDTime(pack);
                break;
            case topArenaQueryStatus:
                DealwithTopArenaQueryStatus(pack);
                break;
            case topArenaGuess:
                DealwithTopArenaGuess(pack);
                break;
            case topArenaReplay:
                DealwithTopArenaReplay(pack);
                break;
            case topArenaQueryGuess:
                DealwithTopArenaQueryGuess(pack);
                break;
            case systemGiftQuery:
                DealwithSystemGiftQuery(pack);
                break;
            case systemGiftGetGift:
                DealwithSystemGiftGetGift(pack);
                break;
            case duanzaoListQuery:
                DealwithDuanzaoListQuery(pack);
                break;
            case duanzao:
                DealwithDuanzao(pack);
                break;
            case duanzaoGroupZBQuery:
                DealwithDuanzaoGroupZBQuery(pack);
                break;
            case querySubTaskList:
                DealwithQuerySubtaskList(pack);
                break;
            case queryAllShenbingList:
                DealwithQueryAllShenbingList(pack);
                break;
            case queryTeamShenbingSuipian:
                DealwithQueryTeamShenbingSuipian(pack);
                break;
            case shenbingHecheng:
                DealwithShenbingHecheng(pack);
                break;
            case queryTeamItemSuipian:
                DealwithQueryTeamItemSuipian(pack);
                break;
            case itemHecheng:
                DealwithItemHecheng(pack);
                break;
            case saodangFuben:
                DealwithSaodang(pack);
                break;
            case shenbingJieFengyin:
                DealwithShenbingJiefengyin(pack);
                break;
            case shenbingJianding:
                DealwithShenbingJianding(pack);
                break;
            case zbJinglian:
                DealwithZBJinglian(pack);
                break;
            case shenbingZhuankeJingwen:
                DealwithShenbingZhuankeJingwen(pack);
                break;
            case refreshZahuopu:
                DealwithRefreshZahuopu(pack);
                break;
            case queryZahuopu:
                DealwithQueryZahuopu(pack);
                break;
            case zahuopuGetOneItem:
                DealwithZahuopuGetOneItem(pack);
                break;
            case heroLevelUp:
                DealwithHeroLevelUp(pack);
                break;
            case queryHellTaskHeroInfo:
                DealwithQueryHellTaskHeroInfo(pack);
                break;
            case hellTaskBattle:
                DealwithHellTaskBattle(pack);
                break;
            case queryYuanshenOfHero:
                DealwithQueryYuanshenOfHero(pack);
                break;
            case churchLevelUp:
                DealwithChurchLevelUp(pack);
                break;
            case skillLevelUp:
                DealWithSkillLevelUp(pack);
                break;
            case getZhuangbeiAlbum:
                DealWithGetZhuangbeiAlbum(pack);
                break;
            case heroUpgrade:
                DealwithHeroUpgrade(pack);
                break;
            case getCityGuardCurrentStat:
                DealWithGetCityGuardCurrentStat(pack);
                break;
            case cityGuardBattle:
                DealWithCityGuardBattle(pack);
                break;
            case quitCityGuard:
                DealwithQuitCityGuard(pack);
                break;
            case getCityGuardLastDayReport:
                DealWithGetCityGuardLastDayReport(pack);
                break;
            case getMyCityGuardReward:
                DealWithGetMyCityGuardReward(pack);
                break;
            case queryBonus:
                DealwithQueryBonus(pack);
                break;
            case getBonus:
                DealwithGetBonus(pack);
                break;
            //case getChessBox:
            //    DealwithGetChessBox(pack);
             //   break;
            case queryRateTask:
                DealwithQueryRateTask(pack);
                break;
            case queryRateTaskBonus:
                DealwithQueryRateTaskBonus(pack);
                break;
            case getRateTaskBonus:
                DealwithGetRateTaskBonus(pack);
                break;
            case queryVipPrivilege:
                DealwithQueryVipPrivilege(pack);
                break;
            case upgradeShenbing:
                DealwithUpgradeShenbing(pack);
                break;
            case queryChargePacket:
                DealwithQueryChargePacket(pack);
                break;
            case unlockAssistant:
                DealwithUnlockAssistant(pack);
                break;
            case queryGiftActivity:
                DealwithQueryGiftActivity(pack);
                break;
            case getGiftActivity:
                DealwithGetGiftActivity(pack);
                break;
            case queryKilledMonster:
                DealwithQueryKilledMonster(pack);
                break;
            case getKilledMonsterBonus:
                DealwithGetKilledMonsterBonus(pack);
                break;
            case queryKilledMonsterBonus:
                DealwithQueryKilledMonsterBonus(pack);
                break;
            case castSilver:
                DealwithCastSilver(pack);
                break;
            case queryLegendNote:
                DealwithQueryLegendNote(pack);
                break;
            case challengeLegendNote:
                DealwithChallengeLegendNote(pack);
                break;
            case querySelfChallengeInfo:
                DealwithQuerySelfChallengeInfo(pack);
                break;
            case querySelfChallengeOrder:
                DealwithQuerySelfChallengeOrder(pack);
                break;
            case selfChallenge:
                DealwithSelfChallenge(pack);
                break;
            case selfChallengeGain:
                DealwithSelfChallengeGain(pack);
                break;
            case getSelfChallengeBox:
                DealwithGetSelfChallengeBox(pack);
                break;
            case queryProtectSpirit:
                DealwithQueryProtectSpirit(pack);
                break;
            case challengeProtectSpirit:
                DealwithChallengeProtectSpirit(pack);
                break;
            case getProtectSpiritBonus:
                DealwithGetProtectSpiritBonus(pack);
                break;
            case worshiProtectSpirit:
                DealwithWorshiProtectSpirit(pack);
                break;
            case queryDiscoverInfo:
                DealwithQueryDiscoverInfo(pack);
                break;
            case discover:
                DealwithDiscover(pack);
                break;
            case unlockDiscoverSeal:
                DealwithUnlockDiscoverSeal(pack);
                break;
            case queryEmail:
                DealwithQueryEmail(pack);
                break;
            case readEmail:
                DealwithReadEmail(pack);
                break;
            case writeEmail:
                DealwithWriteEmail(pack);
                break;
            case deleteEmail:
                DealwithDeleteEmail(pack);
                break;
            case queryGiftBag:
                DealwithQueryGiftBag(pack);
                break;
            case getGiftBag:
                DealwithGetGiftBag(pack);
                break;
            case queryAssessWeapon:
                DealwithQueryAssessWeapon(pack);
                break;
            case assessWeapon:
                DealwithAssessWeapon(pack);
                break;
            case queryPurify:
                DealwithQueryPurify(pack);
                break;
            case purify:
                DealwithPurify(pack);
                break;
            case confirmPurify:
                DealwithConfirmPurify(pack);
                break;
            case queryOrigin:
                DealwithQueryOrigin(pack);
                break;
            case queryHeroOtherInfo:
                DealwithQueryHeroOtherInfo(pack);
                break;
            case queryNotice:
                DealwithQueryNotice(pack);
                break;
            case queryMarket:
                DealwithQueryMarket(pack);
                break;
            case buyItemInMarket:
                DealwithBuyItemInMarket(pack);
                break;
            case queryInstruction:
                DealwithQueryInstruction(pack);
                break;
            case completeInstruction:
                DealwithCompleteInstruction(pack);
                break;
            default:
                LogMsg("%s, line %d,invalide cmd req_cmd=[%u]"
                    , __FILE__, __LINE__, int(ntohs(head->cmd)));
                break;
        }
    }
}




void ProcServerThread::DealwithRegister(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithRegister", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Register* reg = (SPCmd_Register*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Register))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        reg->client_account[ClientAccountMaxLen] = 0;
        reg->client_psw[ClientPswMaxLen] = 0;
    }
    if((strlen(reg->client_account) < 3)
        || strlen(reg->client_psw) < 3)
    {
        int rspDataLen = sizeof(SPCmd_RegisterRsp);
        
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = RegisterRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));

        
        SPCmd_RegisterRsp* rspBody = (SPCmd_RegisterRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);
        rspBody->server_time = htonl(time(0));
        
        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = 0;
        rsppack->new_client_id = true;
        rsppack->main_hero_id = 0;
        rsppack->new_main_hero_id = true;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    
    //生成clientId
    unsigned int clientId = 0;
    {
        //需要生成客户端ID
        char sql[1024];
        sprintf(sql, "select max(client_id) max_client_id "
            " from hellgate.client_id");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                clientId = atoi(Mysql_Thread_Conn->GetField("max_client_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        clientId++;

        std::string account_str, psw_str;
        Mysql_Thread_Conn->Escape(account_str, reg->client_account, strlen(reg->client_account));
        Mysql_Thread_Conn->Escape(psw_str, reg->client_psw, strlen(reg->client_psw));

        sprintf(sql, "insert into hellgate.client_id "
            " set client_id=%d, account='%s', psw='%s'"
            , clientId, account_str.c_str(), psw_str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            int rspDataLen = sizeof(SPCmd_RegisterRsp);

            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = RegisterRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_RegisterRsp* rspBody = (SPCmd_RegisterRsp*)((rspHead)+1);
            rspBody->err_code = htonl(AccountAlreadyExist);
            rspBody->server_time = htonl(time(0));

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = 0;
            rsppack->new_client_id = true;
            rsppack->main_hero_id = 0;
            rsppack->new_main_hero_id = true;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }

    //
    m_clientid2fdaccount[clientId] = pack->fd_account;

    int rspDataLen = sizeof(SPCmd_RegisterRsp);

    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = RegisterRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_RegisterRsp* rspBody = (SPCmd_RegisterRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->server_time = htonl(time(0));

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = clientId;
    rsppack->new_client_id = true;
    rsppack->main_hero_id = 0;
    rsppack->new_main_hero_id = true;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithClientLogin(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithClientLogin", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ClientLogin* login = (SPCmd_ClientLogin*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ClientLogin))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        login->client_account[ClientAccountMaxLen] = 0;
        login->client_psw[ClientPswMaxLen] = 0;
    }

    
    //验证账号密码
    unsigned int clientId = 0;
    std::string psw;
    {
        
        std::string account_str;
        Mysql_Thread_Conn->Escape(account_str, login->client_account, strlen(login->client_account));
        char sql[1024];
        sprintf(sql, "select client_id, psw "
            " from hellgate.client_id where account='%s'"
            , account_str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                clientId = atoi(Mysql_Thread_Conn->GetField("client_id"));
                psw = std::string(Mysql_Thread_Conn->GetField("psw"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(psw.length() == 0)
    {
        LogMsg("%s, line %d, psw is empty. account[%s]"
            , __FILE__, __LINE__, login->client_account);

        int rspDataLen = sizeof(SPCmd_ClientLoginRsp);
        rspDataLen = sizeof(SPCmd_ClientLoginRsp);

        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = clientLoginRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ClientLoginRsp* rspBody = (SPCmd_ClientLoginRsp*)((rspHead)+1);
        rspBody->err_code = htonl(AccountOrPswErr);
        rspBody->server_time = htonl(time(0));
        rspBody->hero_count = htonl(0);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = 0;
        rsppack->new_client_id = true;
        rsppack->main_hero_id = 0;
        rsppack->new_main_hero_id = true;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    if(psw != std::string(login->client_psw))
    {
        int rspDataLen = sizeof(SPCmd_ClientLoginRsp);
        rspDataLen = sizeof(SPCmd_ClientLoginRsp);

        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = clientLoginRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ClientLoginRsp* rspBody = (SPCmd_ClientLoginRsp*)((rspHead)+1);
        rspBody->err_code = htonl(AccountOrPswErr);
        rspBody->server_time = htonl(time(0));
        rspBody->hero_count = htonl(0);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = 0;
        rsppack->new_client_id = true;
        rsppack->main_hero_id = 0;
        rsppack->new_main_hero_id = true;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    

    //返回英雄列表
    std::vector<HeroInfo> heroVec;
    GetHeroList(clientId,heroVec);

    //如果clientID已登录，则kickout
    std::map<unsigned int, std::string>::iterator pos = m_clientid2fdaccount.find(clientId);
    if(pos != m_clientid2fdaccount.end() && pos->second!=pack->fd_account)
    {
        kickoutFdAcount(pos->second);
        m_clientid2fdaccount.erase(pos);
    }

    //
    m_clientid2fdaccount[clientId] = pack->fd_account;
    

    int rspDataLen = sizeof(SPCmd_ClientLoginRsp);
    rspDataLen = sizeof(SPCmd_ClientLoginRsp) + sizeof(HeroInfo)*heroVec.size();

    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = clientLoginRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ClientLoginRsp* rspBody = (SPCmd_ClientLoginRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->server_time = htonl(time(0));
    rspBody->hero_count = htonl(heroVec.size());
    HeroInfo* p = (HeroInfo*)rspBody->hero_data;
    for(int i=0; i<heroVec.size(); ++i, ++p)
    {
        hton_hero_info(heroVec[i],*p);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = clientId;
    rsppack->new_client_id = true;
    rsppack->main_hero_id = 0;
    rsppack->new_main_hero_id = true;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::DealwithReconnect(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithReconnect", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Reconnect* conn = (SPCmd_Reconnect*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Reconnect))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        conn->client_account[ClientAccountMaxLen] = 0;
        conn->client_psw[ClientPswMaxLen] = 0;
        conn->main_hero_id = ntohl(conn->main_hero_id);
    }

    
    //验证账号密码
    unsigned int clientId = 0;
    std::string psw;
    {
        
        char sql[1024];
        sprintf(sql, "select client_id, psw "
            " from hellgate.client_id where account='%s'"
            , conn->client_account);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                clientId = atoi(Mysql_Thread_Conn->GetField("client_id"));
                psw = std::string(Mysql_Thread_Conn->GetField("psw"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(psw.length() == 0)
    {
        LogMsg("%s, line %d, psw is empty. account[%s]"
            , __FILE__, __LINE__, conn->client_account);

        int rspDataLen = sizeof(SPCmd_ReconnectRsp);

        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = ReconnectRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ReconnectRsp* rspBody = (SPCmd_ReconnectRsp*)((rspHead)+1);
        rspBody->err_code = htonl(AccountOrPswErr);
        rspBody->server_time = htonl(time(0));

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = 0;
        rsppack->new_client_id = true;
        rsppack->main_hero_id = 0;
        rsppack->new_main_hero_id = true;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    if(psw != std::string(conn->client_psw))
    {
        int rspDataLen = sizeof(SPCmd_ReconnectRsp);

        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = ReconnectRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ReconnectRsp* rspBody = (SPCmd_ReconnectRsp*)((rspHead)+1);
        rspBody->err_code = htonl(AccountOrPswErr);
        rspBody->server_time = htonl(time(0));

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = 0;
        rsppack->new_client_id = true;
        rsppack->main_hero_id = 0;
        rsppack->new_main_hero_id = true;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    

    //验证主英雄
    {
        if(!isMainHeroOfClient(clientId, conn->main_hero_id))
        {
            int rspDataLen = sizeof(SPCmd_ReconnectRsp);

            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ReconnectRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ReconnectRsp* rspBody = (SPCmd_ReconnectRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);
            rspBody->server_time = htonl(time(0));

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = 0;
            rsppack->new_client_id = true;
            rsppack->main_hero_id = 0;
            rsppack->new_main_hero_id = true;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }

    //如果clientID已登录，则kickout
    std::map<unsigned int, std::string>::iterator pos = m_clientid2fdaccount.find(clientId);
    if(pos != m_clientid2fdaccount.end() && pos->second!=pack->fd_account)
    {
        kickoutFdAcount(pos->second);
        m_clientid2fdaccount.erase(pos);
    }

    //
    m_clientid2fdaccount[clientId] = pack->fd_account;
    

    int rspDataLen = sizeof(SPCmd_ReconnectRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ReconnectRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ReconnectRsp* rspBody = (SPCmd_ReconnectRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->server_time = htonl(time(0));

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = clientId;
    rsppack->new_client_id = true;
    rsppack->main_hero_id = conn->main_hero_id;
    rsppack->new_main_hero_id = true;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithCreateHero(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCreateHero", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CreateHero* create = (SPCmd_CreateHero*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CreateHero))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        create->profession_id = ntohl(create->profession_id);
        create->name[HeroNameMaxLen] = 0;
    }

    unsigned int client_id = pack->client_id;

    //检查该账号是否还能创建新的英雄
    {
    }
    //检查职业合法性
    {
    }

    //需要生成hero ID
    unsigned hero_id;
    char sql[1024];
    sprintf(sql, "select max(hero_id) max_hero_id "
        " from hellgate.hero_infor");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            hero_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    hero_id++;

    //
    unsigned int position = 0;
    if(create->profession_id == Profession_Yemanren
        || create->profession_id == Profession_Chike)
    {
        position = 1;
    }
    else if(create->profession_id == Profession_Fashi)
    {
        position = 3;
    }
    else
    {
        LogMsg("%s, line %d, profession[%u] invalide. create hero failed"
                    , __FILE__, __LINE__, create->profession_id);
        return;
    }

    //
    std::string name_str;
    Mysql_Thread_Conn->Escape(name_str, create->name, strlen(create->name));
    sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, is_unlocked=1, " 
        " is_unlock_able=1, parent_hero_id=0, profession_id=%u, "
        " level=1, hero_name='%s', exp_current=0, position=%u, vit_current=%u, vit_last_modify_time=%u"
        , hero_id, create->profession_id, name_str.c_str(), position, Vitality_Total, (unsigned int)time(0));
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    //创建英雄vip信息
    sprintf(sql, "insert into hellgate.hero_vip_info set hero_id=%u "
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    
    { //赠送一管体力
        insert_into_email(hero_id, 0, EmailType_Bonus, (unsigned int)EmailID_PresentVitality);
    }
    //
    //
    sprintf(sql, "insert into hellgate.hero_list set client_id=%u, hero_id=%u"
        , client_id, hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    
    //初始化英雄
    InitHero((Profession)create->profession_id, hero_id);

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_CreateHeroRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = createHeroRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CreateHeroRsp* rspBody = (SPCmd_CreateHeroRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->hero_id = htonl(hero_id);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::DealwithCreateAssit(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCreateAssit", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CreateAssit* create = (SPCmd_CreateAssit*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CreateAssit))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        create->profession_id = ntohl(create->profession_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //检查该账号是否还能创建新的英雄
    {
    }
    //检查职业合法性
    {
    }
    //检查当前是否进入了助手殿堂
    {
    }

    //需要生成hero ID
    unsigned assit_hero_id = createAssitant(main_hero_id, create->profession_id);

    //获取hero detail
    HeroDetail assit_detail;
    GetHeroDetail(assit_hero_id,assit_detail);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_CreateAssitRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = createAssitRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CreateAssitRsp* rspBody = (SPCmd_CreateAssitRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    hton_hero_detail(assit_detail, rspBody->hero_detail);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}

void ProcServerThread::DealwithGetHerosInTeam(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetHerosInTeam", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetHerosInTeam* get = (SPCmd_GetHerosInTeam*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetHerosInTeam))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->hero_id = ntohl(get->hero_id);
    }

    unsigned int client_id = pack->client_id;
    if(!isMainHeroOfClient(client_id, get->hero_id))
    {
        //这个根本不是主英雄
        SPHead* rspHead;
        int rspDataLen 
            = sizeof(SPCmd_GetHerosInTeamRsp);
        
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = getHerosInTeamRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_GetHerosInTeamRsp* rspBody = (SPCmd_GetHerosInTeamRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);
        rspBody->hero_count = htonl(0);
        
        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = get->hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //首先更玩家体力 
    updateHeroVitality(get->hero_id);

    //获取教堂等级
    unsigned int church_level = getChurchLevel(get->hero_id);
    

    //获取英雄列表
    std::vector<unsigned int> hero_id_vec;
    hero_id_vec.insert(hero_id_vec.end(), get->hero_id);
    {
        char sql[1024];
        sprintf(sql, "select hero_id from hellgate.hero_infor where parent_hero_id=%u"
            , get->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int assit_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                hero_id_vec.insert(hero_id_vec.end(), assit_id);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int top_list_order = 1000000;
    { //获取此英雄排名
        char sql[1024];
        sprintf(sql, "select hero_order from hellgate.top_hero_list where hero_id=%u"
            , get->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if (Mysql_Thread_Conn->FetchRow() != NULL)
            {
                top_list_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    //获取hero detail
    std::vector<HeroDetail> hero_detail_vec;
    for(int i=0; i<hero_id_vec.size(); ++i)
    {
        HeroDetail detail;
        GetHeroDetail(hero_id_vec[i], detail);

        hero_detail_vec.insert(hero_detail_vec.end(), detail);

        if(top_list_order <= 3 && hero_id_vec[i] == get->hero_id) {
            //前三名登陆插入到跑马灯队列中
            insert_marquee_message(MarqueeType_TopList, get->hero_id, top_list_order);
        }
    }
    
    
    //

    SPHead* rspHead;
    int rspDataLen 
        = sizeof(SPCmd_GetHerosInTeamRsp) + sizeof(HeroDetail)*hero_detail_vec.size();
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getHerosInTeamRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetHerosInTeamRsp* rspBody = (SPCmd_GetHerosInTeamRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->church_level = htonl(church_level);
    
    rspBody->hero_count = htonl(hero_detail_vec.size());
    HeroDetail* p=rspBody->hero_detail_arr;
    for(int i=0; i<hero_detail_vec.size(); i++, p++)
    {
        hton_hero_detail(hero_detail_vec[i], *p);
    }
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = get->hero_id;
    rsppack->new_main_hero_id = true;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}

void ProcServerThread::DealwithGetZhuangbeiInTeam(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetZhuangbeiInTeam", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetZhuangbeiInTeam* get = (SPCmd_GetZhuangbeiInTeam*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetZhuangbeiInTeam))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_id"
            " from hellgate.zhuangbei_list"
            " where owner_hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetZhuangbeiInTeamRsp) + zhuangbei_detail_data_len;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getZhuangbeiInTeamRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetZhuangbeiInTeamRsp* rspBody = (SPCmd_GetZhuangbeiInTeamRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());

    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

struct hero_and_zb
{
    unsigned int hero_id;
    std::vector<unsigned long long> zb_arr;
};
void ProcServerThread::DealwithEquipZhuangbei(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithEquipZhuangbei", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_EquipZhuangbei* eq = (SPCmd_EquipZhuangbei*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_EquipZhuangbei))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        eq->hero_count = ntohl(eq->hero_count);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    
    //解析请求包
    std::vector<hero_and_zb> hero_zb_vec;
    {
        if(eq->hero_count > 20)
        {
            LogMsg("%s, line %d, fuck"
                    , __FILE__, __LINE__);
            return;
        }
        
        HeroAndZhuangbei* pHero = eq->hero_zb_arr;
        for(int hero_i=0; hero_i<eq->hero_count; ++hero_i)
        {
            
            pHero->hero_id = ntohl(pHero->hero_id);
            pHero->zb_count = ntohl(pHero->zb_count);

            if(pHero->zb_count > 6)
            {
                LogMsg("%s, line %d, fuck"
                        , __FILE__, __LINE__);
                return;
            }

            hero_and_zb h_z;
            h_z.hero_id = pHero->hero_id;
            
            unsigned long long *pZB = pHero->zb_id_arr;
            for(int zb_i=0; zb_i<pHero->zb_count; ++zb_i)
            {
                h_z.zb_arr.insert(h_z.zb_arr.end(), Utl::ntohll(*pZB));

                pZB++;
            }

            //
            hero_zb_vec.insert(hero_zb_vec.end(), h_z);

            //
            unsigned long long* tmp_p = pHero->zb_id_arr;
            tmp_p += pHero->zb_count;
            pHero = (HeroAndZhuangbei*)tmp_p;
        }
    }

    //检查合法性
    for(int hero_i=0; hero_i<hero_zb_vec.size(); ++hero_i)
    {
        
        if(isZhuangbeiConfilct(hero_zb_vec[hero_i].zb_arr))
        {
            LogMsg("%s, line %d, conflict"
                    , __FILE__, __LINE__);

            int rspDataLen = sizeof(SPCmd_EquipZhuangbeiRsp);

            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = equipZhuangbeiRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_EquipZhuangbeiRsp* rspBody = (SPCmd_EquipZhuangbeiRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
        
        for(int zb_i=0; zb_i<hero_zb_vec[hero_i].zb_arr.size(); ++zb_i)
        {
            if(!isHeroBelong2Team(hero_zb_vec[hero_i].hero_id, main_hero_id)
                || !canZhuangbeiEquipToHero(hero_zb_vec[hero_i].zb_arr[zb_i], hero_zb_vec[hero_i].hero_id))
            {
                LogMsg("%s, line %d, zhuangbei[%llu] can not equip to hero[%u]"
                    , __FILE__, __LINE__, hero_zb_vec[hero_i].zb_arr[zb_i], hero_zb_vec[hero_i].hero_id);

                int rspDataLen = sizeof(SPCmd_EquipZhuangbeiRsp);

                SPHead* rspHead;
                (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
                (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
                (rspHead)->protocol_ver = 1;
                (rspHead)->cmd = equipZhuangbeiRsp;
                (rspHead)->data_len = rspDataLen;
                //将包头转换为网络字节序
                hton_SPHead((rspHead));
                
                SPCmd_EquipZhuangbeiRsp* rspBody = (SPCmd_EquipZhuangbeiRsp*)((rspHead)+1);
                rspBody->err_code = htonl(Error);

                Packet* rsppack = new Packet;
                rsppack->fd_account = pack->fd_account;
                rsppack->client_id = pack->client_id;
                rsppack->main_hero_id = pack->main_hero_id;
                rsppack->packdata = (char*)rspHead;

                m_outport_q->push(rsppack);

                return;
            }

            
        }
    }

    //装
    for(int hero_i=0; hero_i<hero_zb_vec.size(); ++hero_i)
    {
        //先脱
        {
            char sql[1024];
            sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=0 "
                " where zhuangbei_hero_id=%u"
                , hero_zb_vec[hero_i].hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //穿
        if(hero_zb_vec[hero_i].zb_arr.size() > 0)
        {
            char sql[1024];
            sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=%u "
                " where zhuangbei_id=%llu"
                , hero_zb_vec[hero_i].hero_id, hero_zb_vec[hero_i].zb_arr[0]);
            for(int zb_i=1; zb_i<hero_zb_vec[hero_i].zb_arr.size(); ++zb_i)
            {
                char buf[64];
                sprintf(buf, " or zhuangbei_id=%llu ", hero_zb_vec[hero_i].zb_arr[zb_i]);
                strcat(sql, buf);
            }
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

            
            //换装结束 更新战斗力
            calculate_fight_capacity(hero_zb_vec[hero_i].hero_id);
        }

        
    }



    //
    int rspDataLen = sizeof(SPCmd_EquipZhuangbeiRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = equipZhuangbeiRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_EquipZhuangbeiRsp* rspBody = (SPCmd_EquipZhuangbeiRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}


void ProcServerThread::DealwithAdjustFormation(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithAdjustFormation", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_AdjustFormation* adjust = (SPCmd_AdjustFormation*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_AdjustFormation))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        
        for(int i=0; i<FormationHeroAcountMax; ++i)
        {
            adjust->hero_id_arr[i] = ntohl(adjust->hero_id_arr[i]);
        }
    }

    unsigned int main_hero_id = pack->main_hero_id;

    bool result_flag = check_and_adjust_formation(main_hero_id, adjust->hero_id_arr);
    //
    int rspDataLen = sizeof(SPCmd_AdjustFormationRsp);

    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = adjustFormationRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_AdjustFormationRsp* rspBody = (SPCmd_AdjustFormationRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::DealwithGetTaskList(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetTaskList", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetTaskList* get = (SPCmd_GetTaskList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetTaskList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //首先获取主任务进度
    unsigned int maintask_last_actived  = 1;
    unsigned int maintask_status = TaskStatus_NotGot;
    {
        //
        char sql[1024];

        sprintf(sql, "select maintask_last_actived, status "
            " from hellgate.hero_maintask_progress "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                maintask_status = atoi(Mysql_Thread_Conn->GetField("status"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    if(maintask_last_actived > MainTaskId_Implemented_Max)
    {
        maintask_last_actived = MainTaskId_Implemented_Max;
        maintask_status = TaskStatus_Submitted;
    }

    //获取副本任务
    //std::vector<SubTaskInfo> sub_task_vec;
    //getSubTaskList(main_hero_id, sub_task_vec);

    //
    int rspDataLen = sizeof(SPCmd_GetTaskListRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getTaskListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetTaskListRsp* rspBody = (SPCmd_GetTaskListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->maintask_last_actived = htonl(maintask_last_actived);
    rspBody->maintask_status = htonl(maintask_status);

    /*
    rspBody->subtask_count = htonl(sub_task_vec.size());
    SubTaskInfo* p = rspBody->task_arr;
    for(int i=0; i<sub_task_vec.size(); ++i, ++p)
    {
        hton_subtask_info(sub_task_vec[i],*p);
    }
    */

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetTaskChessBoard(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetTaskChessBoard", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetTaskChessBoard* get = (SPCmd_GetTaskChessBoard*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetTaskChessBoard))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->task_id = ntohl(get->task_id);
    }

    //判断task_id合法性
    if(get->task_id == 0)
    {
        LogMsg("%s, line %d, mysql exception. task_id[%u] invalide"
                        , __FILE__, __LINE__, get->task_id);
        return;
    }

    unsigned int main_hero_id = pack->main_hero_id;

#ifdef _DEBUG
    LogMsg("%s, line %d,hero[%u] task[%u] ", __FILE__, __LINE__, main_hero_id, get->task_id);
#endif //_DEBUG


    //验证合法性
    {
        //首先获取主任务进度
        unsigned int maintask_last_actived  = 1;
        unsigned int maintask_status = TaskStatus_NotGot;
        {
            char sql[1024];
            sprintf(sql, "select maintask_last_actived, status "
                " from hellgate.hero_maintask_progress "
                " where hero_id=%u"
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                    maintask_status = atoi(Mysql_Thread_Conn->GetField("status"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //
        if((maintask_last_actived < get->task_id)
            || (maintask_last_actived == get->task_id && (maintask_status == TaskStatus_NotGot || maintask_status == TaskStatus_NotActived)))
        {
            //
            int rspDataLen = sizeof(SPCmd_GetTaskChessBoardRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = GetTaskChessboardRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_GetTaskChessBoardRsp* rspBody = (SPCmd_GetTaskChessBoardRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            //rspBody->grid_stat = chess_board;

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }

    //重新刷新棋盘关卡
    if(get->need_refresh_chessboard) {
        refreshChessBoard(main_hero_id, get->task_id);
    }
    
    //获取棋盘规格
    unsigned int grid_count_heng = 0;
    unsigned int grid_count_shu = 0;
    CS::getTaskChessboardFormat(get->task_id, grid_count_heng, grid_count_shu);
    unsigned int grid_count_total = 1 + grid_count_heng*grid_count_shu;
    
    const int max_grid_count = 17;
    TaskGridInfo chess_board[max_grid_count];
    int grid_id[max_grid_count];
    memset(chess_board, 0, sizeof(TaskGridInfo) *max_grid_count);
    memset(grid_id, 0, sizeof(int) *max_grid_count);

    { //查询棋盘信息
        char sql[1024];
        sprintf(sql, "select * from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u "
            , main_hero_id, get->task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                char stat_field[32], id_field[32];
                for(int i=0; i<grid_count_total; ++i) {
                    sprintf(id_field, "grid_id_%d", i);
                    sprintf(stat_field, "grid_stat_%d", i);
                    
                    chess_board[i].stat = atoi(Mysql_Thread_Conn->GetField(stat_field));
                    grid_id[i] = atoi(Mysql_Thread_Conn->GetField(id_field));
                    if(grid_id[i] == 0) {
                        chess_board[i].type = TaskGridType_Empty;
                    }
                    else if(grid_id[i] > 0) {
                        chess_board[i].type = TaskGridType_Monster;
                    }
                    else if(grid_id[i] == -1) {
                        chess_board[i].type = TaskGridType_Box;
                    }
                    else {
                        LogMsg("%s, line %d, hero[%u] task[%u] chessboard error "
                            , __FILE__, __LINE__, main_hero_id, get->task_id);
                        return ;
                    }
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<grid_count_total; ++i) {
        if(chess_board[i].type != TaskGridType_Monster)
            continue;

        char sql[1024];
        sprintf(sql, "select task_type "
            " from hellgate.task_template_test "
            " where task_id=%u and guanqia_id=%u "
            , get->task_id, grid_id[i]);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                chess_board[i].monster_type = atoi(Mysql_Thread_Conn->GetField("task_type"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    

    //
    int rspDataLen = sizeof(SPCmd_GetTaskChessBoardRsp) 
        + sizeof(TaskGridInfo)* (grid_count_heng *grid_count_shu);
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = GetTaskChessboardRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetTaskChessBoardRsp* rspBody = (SPCmd_GetTaskChessBoardRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->horizontal_count = htonl(grid_count_heng);
    rspBody->vertical_count = htonl(grid_count_shu);

    TaskGridInfo *p = rspBody->grid_arr;
    for(int i=0; i<grid_count_total; ++i, ++p) {
        p->type = htonl(chess_board[i].type); 
        p->stat = htonl(chess_board[i].stat); 
        p->monster_type = htonl(chess_board[i].monster_type); 
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithFlopTaskGrid(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithFlopTaskGrid", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_FlopTaskGrid* ft = (SPCmd_FlopTaskGrid*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_FlopTaskGrid))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        ft->task_id = ntohl(ft->task_id);
        ft->grid_id = ntohl(ft->grid_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int boss_stat, grid_stat;
    std::vector<ItemInfo> item_vec;
    int result_code = check_and_flop(main_hero_id, ft->task_id, ft->grid_id,
        boss_stat, grid_stat, item_vec);
  

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_FlopTaskGridRsp) + sizeof(ItemInfo)*item_vec.size();
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = flopTaskGridRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_FlopTaskGridRsp* rspBody = (SPCmd_FlopTaskGridRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_code);
    rspBody->boss_stat = htonl(boss_stat);
    rspBody->grid_stat = htonl(grid_stat);
    rspBody->count = htonl(item_vec.size());

    ItemInfo* p = rspBody->item_arr;
    for(int i=0; i<item_vec.size(); ++i, ++p) {
        p->type = htonl(item_vec[i].type);
        p->count = htonl(item_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}


void ProcServerThread::DealwithGetItemsInTeam(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetItemsInTeam", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetItemsInTeam* get = (SPCmd_GetItemsInTeam*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetItemsInTeam))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //获取item列表
    std::vector<ItemInfo> item_vec;
    {
        char sql[1024];
        sprintf(sql, "select item_type, item_count from hellgate.items_in_team "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ItemInfo item;
                
                item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                
                //
                //
                if(item.count > 0)
                {
                    item_vec.insert(item_vec.end(), item);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetItemsInTeamRsp) + sizeof(ItemInfo)*item_vec.size();
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getItemsInTeamRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetItemsInTeamRsp* rspBody = (SPCmd_GetItemsInTeamRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->count = htonl(item_vec.size());

    ItemInfo* p = rspBody->item_arr;
    for(int i=0; i<item_vec.size(); ++i, ++p)
    {
        p->type = htonl(item_vec[i].type);
        p->count = htonl(item_vec[i].count);
    }
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithZhuangbeiQianghua(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZhuangbeiQianghua", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBQianghua* qh = (SPCmd_ZBQianghua*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBQianghua))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qh->zhuangbei_id = Utl::ntohll(qh->zhuangbei_id);
        
        /* 20140521 去掉熔金石强化 */
        qh->b_gold_star = false;
    }

    unsigned int main_hero_id = pack->main_hero_id;
       
    //判断所需材料是否足够，如果足够则强化
    bool qianghua_suc = false;
    QianghuaInfo qh_info;
    {
        CheckAndQianghuaZhuangbei(main_hero_id, qh->zhuangbei_id, 
            qh->b_gold_star, qianghua_suc, qh_info);

        if(!qianghua_suc)
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBQianghuaRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBQianghuaRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBQianghuaRsp* rspBody = (SPCmd_ZBQianghuaRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_ZBQianghuaRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBQianghuaRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBQianghuaRsp* rspBody = (SPCmd_ZBQianghuaRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->qianghua_info.id = qh_info.id;
    rspBody->qianghua_info.level = qh_info.level;
    rspBody->qianghua_info.percent = qh_info.percent;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::DealwithZhuangbeiQianghuaHuitui(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZhuangbeiQianghuaHuitui", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBQianghuaHuitui* ht = (SPCmd_ZBQianghuaHuitui*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBQianghuaHuitui))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        ht->zhuangbei_id = Utl::ntohll(ht->zhuangbei_id);
        ht->keep_count = ntohl(ht->keep_count);
    }

    unsigned int main_hero_id = pack->main_hero_id;
       
    //判断所需材料是否足够，如果足够则强化
    bool ht_suc = CheckAndHuituiZhuangbei(main_hero_id, ht->zhuangbei_id, ht->keep_count, ht->id_arr);
    if(!ht_suc) {
        int rspDataLen = sizeof(SPCmd_ZBQianghuaHuituiRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = ZBQianghuaHuituiRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ZBQianghuaHuituiRsp* rspBody = (SPCmd_ZBQianghuaHuituiRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    

    //
    __ZhuangbeiDetail new_detail;
    getZhuangbeiDetail(ht->zhuangbei_id,main_hero_id,new_detail);
    
    //
    int rspDataLen = sizeof(SPCmd_ZBQianghuaHuituiRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBQianghuaHuituiRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBQianghuaHuituiRsp* rspBody = (SPCmd_ZBQianghuaHuituiRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    memcpy(&rspBody->new_qianghua_data
        , &new_detail.qianghua_data
        , sizeof(rspBody->new_qianghua_data));

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithZhuangbeiChaijie(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZhuangbeiChaijie", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBChaijie* cj = (SPCmd_ZBChaijie*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBChaijie))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        cj->zb_count = htonl(cj->zb_count);
        for(int i=0; i<cj->zb_count; ++i)
        {
            cj->zb_id_arr[i]  = Utl::ntohll(cj->zb_id_arr[i]);
        }
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<unsigned long long> zb_id_vec;
    for(int i=0; i<cj->zb_count; ++i)
    {
        zb_id_vec.push_back(cj->zb_id_arr[i]);
    }
       
    //
    std::vector<ItemInfo> item_vec;     //拆解装备获取的材料
    std::vector<ItemInfo> re_item_vec;  //返还的材料
    {

        if(!CheckAndChaijieZhuangbei(main_hero_id, zb_id_vec, item_vec, re_item_vec))
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBChaijieRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBChaijieRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBChaijieRsp* rspBody = (SPCmd_ZBChaijieRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_ZBChaijieRsp)
            + sizeof(int) + sizeof(ItemInfo) *(item_vec.size() +re_item_vec.size());
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBChaijieRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBChaijieRsp* rspBody = (SPCmd_ZBChaijieRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->count = htonl(item_vec.size());
    
    ItemInfo *p = rspBody->item_arr;
    for(int i=0; i<item_vec.size(); ++i, ++p) {
        p->type = htonl(item_vec[i].type);
        p->count = htonl(item_vec[i].count);
    }

    int *re_count_p = (int *)p;
    *re_count_p = htonl(re_item_vec.size());
    
    p = (ItemInfo*)(re_count_p +1);
    for(int i=0; i<re_item_vec.size(); ++i, ++p) {
        p->type = htonl(re_item_vec[i].type);
        p->count = htonl(re_item_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryAllMofaJinghua(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryAllMofaJinghua", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryAllMofaJinghua* query = (SPCmd_QueryAllMofaJinghua*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryAllMofaJinghua))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //获取jinghua列表
    std::vector<MofaJinghua> item_vec;
    {
        char sql[1024];
        sprintf(sql, "select zb_type, attr_type, jh_level, jh_count "
            " from hellgate.mofa_jinghua_in_team "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                MofaJinghua item;
                
                item.zb_type = atoi(Mysql_Thread_Conn->GetField("zb_type"));
                item.attr_type = atoi(Mysql_Thread_Conn->GetField("attr_type"));
                item.level = atoi(Mysql_Thread_Conn->GetField("jh_level"));
                item.count = atoi(Mysql_Thread_Conn->GetField("jh_count"));
                
                //
                if(item.count > 0)
                {
                    item_vec.insert(item_vec.end(), item);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryAllMofaJinghuaRsp) + sizeof(MofaJinghua)*item_vec.size();
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryAllMofaJinghuaRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryAllMofaJinghuaRsp* rspBody = (SPCmd_QueryAllMofaJinghuaRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->count = htonl(item_vec.size());

    MofaJinghua* p = rspBody->jinghua_arr;
    for(int i=0; i<item_vec.size(); ++i, ++p)
    {
        p->zb_type = htonl(item_vec[i].zb_type);
        p->attr_type = htonl(item_vec[i].attr_type);
        p->level = htonl(item_vec[i].level);
        p->count = htonl(item_vec[i].count);
    }
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}

void ProcServerThread::DealwithZBCuiqu(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZBCuiqu", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBCuiqu* cq = (SPCmd_ZBCuiqu*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBCuiqu))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        cq->zhuangbei_id = Utl::ntohll(cq->zhuangbei_id);
        cq->attr_type = ntohl(cq->attr_type);
        cq->attr_value = ntohl(cq->attr_value);
    }

    unsigned int main_hero_id = pack->main_hero_id;
       
    //
    bool cuiqu_suc = false;
    unsigned int zb_type = 0;
    unsigned int jh_level = 0;
    {

        if(!checkAndCuiqu(main_hero_id, cq->zhuangbei_id,(AttrType)cq->attr_type,cq->attr_value,cq->is_fumo_attr
                , cuiqu_suc, zb_type,jh_level))
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBCuiquRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBCuiquRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBCuiquRsp* rspBody = (SPCmd_ZBCuiquRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }

    //
    

    //
    int rspDataLen = sizeof(SPCmd_ZBCuiquRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBCuiquRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBCuiquRsp* rspBody = (SPCmd_ZBCuiquRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->sucess = cuiqu_suc;
    rspBody->jinghua.zb_type = htonl(zb_type);
    rspBody->jinghua.attr_type = htonl(cq->attr_type);
    rspBody->jinghua.level = htonl(jh_level);
    rspBody->jinghua.count = htonl((int)1);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithZBFumo(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZBFumo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBFumo* fm = (SPCmd_ZBFumo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBFumo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        fm->zhuangbei_id = Utl::ntohll(fm->zhuangbei_id);
        fm->jinghua.zb_type = ntohl(fm->jinghua.zb_type);
        fm->jinghua.attr_type = ntohl(fm->jinghua.attr_type);
        fm->jinghua.level = ntohl(fm->jinghua.level);
        fm->jinghua.count = ntohl(fm->jinghua.count);
    }

    unsigned int main_hero_id = pack->main_hero_id;
       
    //
    bool fm_suc = false;
    ZBAttr new_fm_attr;
    {

        if(!checkAndFumo(main_hero_id,fm->zhuangbei_id,fm->jinghua,fm_suc,new_fm_attr))
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBFumoRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBFumoRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBFumoRsp* rspBody = (SPCmd_ZBFumoRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }

    //
    

    //
    int rspDataLen = sizeof(SPCmd_ZBFumoRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBFumoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBFumoRsp* rspBody = (SPCmd_ZBFumoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->sucess = fm_suc;
    rspBody->new_fumo_attr.attr_type = htonl(new_fm_attr.attr_type);
    rspBody->new_fumo_attr.attr_value = htonl(new_fm_attr.attr_value);
    rspBody->new_fumo_attr.cuiqu_suc_ratio = htonl(new_fm_attr.cuiqu_suc_ratio);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


/*
void ProcServerThread::DealwithZhuangbeiZhuankong(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZhuangbeiZhuankong", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBZhuankong* zk = (SPCmd_ZBZhuankong*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBZhuankong))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        zk->zhuangbei_id = Utl::ntohll(zk->zhuangbei_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    //
    {

        if(!CheckAndZhuangkong(main_hero_id, zk->zhuangbei_id))
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBZhuankongRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBZhuankongRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBZhuankongRsp* rspBody = (SPCmd_ZBZhuankongRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_ZBZhuankongRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBZhuankongRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBZhuankongRsp* rspBody = (SPCmd_ZBZhuankongRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}
*/
void ProcServerThread::DealwithXiangBaoshi(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithXiangBaoshi", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBXiangBaoshi* xbs = (SPCmd_ZBXiangBaoshi*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBXiangBaoshi))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        xbs->zhuangbei_id = Utl::ntohll(xbs->zhuangbei_id);
        xbs->baoshi_type = ntohl(xbs->baoshi_type);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    //判断所需材料是否足够，如果足够则强化
    {

        if(!CheckAndXiangbaoshi(main_hero_id, xbs->zhuangbei_id, xbs->baoshi_type))
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBXiangBaoshiRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBXiangBaoshiRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBXiangBaoshiRsp* rspBody = (SPCmd_ZBXiangBaoshiRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_ZBXiangBaoshiRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBXiangBaoshiRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBXiangBaoshiRsp* rspBody = (SPCmd_ZBXiangBaoshiRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithChaiBaoshi(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChaiBaoshi", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBChaiBaoshi* cbs = (SPCmd_ZBChaiBaoshi*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZBChaiBaoshi))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        cbs->zhuangbei_id = Utl::ntohll(cbs->zhuangbei_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    //判断所需材料是否足够，如果足够则强化
    {

        if(!CheckAndChaibaoshi(main_hero_id, cbs->zhuangbei_id))
        {
            //
            int rspDataLen = sizeof(SPCmd_ZBChaiBaoshiRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = ZBChaiBaoshiRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ZBChaiBaoshiRsp* rspBody = (SPCmd_ZBChaiBaoshiRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_ZBChaiBaoshiRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = ZBChaiBaoshiRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBChaiBaoshiRsp* rspBody = (SPCmd_ZBChaiBaoshiRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithBaoshiHecheng(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithBaoshiHecheng", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_BaoshiHecheng* hc = (SPCmd_BaoshiHecheng*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_BaoshiHecheng))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        hc->baoshi_type = ntohl(hc->baoshi_type);
        hc->count = ntohl(hc->count);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    //判断所需材料是否足够
    {

        if(!CheckAndHechengBaoshi(main_hero_id, hc->baoshi_type, hc->count))
        {
            //
            int rspDataLen = sizeof(SPCmd_BaoshiHechengRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = BaoshiHechengRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_BaoshiHechengRsp* rspBody = (SPCmd_BaoshiHechengRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Error);

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_BaoshiHechengRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = BaoshiHechengRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_BaoshiHechengRsp* rspBody = (SPCmd_BaoshiHechengRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithBattle(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithBattle", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Battle* bt = (SPCmd_Battle*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Battle))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        bt->task_id = ntohl(bt->task_id);
        bt->grid_id = ntohl(bt->grid_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

#ifdef _DEBUG
LogMsg("%s, line %d,Battle hero[%u] task[%u] grid[%u]"
    , __FILE__, __LINE__, main_hero_id, bt->task_id, bt->grid_id);
#endif //_DEBUG

    
    //判断task和grid是否当前可进入
    if(!canHeroEnterTaskGrid(main_hero_id, bt->task_id, bt->grid_id, true))
    {
        //
        int rspDataLen = sizeof(SPCmd_BattleRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = BattleRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_BattleRsp* rspBody = (SPCmd_BattleRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //消耗体力
    bool vit_enought = true;
    if(isBOSS(bt->task_id,bt->grid_id)) { //boss关扣除体力 普通牌已扣
        vit_enought = subVitality(main_hero_id,Vitality_GuanQia_Boss);
    }
    
    if(!vit_enought) {
        int rspDataLen = sizeof(SPCmd_BattleRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = BattleRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_BattleRsp* rspBody = (SPCmd_BattleRsp*)((rspHead)+1);
        rspBody->err_code = htonl(TiliNotEnought);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //特殊关卡战斗前加入新助手
    unsigned int assist_id = 0;
    addAssistAtSpecialTaskGrid(main_hero_id, bt->task_id, bt->grid_id, assist_id);
    if(assist_id > 0)
    {
        //发新增助手的通知给客户端
        sendNewAssistJoinRsp(main_hero_id, assist_id);
    }

    //查询我方上阵阵型
    unsigned int team_pos_vec[4] = {0, 0, 0, 0};
    {
        std::vector<int> arr;
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , main_hero_id, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, main_hero_id, pos);
                }
                else
                {
                    team_pos_vec[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询怪物阵型
    unsigned int monster_pos_vec_1[4] = {0, 0, 0, 0};
    unsigned int monster_pos_vec_2[4] = {0, 0, 0, 0};
    unsigned int monster_pos_vec_3[4] = {0, 0, 0, 0};
    getGuanQiaGuaiWu(main_hero_id, bt->task_id, bt->grid_id
        , monster_pos_vec_1, monster_pos_vec_2, monster_pos_vec_3);

    //查询总共几波怪物
    unsigned int guaiwuAttachTime = getGuaiwuAttackCountOfTask(bt->task_id,bt->grid_id);
    
    //生成战斗脚本
    char* rspHead = NULL;
    HeroState teamHp;
    bool battle_win = true;
    int attached_round = 0;
    {
        ScriptBuilderUserData userData;
        FightSUD f_sud;
        userData.data = &f_sud;
        
        //HeroState teamHp;
        f_sud.heroId = main_hero_id;
        f_sud.taskId = bt->task_id;
        f_sud.gridId = bt->grid_id;
        FightScriptBuilder scriptBuild;
        std::vector<FightScript> team_script_vec;

        unsigned int fight_index = 1;
        if(guaiwuAttachTime >= 3)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 4)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 2)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_2
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 5)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_2
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }

        if(battle_win) //最后一个波一定是需要的
        {
            //SpecialControl SControl = SC_NONE;
            f_sud.boss_freezy = false;
            if(bt->task_id == 39 && isBOSS(bt->task_id,bt->grid_id))
            {
                f_sud.boss_freezy = true;
            }
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_3
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 6)
        {
            //SpecialControl SControl = SC_NONE;
            f_sud.boss_freezy = false;
            if(bt->task_id == 39 && isBOSS(bt->task_id,bt->grid_id))
            {
                f_sud.boss_freezy = true;
            }
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_3
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }

        attached_round = fight_index -1; //打赢怪物波数
        rspHead = scriptBuild.FightScript_2_Package(team_script_vec);

        
        if(battle_win && !isBOSS(bt->task_id,bt->grid_id)) { //打赢了 累计击杀怪物量 不计算boss关卡
            unsigned int common_count = 0;
            unsigned int elite_count = 0;
            for(int i=0; i<team_script_vec.size(); i++) {
                FightScript team_script = team_script_vec[i];

                for(int j=0; j<FormationHeroAcountMax; j++) {
                    if(team_script.init.oppositeTeam[j].hero_type == Type_Guaiwu_putong)
                        common_count++;
                    else if(team_script.init.oppositeTeam[j].hero_type == Type_Guaiwu_jingying)
                        elite_count++;
                }
            }

            update_killed_monster_counts(main_hero_id, common_count, elite_count);
        }
        
    }


    //判断是否需要修改任务状态
    unsigned int last_maintask_id = 0;
    unsigned int last_task_stat = TaskStatus_NotActived;
    {
        //
        char sql[1024];

        sprintf(sql, "select maintask_last_actived, status "
            " from hellgate.hero_maintask_progress "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                last_maintask_id = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                last_task_stat = atoi(Mysql_Thread_Conn->GetField("status"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //如果胜利，则设置grid为已探索
    if(battle_win )
    {
        setChessBoardGridDiscovered(main_hero_id, bt->task_id, bt->grid_id);
    }
    
    //当前任务的boss关打赢了，并且当前任务状态还没有完成和提交
    if(battle_win && isBOSS(bt->task_id,bt->grid_id) && bt->task_id==last_maintask_id 
        && last_task_stat!=TaskStatus_Finished && last_task_stat!=TaskStatus_Submitted)
    {
        ChangeTaskStat(main_hero_id, bt->task_id,TaskStatus_Finished);
    }

    
    if(guaiwuAttachTime > 1) { //给多波怪物的关卡评星
        rateTask(main_hero_id, bt->task_id, team_pos_vec, teamHp, guaiwuAttachTime, attached_round);
    }
    
    //如果是boss关打赢了，按照vip级别把该任务所有棋盘格子设置未探索
    //并刷新棋盘
    if(battle_win && isBOSS(bt->task_id,bt->grid_id))
    {
        //给当前关评级
        if(guaiwuAttachTime == 1) //打赢的情况下1波怪物评星
            rateTask(main_hero_id, bt->task_id, team_pos_vec, teamHp, 1, 1);
        //给章节评级
        rateChapter(main_hero_id, ((bt->task_id -1) /10) +1);

        /*if(bt->task_id%10 ==0) {
            rateChapter(main_hero_id, (bt->task_id/10));
        }*/
        
        //先刷新棋盘
        refreshChessBoard(main_hero_id,bt->task_id);

        //触发日常任务
        send_system_bonus_notify(main_hero_id, BonusType_DayWelfare, BonusID_Killed_Boss);


        /* 2014.03.17 去掉打过关卡跳格子
        std::string grid_str;
        HeroInfo hero_info;
        GetHeroBasicInfo(main_hero_id,hero_info);
        if(hero_info.vip_level <= 1)
        {
            grid_str = " grid_1_stat=0, "
                        " grid_2_stat=0, "
                        " grid_3_stat=0, "
                        " grid_4_stat=0, "
                        " grid_5_stat=0, "
                        " grid_6_stat=0, "
                        " grid_7_stat=0, "
                        " grid_8_stat=0, "
                        " grid_9_stat=0 ";
        }
        else if(hero_info.vip_level == 2)
        {
            grid_str = " grid_1_stat=1, "
                        " grid_2_stat=0, "
                        " grid_3_stat=0, "
                        " grid_4_stat=0, "
                        " grid_5_stat=0, "
                        " grid_6_stat=0, "
                        " grid_7_stat=0, "
                        " grid_8_stat=0, "
                        " grid_9_stat=0 ";
        }
        else if(hero_info.vip_level == 3)
        {
            grid_str = " grid_1_stat=1, "
                        " grid_2_stat=1, "
                        " grid_3_stat=0, "
                        " grid_4_stat=1, "
                        " grid_5_stat=0, "
                        " grid_6_stat=0, "
                        " grid_7_stat=0, "
                        " grid_8_stat=0, "
                        " grid_9_stat=0 ";
        }
        else if(hero_info.vip_level == 4)
        {
            grid_str = " grid_1_stat=1, "
                        " grid_2_stat=1, "
                        " grid_3_stat=1, "
                        " grid_4_stat=1, "
                        " grid_5_stat=1, "
                        " grid_6_stat=0, "
                        " grid_7_stat=1, "
                        " grid_8_stat=0, "
                        " grid_9_stat=0 ";
        }
        else
        {
            grid_str = " grid_1_stat=1, "
                        " grid_2_stat=1, "
                        " grid_3_stat=1, "
                        " grid_4_stat=1, "
                        " grid_5_stat=1, "
                        " grid_6_stat=1, "
                        " grid_7_stat=1, "
                        " grid_8_stat=1, "
                        " grid_9_stat=0 ";
        }
        
        char sql[1024];

         sprintf(sql, "update hellgate.task_chessboard set  "
            " %s "
            " where hero_id=%u and task_id=%u"
            , grid_str.c_str(), main_hero_id, bt->task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        */
    }
    


    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);


    return;
}


void ProcServerThread::DealwithSaodang(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithSaodang", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Saodang* saodang = (SPCmd_Saodang*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Saodang))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        saodang->task_id = ntohl(saodang->task_id);
        saodang->saodang_time = ntohl(saodang->saodang_time);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询剩余扫荡次数
    unsigned int sweep_num = getHeroVipInfo(main_hero_id, VIP_FIELD_TYPE_SWEEP);
    
    //查询任务棋盘格式
    unsigned int grid_count_heng = 0;
    unsigned int grid_count_shu = 0;
    CS::getTaskChessboardFormat(saodang->task_id,grid_count_heng,grid_count_shu);
    
    //判断task和grid是否当前可进入
    if((sweep_num < saodang->saodang_time) 
        || (saodang->saodang_time <= 0)
        || (!canHeroSaodangTask(main_hero_id, saodang->task_id))
        || ((grid_count_heng*grid_count_shu) < 9)
        || ((get_unequipped_counts(main_hero_id)+saodang->saodang_time)> MAX_COUNTS_IN_KNAPSACK)
        )
    {
        //
        int rspDataLen = sizeof(SPCmd_SaodangRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = saodangFubenRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_SaodangRsp* rspBody = (SPCmd_SaodangRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }


    //消耗体力
    bool vit_enought = subVitality(main_hero_id
        , Vitality_GuanQia_Floped*saodang->saodang_time*(grid_count_heng*grid_count_shu));
    if(!vit_enought)
    {
        //
        int rspDataLen = sizeof(SPCmd_SaodangRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = saodangFubenRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_SaodangRsp* rspBody = (SPCmd_SaodangRsp*)((rspHead)+1);
        rspBody->err_code = htonl(TiliNotEnought);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //更新副本扫荡次数
    updateHeroVipInfo(main_hero_id, VIP_FIELD_TYPE_SWEEP, sweep_num - saodang->saodang_time);
    
    //查询我方上阵阵型
    /*
    unsigned int team_pos_vec[4] = {0, 0, 0, 0};
    {
        std::vector<int> arr;
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , main_hero_id, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, main_hero_id, pos);
                }
                else
                {
                    team_pos_vec[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */

    
    //棋盘，最大棋盘17个格子
    //首先获取棋盘的布局
    const int max_grid_count = 17;
    unsigned int grid_id_arr[max_grid_count];
    memset(grid_id_arr, 0, max_grid_count);
    { //查询当前grid的状态
       char sql[1024], grid_field[32];
       sprintf(sql, "select * "
           " from hellgate.task_chessboard "
           " where hero_id=%u and task_id=%u"
           , main_hero_id, saodang->task_id);
       try
       {
           Mysql_Thread_Conn->Query(sql);
           if(Mysql_Thread_Conn->FetchRow() != NULL) {
               for(int i=1; i<(grid_count_heng*grid_count_shu+1); ++i) {
                   sprintf(grid_field, "grid_id_%u", i);
                   grid_id_arr[i] = atoi(Mysql_Thread_Conn->GetField(grid_field));
               }
           }
           
           Mysql_Thread_Conn->FreeResult();
       }
       catch(CMysqlException& e)
       {
           LogMsg("%s, line %d, mysql exception. [%s]"
                       , __FILE__, __LINE__, e.GetErrMsg());
           //
           exit(1);
       }
    }

    //查询初始银币量
    unsigned silver_init = getItemCountInTeam(main_hero_id, ItemsType_Silver);


    //扫荡结果
    unsigned int exp_total = 0;
    unsigned int silver_end_total = 0;
    unsigned int silver_diaoluo = 0;
    unsigned int silver_used_for_auto_fenjie = 0;
    std::vector<unsigned long long> zb_vec;
    std::vector<ItemInfo> item_vec;
    std::vector<ItemSuipianInfo> item_suipian_vec;
    

    //循环扫荡所有小怪格子 
    std::vector<unsigned long long> zb_chaijie_vec; //要自动分解的
    for(int saodang_time=0; saodang_time<saodang->saodang_time; ++saodang_time) {
        for(int grid_id=1; grid_id<=grid_count_heng*grid_count_shu; ++grid_id) {
            
            if(grid_id_arr[grid_id] <= 0) //非怪物牌直接跳过
                continue;
            
            { //提取掉落物品
                ScriptBuilderUserData userData;
                FightSUD f_sud;
                userData.data = &f_sud;
                
                userData.teamTag = 1;
                HeroState teamHp;
                f_sud.b_check_count = false;
                f_sud.heroId = main_hero_id;
                f_sud.taskId = saodang->task_id;
                f_sud.gridId = grid_id;
                unsigned int fight_index = getGuaiwuAttackCountOfTask(saodang->task_id, grid_id);
                f_sud.fightIndex = fight_index;
                f_sud.heroHpAfterLastFight = teamHp;
                
                //经验 stub
                exp_total += fightEndCallback(userData,true);

                //装备 
                std::vector<EquipData> eq_data_vec = getFightEndEquips(userData, true);
                for(int zb_index=0; zb_index<eq_data_vec.size(); ++zb_index)
                {
                    EquipData* zb_p = &(eq_data_vec[zb_index]);
                    if((zb_p->zhuangbei_colour == ZhuangbeiColour_Baizhuang && saodang->auto_fenjie_baizhuang)
                        || (zb_p->zhuangbei_colour == ZhuangbeiColour_Fumo && saodang->auto_fenjie_lanzhuang)
                        || (zb_p->zhuangbei_colour == ZhuangbeiColour_Xiyou && saodang->auto_fenjie_huangzhuang)
                        )
                    {
                        //要分解的
                        zb_chaijie_vec.push_back(zb_p->zhuangbei_id);
                    }
                    else
                    {
                        //要保留的
                        zb_vec.push_back(zb_p->zhuangbei_id);
                    }
                }

                //item
                std::vector<ItemInfo> tmp_item_vec = getFightEndItems(userData,true);
                for(int item_index=0; item_index<tmp_item_vec.size(); ++item_index)
                {
                    ItemInfo* item_p = &(tmp_item_vec[item_index]);
                    if(item_p->type == ItemsType_Silver)
                    {
                        silver_diaoluo += item_p->count;
                    }
                    else
                    {
                        int x=0;
                        for(; x<item_vec.size(); ++x)
                        {
                            if(item_vec[x].type == item_p->type)
                            {
                                item_vec[x].count += item_p->count;
                                break;
                            }
                        }
                        if(x == item_vec.size())
                        {
                            ItemInfo item;
                            item.type = item_p->type;
                            item.count = item_p->count;

                            item_vec.push_back(item);
                        }
                    }
                }

                //道具碎片
                item_suipian_vec = getFightEndItemSuiPians(userData,true);
            }
                    
            /*
            //查询怪物阵型
            unsigned int monster_pos_vec_1[4] = {0, 0, 0, 0};
            unsigned int monster_pos_vec_2[4] = {0, 0, 0, 0};
            unsigned int monster_pos_vec_3[4] = {0, 0, 0, 0};
            getGuanQiaGuaiWu(main_hero_id, saodang->task_id, grid_id
                , monster_pos_vec_1, monster_pos_vec_2, monster_pos_vec_3);
            
            //生成战斗脚本
            bool battle_win = true;
            {
                ScriptBuilderUserData userData;
                HeroState teamHp;
                userData.heroId = main_hero_id;
                userData.taskId = saodang->task_id;
                userData.gridId = grid_id;
                FightScriptBuilder scriptBuild;
                std::vector<FightScript> team_script_vec;

                unsigned int fight_index = 1;
                
                //SpecialControl SControl = SC_NONE;
                
                FightScript team_script;
                FightScript monster_script;
                userData.fightIndex = fight_index;
                userData.heroHpAfterLastFight = teamHp;
                teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_3
                    , team_script, monster_script
                     , this
                    , userData
                    , FBB_BoardA
                    , -1);
                team_script_vec.push_back(team_script);

                battle_win = (team_script.endResult.myResult == Result_Win);

                //提取掉落物品
                if(battle_win)
                {
                    //经验 stub
                    exp_total += team_script.endResult.gettedExp;

                    //装备
                    for(int zb_index=0; zb_index<team_script.endResult.gettedZhuangBei.size(); ++zb_index)
                    {
                        EquipData* zb_p = &(team_script.endResult.gettedZhuangBei[zb_index]);
                        if((zb_p->zhuangbei_colour == ZhuangbeiColour_Baizhuang && saodang->auto_fenjie_baizhuang)
                            || (zb_p->zhuangbei_colour == ZhuangbeiColour_Fumo && saodang->auto_fenjie_lanzhuang)
                            )
                        {
                            //要分解的
                            zb_chaijie_vec.push_back(zb_p->zhuangbei_id);
                        }
                        else
                        {
                            //要保留的
                            zb_vec.push_back(zb_p->zhuangbei_id);
                        }
                    }

                    //item
                    for(int item_index=0; item_index<team_script.endResult.gettedItem.size(); ++item_index)
                    {
                        ItemInfo* item_p = &(team_script.endResult.gettedItem[item_index]);
                        if(item_p->type == ItemsType_Silver)
                        {
                            silver_diaoluo += item_p->count;
                        }
                        else
                        {
                            int x=0;
                            for(; x<item_vec.size(); ++x)
                            {
                                if(item_vec[x].type == item_p->type)
                                {
                                    item_vec[x].count += item_p->count;
                                    break;
                                }
                            }
                            if(x == item_vec.size())
                            {
                                ItemInfo item;
                                item.type = item_p->type;
                                item.count = item_p->count;

                                item_vec.push_back(item);
                            }
                        }
                    }

                    //道具碎片
                    item_suipian_vec = team_script.endResult.gettedItemSuiPian;
                }
            }
            */
        }
    }

    //自动分解装备
    std::vector<ItemInfo> tmp_item_vec; 
    std::vector<ItemInfo> tmp_re_item_vec; 
    int decomposed_count = 0, zb_index = 0;
    for(; zb_index<zb_chaijie_vec.size(); ++zb_index)
    {
        std::vector<unsigned long long> tmp_zb_vec;
        tmp_zb_vec.push_back(zb_chaijie_vec[zb_index]);
        if(CheckAndChaijieZhuangbei(main_hero_id, tmp_zb_vec,tmp_item_vec, tmp_re_item_vec))
        { //扫荡产生的装备没有返还的材料 tmp_re_item_vec这个参数只是传入 没用
            for(int item_index=0; item_index<tmp_item_vec.size(); ++item_index)
            {
                ItemInfo* item_p = &(tmp_item_vec[item_index]);
                int x=0;
                for(; x<item_vec.size(); ++x)
                {
                    if(item_vec[x].type == item_p->type)
                    {
                        item_vec[x].count += item_p->count;
                        break;
                    }
                }
                if(x == item_vec.size())
                {
                    ItemInfo item;
                    item.type = item_p->type;
                    item.count = item_p->count;

                    item_vec.push_back(item);
                }
            }
        }
        else
        {
            //银币不够了
            break;
        }
    }

    decomposed_count = zb_index; //已经拆解装备的数量
    if(zb_index < zb_chaijie_vec.size())
    {
        //银币不够拆不完就不拆了
        for(; zb_index<zb_chaijie_vec.size(); ++zb_index)
        {
            zb_vec.push_back(zb_chaijie_vec[zb_index]);
        }
    }
    
    //计算银币
    silver_end_total = getItemCountInTeam(main_hero_id, ItemsType_Silver);

    silver_used_for_auto_fenjie = silver_init+silver_diaoluo - silver_end_total;

    //
    std::vector<__ZhuangbeiDetail> zb_detail_vec;
    for(int i=0; i<zb_vec.size(); ++i)
    {
        __ZhuangbeiDetail detail;
        getZhuangbeiDetail(zb_vec[i],main_hero_id,detail);

        zb_detail_vec.push_back(detail);
    }
    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zb_detail_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zb_detail_vec.size(); ++i)
    {
        unsigned int len;
        zb_detail_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_SaodangRsp) + sizeof(ItemInfo)*item_vec.size()
        + sizeof(unsigned int) + zhuangbei_detail_data_len;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = saodangFubenRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SaodangRsp* rspBody = (SPCmd_SaodangRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->exp = htonl(exp_total);
    rspBody->decomposed_count = htonl(decomposed_count);

    //道具
    rspBody->item_count = htonl(item_vec.size());
    for(int i=0; i<item_vec.size(); ++i)
    {
        rspBody->item_arr[i].type = htonl(item_vec[i].type);
        rspBody->item_arr[i].count = htonl(item_vec[i].count);
    }

    //装备
    unsigned int* zb_count_p = (unsigned int*)(rspBody->item_arr +item_vec.size());
    *zb_count_p = htonl(zb_vec.size());
    ZhuangbeiDetail* zb_detail_arr = (ZhuangbeiDetail*)(zb_count_p+1);
    memcpy(zb_detail_arr, zhuangbei_detail_data, zhuangbei_detail_data_len);
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    return;
}

void ProcServerThread::DealwithShenbingJiefengyin(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithShenbingJiefengyin", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ShenbingJieFengyin* jiefengyin = (SPCmd_ShenbingJieFengyin*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ShenbingJieFengyin))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        jiefengyin->zb_id = Utl::htonll(jiefengyin->zb_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    
    if(!checkAndShenbingJiefengyin(main_hero_id, jiefengyin->zb_id))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ShenbingJieFengyinRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = shenbingJieFengyinRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ShenbingJieFengyinRsp* rspBody = (SPCmd_ShenbingJieFengyinRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ShenbingJieFengyinRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = shenbingJieFengyinRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ShenbingJieFengyinRsp* rspBody = (SPCmd_ShenbingJieFengyinRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}

void ProcServerThread::DealwithShenbingJianding(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithShenbingJianding", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ShenbingJianding* jianding = (SPCmd_ShenbingJianding*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ShenbingJianding))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        jianding->zb_id = Utl::htonll(jianding->zb_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<ZBAttr> zb_attr_vec;
    if(!checkAndShenbingJianding(main_hero_id, jianding->zb_id, zb_attr_vec))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ShenbingJiandingRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = shenbingJiandingRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ShenbingJiandingRsp* rspBody = (SPCmd_ShenbingJiandingRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ShenbingJiandingRsp) + sizeof(ZBAttr)*zb_attr_vec.size();
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = shenbingJiandingRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ShenbingJiandingRsp* rspBody = (SPCmd_ShenbingJiandingRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->identified_attr_count = htonl(zb_attr_vec.size());
    for(int i=0; i<zb_attr_vec.size(); ++i)
    {
        rspBody->identified_attr_vec[i].attr_type = htonl(zb_attr_vec[i].attr_type);
        rspBody->identified_attr_vec[i].attr_value = htonl(zb_attr_vec[i].attr_value);
        rspBody->identified_attr_vec[i].cuiqu_suc_ratio = htonl(zb_attr_vec[i].cuiqu_suc_ratio);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}

void ProcServerThread::DealwithZBJinglian(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZBJinglian", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZBJinglian* jinglian = (SPCmd_ZBJinglian*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ShenbingJianding))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        jinglian->zb_id = Utl::htonll(jinglian->zb_id);
        jinglian->cailiao_zb_id = Utl::htonll(jinglian->cailiao_zb_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<ZBAttr> zb_attr_vec;
    unsigned int jinglian_time;
    std::vector<ItemInfo> cailiao_vec;
    if(!checkAndZBJinglian(main_hero_id, jinglian->zb_id, jinglian->cailiao_zb_id
        , jinglian_time, cailiao_vec, zb_attr_vec))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ZBJinglianRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = zbJinglianRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ZBJinglianRsp* rspBody = (SPCmd_ZBJinglianRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ZBJinglianRsp) +sizeof(ItemInfo)*cailiao_vec.size();
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = zbJinglianRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZBJinglianRsp* rspBody = (SPCmd_ZBJinglianRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    bzero(&rspBody->jinglian_data, sizeof(JinglianData));
    rspBody->jinglian_data.jinglian_times = htonl(jinglian_time);

    rspBody->jinglian_data.jinglian_attr_arr[0].attr_type = htonl(zb_attr_vec[0].attr_type);
    rspBody->jinglian_data.jinglian_attr_arr[0].attr_value = htonl(zb_attr_vec[0].attr_value);
    rspBody->jinglian_data.jinglian_attr_arr[0].cuiqu_suc_ratio = htonl(zb_attr_vec[0].cuiqu_suc_ratio);
    if(zb_attr_vec.size() >= 2)
    {
        rspBody->jinglian_data.jinglian_attr_arr[1].attr_type = htonl(zb_attr_vec[1].attr_type);
        rspBody->jinglian_data.jinglian_attr_arr[1].attr_value = htonl(zb_attr_vec[1].attr_value);
        rspBody->jinglian_data.jinglian_attr_arr[1].cuiqu_suc_ratio = htonl(zb_attr_vec[1].cuiqu_suc_ratio);
    }

    rspBody->count = htonl(cailiao_vec.size());
    ItemInfo *p = rspBody->item_arr;
    for(int i=0; i<cailiao_vec.size() && i<5; i++, p++) {
        p->type = htonl(cailiao_vec[i].type);
        p->count = htonl(cailiao_vec[i].count);
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}

void ProcServerThread::DealwithShenbingZhuankeJingwen(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithShenbingZhuankeJingwen", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ShenbingZhuankeJingwen* jingwen = (SPCmd_ShenbingZhuankeJingwen*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ShenbingZhuankeJingwen))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        jingwen->zb_id = Utl::htonll(jingwen->zb_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<ZBAttr> jingwen_attr_vec;
    if(!checkAndShenbingZhuankeJingwen(main_hero_id, jingwen->zb_id, jingwen_attr_vec))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ShenbingZhuankeJingwenRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = shenbingZhuankeJingwenRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ShenbingZhuankeJingwenRsp* rspBody = (SPCmd_ShenbingZhuankeJingwenRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ShenbingZhuankeJingwenRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = shenbingZhuankeJingwenRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ShenbingZhuankeJingwenRsp* rspBody = (SPCmd_ShenbingZhuankeJingwenRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->jingwen_attr[0].attr_type = htonl(jingwen_attr_vec[0].attr_type);
    rspBody->jingwen_attr[0].attr_value = htonl(jingwen_attr_vec[0].attr_value);
    rspBody->jingwen_attr[0].cuiqu_suc_ratio = htonl(jingwen_attr_vec[0].cuiqu_suc_ratio);
    if(jingwen_attr_vec.size() >= 2)
    {
        rspBody->jingwen_attr[1].attr_type = htonl(jingwen_attr_vec[1].attr_type);
        rspBody->jingwen_attr[1].attr_value = htonl(jingwen_attr_vec[1].attr_value);
        rspBody->jingwen_attr[1].cuiqu_suc_ratio = htonl(jingwen_attr_vec[1].cuiqu_suc_ratio);
    }
    else
    {
        rspBody->jingwen_attr[1].attr_type = htonl(0);
        rspBody->jingwen_attr[1].attr_value = htonl(0);
        rspBody->jingwen_attr[1].cuiqu_suc_ratio = htonl(0);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}


void ProcServerThread::DealwithHeroLevelUp(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithHeroLevelUp", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_HeroLevelUp* levelup = (SPCmd_HeroLevelUp*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_HeroLevelUp))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        levelup->hero_id = ntohl(levelup->hero_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    if(!isHeroBelong2Team(levelup->hero_id, main_hero_id))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_HeroLevelUpRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = heroLevelUpRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_HeroLevelUpRsp* rspBody = (SPCmd_HeroLevelUpRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }

    //
    unsigned int silver_balance;
    unsigned int levelup_daoju_count;
    HeroDetail hero_detail;

    HeroInfo hero_basic_info;
    GetHeroBasicInfo(levelup->hero_id, hero_basic_info);
    bool ret = false;
    if(hero_basic_info.is_yuanshen)
    {
        ret = checkAndYuanshenLevelUp(levelup->hero_id, silver_balance, levelup_daoju_count, hero_detail);
    }
    else
    {
        ret = checkAndHeroLevelUp(levelup->hero_id, silver_balance, levelup_daoju_count, hero_detail);
        
    }

    if(!ret)
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_HeroLevelUpRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = heroLevelUpRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_HeroLevelUpRsp* rspBody = (SPCmd_HeroLevelUpRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }

    //等级变化 重新计算战斗力
    calculate_fight_capacity(levelup->hero_id);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_HeroLevelUpRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = heroLevelUpRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_HeroLevelUpRsp* rspBody = (SPCmd_HeroLevelUpRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->silver_end = htonl(silver_balance);
    rspBody->item_end.type = htonl(ItemsType_Hero_LevelUp);
    rspBody->item_end.count = htonl(levelup_daoju_count);

    hton_hero_detail(hero_detail, rspBody->hero_detial);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}

bool ProcServerThread::checkAndHeroLevelUp(unsigned int hero_id
    ,unsigned int & silver_count,unsigned int & levelup_daoju_count,HeroDetail & hero_detail)
{
    HeroDetail hero_detail_begin;
    GetHeroDetail(hero_id,hero_detail_begin);

    unsigned int main_hero_id = 0;
    if(hero_detail_begin.parent_hero_id == 0)
    {
        main_hero_id = hero_id;
    }
    else
    {
        main_hero_id = hero_detail_begin.parent_hero_id;
    }
    

    //
    if(hero_detail_begin.basic_info.level >= HERO_MAX_LEVEL)
    {
        return false;
    }
    if(hero_detail_begin.exp_current < hero_detail_begin.exp_need)
    {
        return false;
    }

    //查询道具
    levelup_daoju_count = getItemCountInTeam(main_hero_id, ItemsType_Hero_LevelUp);

    if(levelup_daoju_count < CS::heroLevelUpNeedItemCount(hero_detail_begin.basic_info.level + 1))
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup item_balance=[%d]", __FILE__, __LINE__, levelup_daoju_count);
#endif //_DEBUG

        return false;
    }

    //查询银币
    silver_count = getItemCountInTeam(main_hero_id, ItemsType_Silver);
    /* 2014年03月12日 移除英雄升级需要的银币
    if(silver_count < CS::heroLevelUpNeedSilver(hero_detail_begin.basic_info.level + 1))
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup silver_balance=[%d]", __FILE__, __LINE__, silver_count);
#endif //_DEBUG

        return false;
    }
    */

    //升级
    {
        unsigned int exp_current = hero_detail_begin.exp_current - hero_detail_begin.exp_need;

        {
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor "
                " set level=%u, exp_current=%u "
                " where hero_id=%u"
                , hero_detail_begin.basic_info.level + 1, exp_current, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //如果是主角，升级时可能附带的其他操作
        if(hero_detail_begin.parent_hero_id == 0)
        {
            heroOperatioWhenLevelUpgrade(hero_id, hero_detail_begin.basic_info.level + 1);
        }
    }

    //如果满级了，则创建元神
    if(hero_detail_begin.basic_info.level == HERO_MAX_LEVEL-1)
    {
        createYuanshen(hero_id);
    }

    /* 2014年03月12日 移除英雄升级需要的银币
    //扣钱
    silver_count -= CS::heroLevelUpNeedSilver(hero_detail_begin.basic_info.level + 1);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_count, main_hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */

    //扣道具
    levelup_daoju_count -= CS::heroLevelUpNeedItemCount(hero_detail_begin.basic_info.level + 1);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , levelup_daoju_count, main_hero_id, ItemsType_Hero_LevelUp);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //重新查询herodetail
    GetHeroDetail(hero_id,hero_detail);

    return true;
}

bool ProcServerThread::checkAndYuanshenLevelUp(unsigned int hero_id
    ,unsigned int & silver_count,unsigned int & levelup_daoju_count,HeroDetail & hero_detail)
{

    
    HeroDetail hero_detail_begin;
    GetHeroDetail(hero_id,hero_detail_begin);

    unsigned int main_hero_id = 0;
    if(hero_detail_begin.parent_hero_id == 0)
    {
        main_hero_id = hero_id;
    }
    else
    {
        main_hero_id = hero_detail_begin.parent_hero_id;
    }
    

    //
    if(hero_detail_begin.basic_info.level >= YUANSHEN_MAX_LEVEL)
    {
        return false;
    }
    if(hero_detail_begin.exp_current < hero_detail_begin.exp_need)
    {
        return false;
    }

    //特定等级只能通过升阶
    switch(hero_detail_begin.basic_info.level)
    {
        case 5:
        case 10:
        case 15:
        case 20:
            return false;
    }

    //查询道具
    levelup_daoju_count = getItemCountInTeam(main_hero_id, ItemsType_Hero_LevelUp);
    
    //查询银币
    silver_count =  getItemCountInTeam(main_hero_id, ItemsType_Silver);


    //升级
    {
        unsigned int exp_current = hero_detail_begin.exp_current - hero_detail_begin.exp_need;

        {
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor "
                " set level=%u, exp_current=%u "
                " where hero_id=%u"
                , hero_detail_begin.basic_info.level + 1, exp_current, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    //重新查询herodetail
    GetHeroDetail(hero_id,hero_detail);

    return true;
}


void ProcServerThread::DealwithHeroUpgrade(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithHeroUpgrade", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_HeroUpgrade* upgrade = (SPCmd_HeroUpgrade*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_HeroUpgrade))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        upgrade->hero_id = ntohl(upgrade->hero_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    if(!isHeroBelong2Team(upgrade->hero_id, main_hero_id))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_HeroLevelUpRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = heroUpgradeRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_HeroLevelUpRsp* rspBody = (SPCmd_HeroLevelUpRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }

    //
    unsigned int silver_balance;
    unsigned int upgrade_daoju_count;
    HeroDetail hero_detail;

    HeroInfo hero_basic_info;
    GetHeroBasicInfo(upgrade->hero_id, hero_basic_info);
    bool ret = false;
    if(hero_basic_info.is_yuanshen)
    {
        ret = checkAndYuanshenUpgrade(upgrade->hero_id, silver_balance, upgrade_daoju_count, hero_detail);
    }
    else
    {
        ret = checkAndHeroUpgrade(upgrade->hero_id, silver_balance, upgrade_daoju_count, hero_detail);
        
    }

    if(!ret)
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_HeroUpgradeRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = heroUpgradeRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_HeroUpgradeRsp* rspBody = (SPCmd_HeroUpgradeRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }
    
    //阶数变化 重新计算战斗力
    calculate_fight_capacity(upgrade->hero_id);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_HeroUpgradeRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = heroUpgradeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_HeroUpgradeRsp* rspBody = (SPCmd_HeroUpgradeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->silver_end = htonl(silver_balance);
    rspBody->item_end.type = htonl(ItemsType_Hero_Upgrade);
    rspBody->item_end.count = htonl(upgrade_daoju_count);

    hton_hero_detail(hero_detail, rspBody->hero_detial);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}


bool ProcServerThread::checkAndHeroUpgrade(unsigned int hero_id
    ,unsigned int & silver_count,unsigned int & upgrade_daoju_count,HeroDetail & hero_detail)
{
    HeroDetail hero_detail_begin;
    GetHeroDetail(hero_id,hero_detail_begin);

    unsigned int main_hero_id = 0;
    if(hero_detail_begin.parent_hero_id == 0)
    {
        main_hero_id = hero_id;
    }
    else
    {
        main_hero_id = hero_detail_begin.parent_hero_id;
    }
    

    //
    if(hero_detail_begin.basic_info.stage>= HERO_MAX_STAGE)
    {
        return false;
    }

    //查询教堂
    unsigned int church_level = 0;
    {
        char sql[1024];
        sprintf(sql, "select church_level "
            " from hellgate.hero_list "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                church_level = atoi(Mysql_Thread_Conn->GetField("church_level"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(church_level <= hero_detail_begin.basic_info.stage)
    {
        return false;
    }

    //查询道具
    upgrade_daoju_count = getItemCountInTeam(main_hero_id, ItemsType_Hero_Upgrade);

    if(upgrade_daoju_count < CS::heroUpgradeNeedItemCount(hero_detail_begin.basic_info.stage + 1))
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup item_balance=[%d]", __FILE__, __LINE__, upgrade_daoju_count);
#endif //_DEBUG

        return false;
    }

    //查询银币
    silver_count = getItemCountInTeam(main_hero_id, ItemsType_Silver);

    if(silver_count < CS::heroUpgradeNeedSilver(hero_detail_begin.basic_info.stage + 1))
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup silver_balance=[%d]", __FILE__, __LINE__, silver_count);
#endif //_DEBUG

        return false;
    }

    //升阶
    {

        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor "
            " set stage=%u "
            " where hero_id=%u"
            , hero_detail_begin.basic_info.stage+ 1, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //扣钱
    silver_count -= CS::heroUpgradeNeedSilver(hero_detail_begin.basic_info.stage+ 1);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_count, main_hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //扣道具
    upgrade_daoju_count -= CS::heroUpgradeNeedItemCount(hero_detail_begin.basic_info.stage+ 1);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , upgrade_daoju_count, main_hero_id, ItemsType_Hero_Upgrade);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //重新查询herodetail
    GetHeroDetail(hero_id,hero_detail);

    return true;
}

bool ProcServerThread::checkAndYuanshenUpgrade(unsigned int hero_id
    ,unsigned int & silver_count,unsigned int & upgrade_daoju_count,HeroDetail & hero_detail)
{

    
    HeroDetail hero_detail_begin;
    GetHeroDetail(hero_id,hero_detail_begin);

    unsigned int main_hero_id = 0;
    if(hero_detail_begin.parent_hero_id == 0)
    {
        main_hero_id = hero_id;
    }
    else
    {
        main_hero_id = hero_detail_begin.parent_hero_id;
    }
    

    //
    if(hero_detail_begin.basic_info.stage >= YUANSHEN_MAX_STAGE)
    {
        LogMsg("%s, line %d, mysql exception. yuanshen stage[%u] always max stage "
            , __FILE__, __LINE__, hero_detail_begin.basic_info.stage);
        return false;
    }

    //元神只有在特定等级时才能升阶
    if(!(hero_detail_begin.basic_info.level == 5
        || hero_detail_begin.basic_info.level == 10
        || hero_detail_begin.basic_info.level == 15
        || hero_detail_begin.basic_info.level == 20))
    {
        LogMsg("%s, line %d, mysql exception. yuanshen level[%u] is not special level "
            , __FILE__, __LINE__, hero_detail_begin.basic_info.level);
        return false;
    }
    //元神升阶其实就是升级突破，所需要满足下一级的经验要求
    if(hero_detail_begin.exp_current < hero_detail_begin.exp_need)
    {
        LogMsg("%s, line %d, mysql exception. yuanshen exp_current[%u] not enough, need[%u]"
            , __FILE__, __LINE__, hero_detail_begin.exp_current, hero_detail_begin.exp_need);
        return false;
    }


    //查询道具
    upgrade_daoju_count = getItemCountInTeam(main_hero_id, ItemsType_Hero_Upgrade);

    //查询银币
    silver_count = getItemCountInTeam(main_hero_id, ItemsType_Silver);

    //升级并升阶
    {
        unsigned int exp_current = hero_detail_begin.exp_current - hero_detail_begin.exp_need;

        {
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor "
                " set level=%u, stage=%u, exp_current=%u "
                " where hero_id=%u"
                , hero_detail_begin.basic_info.level + 1, hero_detail_begin.basic_info.stage+1
                , exp_current, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    //扣钱
    silver_count -= CS::yuanshenUpgradeNeedSilver(hero_detail_begin.basic_info.stage+ 1);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_count, main_hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    

    //重新查询herodetail
    GetHeroDetail(hero_id,hero_detail);

    return true;
}


bool ProcServerThread::checkAndShenbingJiefengyin(unsigned int hero_id, unsigned long long zb_id)
{
    //获取现有silver数量
    unsigned silver_total_count = getItemCountInTeam(hero_id, ItemsType_Silver);

    unsigned int silver_need_count = CS::ShenbingJiefengyinNeedSilver();
    if(silver_total_count < silver_need_count)
    {
        LogMsg("%s, line %d,  silver_need_count=[%u] silver_total_count[%u]"
                            , __FILE__, __LINE__, silver_need_count, silver_total_count);
            
        return false;
    }

    //获取现有解封印道具数量
    unsigned item_total_count = getItemCountInTeam(hero_id, ItemsType_Shenbing_Jiefengyin);

    unsigned int item_need_count = CS::ShenbingJiefengyinNeedItemCount();
    if(item_total_count < item_need_count)
    {
        LogMsg("%s, line %d,  item_need_count=[%u] item_total_count[%u]"
                            , __FILE__, __LINE__, item_need_count, item_total_count);
            
        return false;
    }
        
    //检查装备
    {
        //
        unsigned int group_id = 0;
        bool is_unlocked = false;
        {
            char sql[1024];
            sprintf(sql, "select group_id, is_unlocked "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    is_unlocked = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlocked"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //检查是否是神兵 
        if(ZBGroupIsShenbing(group_id) == -1)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not shenbing"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //是否已经解封印
        if(is_unlocked)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is already unlocked"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }
    }


    //先解封印
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list set is_unlocked=1 "
            " where zhuangbei_id=%llu"
            , zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再扣钱和道具
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need_count, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , item_need_count, hero_id, ItemsType_Shenbing_Jiefengyin);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

bool ProcServerThread::checkAndShenbingJianding(unsigned int hero_id
    ,unsigned long long zb_id, std::vector < ZBAttr > & identified_attr_vec)
{
    identified_attr_vec.clear();
    
    //获取现有silver数量
    unsigned silver_total_count = getItemCountInTeam(hero_id, ItemsType_Silver);
    

    //获取现有鉴定道具数量
    unsigned item_total_count = getItemCountInTeam(hero_id, ItemsType_Shenbing_Jianding);
    

    //检查装备
    unsigned int zb_name_id = 0;
    unsigned int group_id = 0;
    unsigned int cur_identified_attr_count = 0;
    {
        //
        bool is_unlocked = false;
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_list.zhuangbei_name_id, group_id, is_unlocked, identified_attr_count "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                    group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    is_unlocked = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlocked"));
                    cur_identified_attr_count = atoi(Mysql_Thread_Conn->GetField("identified_attr_count"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //检查是否是神兵 
        if(ZBGroupIsShenbing(group_id) == -1)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not shenbing"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //是否已经解封印
        if(!is_unlocked)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not unlocked"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //是否已经鉴定完
        if(cur_identified_attr_count == 5)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is already identified all attr"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }
    }

    //
    cur_identified_attr_count++;

    unsigned int silver_need_count = CS::ShenbingJiandingNeedSilver(cur_identified_attr_count);
    if(silver_total_count < silver_need_count)
    {
        LogMsg("%s, line %d,  silver_need_count=[%u] silver_total_count[%u]"
                            , __FILE__, __LINE__, silver_need_count, silver_total_count);
            
        return false;
    }

    unsigned int item_need_count = CS::ShenbingJiandingNeedItemCount(cur_identified_attr_count);
    if(item_total_count < item_need_count)
    {
        LogMsg("%s, line %d,  item_need_count=[%u] item_total_count[%u]"
                            , __FILE__, __LINE__, item_need_count, item_total_count);
            
        return false;
    }

    //先从模板库中取出装备的隐藏属性
    unsigned int zhuangbei_type, zhuangbei_colour, zhuangbei_level;
    std::vector<std::string> hide_attr_str_vec;
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_type, zhuangbei_name, zhuangbei_colour, "
            " zhuangbei_level, "
            "hide_attr_1_attr,     "
            "hide_attr_2_attr,     "
            "hide_attr_3_attr,     "
            "hide_attr_4_attr,     "
            "hide_attr_5_attr     "
            " from hellgate.zhuangbei_name_list_copy where zhuangbei_name_id=%u"
            , zb_name_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                
                //神兵隐藏属性
                for(int i=1; i<=5; ++i)
                {
                    char str[32];
                    sprintf(str, "hide_attr_%d_attr", i);
                    if(strlen(Mysql_Thread_Conn->GetField(str)) > 0)
                    {
                        hide_attr_str_vec.push_back(std::string(Mysql_Thread_Conn->GetField(str)));
                    }
                    else
                    {
                        LogMsg("%s, line %d, shenbing hide_attr count error zhuangbei_group_id[%u]."
                            , __FILE__, __LINE__, group_id);
                        return false;
                    }
                }
                
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_name_id=[%u] not exist"
                        , __FILE__, __LINE__, zb_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //先鉴定
    {
        for(int i=0; i<cur_identified_attr_count; ++i)
        {
            //取出所有键值对
            std::list<std::string> key_list;
            std::list<std::string> value_list;
            Str2KeyValueList(hide_attr_str_vec[i], key_list, value_list);

            //
            if(key_list.size() == 0 || key_list.size() != value_list.size())
            {
                LogMsg("%s, line %d, zhuangbei module jinglian error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zb_name_id);
                return false;
            }

            //找到概率，删除
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos != key_list.end() && value_pos != value_list.end()
                    ; ++key_pos, ++value_pos)
                {
                    if(*key_pos == ZB_Key_gailv)
                    {

                        key_list.erase(key_pos);
                        value_list.erase(value_pos);

                        break;
                    }
                }
            }
            //找到有效数，删除
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos != key_list.end() && value_pos != value_list.end()
                    ; ++key_pos, ++value_pos)
                {
                    if(*key_pos == ZB_Key_count)
                    {
                        key_list.erase(key_pos);
                        value_list.erase(value_pos);

                        break;
                    }
                }
            }

            if(key_list.size() == 1 && value_list.size() == 1)
            {
                ZBAttr attr;
                if(!keyValue2Attr(*key_list.begin(), *value_list.begin(), zhuangbei_type, zhuangbei_colour, zhuangbei_level,attr))
                {
                    LogMsg("%s, line %d, zhuangbei module jianding error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zb_name_id);
                    return false;
                }

                identified_attr_vec.push_back(attr);
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei module jinglian error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zb_name_id);
                return false;
            }
        }
    }

    //入库
    {
        std::string attr_str;
        for(int i=0; i<cur_identified_attr_count; ++i)
        {
            char str[64];
            sprintf(str, "hide_attr_type_%d=%u, hide_attr_value_%d=%u, "
                , i+1, identified_attr_vec[i].attr_type, i+1, identified_attr_vec[i].attr_value);

            attr_str = attr_str + std::string(str);
        }
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list set %s identified_attr_count=%u "
            " where zhuangbei_id=%llu"
            , attr_str.c_str(), cur_identified_attr_count, zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再扣钱和道具
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need_count, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , item_need_count, hero_id, ItemsType_Shenbing_Jianding);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

bool ProcServerThread::checkAndShenbingZhuankeJingwen(unsigned int hero_id
    ,unsigned long long zb_id, std::vector < ZBAttr > & jingwen_attr_vec)
{
    jingwen_attr_vec.clear();
    
    //获取现有silver数量
    unsigned silver_total_count = getItemCountInTeam(hero_id, ItemsType_Silver);
    

    //获取现有解封印道具数量
    unsigned item_total_count = getItemCountInTeam(hero_id, ItemsType_JingwenZhuanke);
    

    //检查装备
    unsigned int zhuangbei_hero_id = 0;
    unsigned int zb_name_id = 0;
    unsigned int group_id = 0;
    unsigned int jinglian_level = 0;
    bool has_jingwen = false;
    {
        //
        bool is_unlocked = false;
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_name_list_copy.zhuangbei_name_id, zhuangbei_hero_id, group_id, is_unlocked, "
                " jinglian_level, has_jingwen "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                    group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    is_unlocked = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlocked"));
                    jinglian_level = atoi(Mysql_Thread_Conn->GetField("jinglian_level"));
                    has_jingwen = (bool)atoi(Mysql_Thread_Conn->GetField("has_jingwen"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //检查是否是神兵 
        if(ZBGroupIsShenbing(group_id) == -1)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not shenbing"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //是否已经解封印
        /*if(!is_unlocked)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not unlocked"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }*/

        //是否精炼次数达到要求
        if(jinglian_level < JingwenZhuanke_need_JinglianLevel)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] jinglian is not enought"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //是否已经篆刻
        if(has_jingwen)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is already zhuanke jingwen"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }
    }

    unsigned int silver_need_count = CS::ShenbingZhuankeJingwenNeedSilver();
    if(silver_total_count < silver_need_count)
    {
        LogMsg("%s, line %d,  silver_need_count=[%u] silver_total_count[%u]"
                            , __FILE__, __LINE__, silver_need_count, silver_total_count);
            
        return false;
    }

    unsigned int item_need_count = CS::ShenbingZhuankeJingwenNeedItem();
    if(item_total_count < item_need_count)
    {
        LogMsg("%s, line %d,  item_need_count=[%u] item_total_count[%u]"
                            , __FILE__, __LINE__, item_need_count, item_total_count);
            
        return false;
    }

    //先从模板库中取出装备的经文属性
    unsigned int zhuangbei_type, zhuangbei_colour, zhuangbei_level;
    std::string jingwen_attr_str;
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_type, zhuangbei_name, zhuangbei_colour, "
            " zhuangbei_level, "
            "jingwen_attr     "
            " from hellgate.zhuangbei_name_list_copy where zhuangbei_name_id=%u"
            , zb_name_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                
                //神兵经文属性
                jingwen_attr_str = Mysql_Thread_Conn->GetField("jingwen_attr");
                
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_name_id=[%u] not exist"
                        , __FILE__, __LINE__, zb_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //先篆刻
    {
        {
            //取出所有键值对
            std::list<std::string> key_list;
            std::list<std::string> value_list;
            Str2KeyValueList(jingwen_attr_str, key_list, value_list);

            //
            if(key_list.size() == 0 || key_list.size() != value_list.size())
            {
                LogMsg("%s, line %d, zhuangbei module jinglian error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zb_name_id);
                return false;
            }

            //找到概率，删除
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos != key_list.end() && value_pos != value_list.end()
                    ; ++key_pos, ++value_pos)
                {
                    if(*key_pos == ZB_Key_gailv)
                    {

                        key_list.erase(key_pos);
                        value_list.erase(value_pos);

                        break;
                    }
                }
            }
            //找到有效数，删除
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos != key_list.end() && value_pos != value_list.end()
                    ; ++key_pos, ++value_pos)
                {
                    if(*key_pos == ZB_Key_count)
                    {
                        key_list.erase(key_pos);
                        value_list.erase(value_pos);

                        break;
                    }
                }
            }

            if(key_list.size() == value_list.size())
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos!=key_list.end(); ++key_pos)
                {
                    ZBAttr attr;
                    if(!keyValue2Attr(*key_pos, *value_pos, zhuangbei_type, zhuangbei_colour, zhuangbei_level,attr))
                    {
                        LogMsg("%s, line %d, zhuangbei module jianding error. zhuangbei_name_id=[%u]"
                            , __FILE__, __LINE__, zb_name_id);
                        return false;
                    }

                    jingwen_attr_vec.push_back(attr);
                }

                if(jingwen_attr_vec.size() < 1 || jingwen_attr_vec.size() > 2)
                {
                    LogMsg("%s, line %d, zhuangbei module jingwen error. zhuangbei_name_id=[%u]"
                            , __FILE__, __LINE__, zb_name_id);
                    return false;
                }
                if(jingwen_attr_vec.size() == 1)
                {
                    ZBAttr attr;
                    attr.attr_type = 0;
                    attr.attr_value = 0;
                    attr.cuiqu_suc_ratio = 0;

                    jingwen_attr_vec.push_back(attr);
                }
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei module jinglian error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zb_name_id);
                return false;
            }
        }
    }

    //入库
    {
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list set "
            " has_jingwen=1, "
            " jingwen_attr_type_1=%u, jingwen_attr_value_1=%u, "
            " jingwen_attr_type_2=%u, jingwen_attr_value_2=%u"
            " where zhuangbei_id=%llu"
            , jingwen_attr_vec[0].attr_type, jingwen_attr_vec[0].attr_value
            , jingwen_attr_vec[1].attr_type, jingwen_attr_vec[1].attr_value
            , zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再扣钱和道具
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need_count, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , item_need_count, hero_id, ItemsType_JingwenZhuanke);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }

    return true;
}



bool ProcServerThread::checkAndZBJinglian(unsigned int hero_id
    ,unsigned long long zb_id,unsigned long long cailiao_zb_id
    , unsigned int & jinglian_time
    , std::vector<ItemInfo> &cailiao_vec
    , vector < ZBAttr > & jinglian_attr_vec)
{
    cailiao_vec.clear();
    jinglian_attr_vec.clear();
    jinglian_time = 0;

    /*
    //检查材料装的group_id是不是在强化装的套装配件组中
    if(zb_id == cailiao_zb_id)
    {
        LogMsg("%s, line %d, zhuangbei_id[%llu] is the same id of cailiao_zb_id"
                            , __FILE__, __LINE__, zb_id);
        return false;
    }
    */
    
    //获取现有silver数量
    unsigned silver_total_count = getItemCountInTeam(hero_id, ItemsType_Silver);


    //检查装备
    unsigned int zb_name_id = 0;
    unsigned int zhuangbei_hero_id = 0;
    unsigned int group_id = 0;
    unsigned int zb_colour = 0;
    unsigned int zb_level = 0;
    unsigned int is_unlocked = false;
    {
        //
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_list.zhuangbei_name_id, zhuangbei_hero_id, group_id, "
                " zhuangbei_colour, zhuangbei_level, jinglian_level, is_unlocked "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                    group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    is_unlocked = (bool)(atoi(Mysql_Thread_Conn->GetField("is_unlocked")));
                    zb_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                    zb_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                    jinglian_time = atoi(Mysql_Thread_Conn->GetField("jinglian_level"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //检查是否能精炼
        if(zb_colour < ZhuangbeiColour_Xiyou)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] can not jinglian"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        if(zb_colour == ZhuangbeiColour_Xiyou && !is_unlocked)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not unlocked"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        unsigned int max_jinglian_time = 0;
        max_jinglian_time = CS::getJingLianMaxTimes(zb_colour, zb_level);
        
        //是否已经精炼满
        if(jinglian_time >= max_jinglian_time)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is already jinglian to full level"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }
    }

    //检查精炼材料装状态
    {
        unsigned int cailiao_zb_group_id = 0;
        bool cailiao_zb_equip_by_hero = false;
        {
            char sql[1024];
            sprintf(sql, "select group_id, zhuangbei_hero_id, qianghua_cailiao_total_count, "
                " qianghua_cailiao_goldstar_count, diamond_type_1, diamond_type_2, diamond_type_3"
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , cailiao_zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    cailiao_zb_group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    unsigned int equip_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    if(equip_hero_id != 0)
                    {
                        cailiao_zb_equip_by_hero = true;
                    }
                    else
                    {
                        cailiao_zb_equip_by_hero = false;
                    }
                    
                    int qianghua_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_total_count"));
                    if(qianghua_count > 0){
                        ItemInfo item;
                        item.type = ItemsType_QianghuaNormal;
                        item.count = qianghua_count;
                        cailiao_vec.push_back(item);
                    }
                    int qianghua_goldstar_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_goldstar_count"));
                    if(qianghua_goldstar_count > 0){
                        ItemInfo item;
                        item.type = ItemsType_GoldStar_Qianghua;
                        item.count = qianghua_goldstar_count;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                    if(diamond_type_1 > 0){
                        ItemInfo item;
                        item.type = diamond_type_1;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                    if(diamond_type_2 > 0){
                        ItemInfo item;
                        item.type = diamond_type_2;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));
                    if(diamond_type_3 > 0){
                        ItemInfo item;
                        item.type = diamond_type_3;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                }
                else
                {
                    LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //
        if(cailiao_zb_equip_by_hero)
        {
            LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] has equiped to hero"
                            , __FILE__, __LINE__, cailiao_zb_id);

            return false;
        }

        if(zb_colour == ZhuangbeiColour_Chuanqi) {
            //检查材料装的group_id是不是在强化装的套装配件组中
            if(!check_same_parts(group_id, cailiao_zb_group_id)){
                LogMsg("%s, line %d, zhuangbei_id[%llu] is the not same id of cailiao_zb_id"
                                    , __FILE__, __LINE__, zb_id);
                return false;
            }
        }
        else if(zb_colour == ZhuangbeiColour_Xiyou){
            //检查材料装的group_id是不是跟强化装的group_id相同
            if(group_id != cailiao_zb_group_id){
                LogMsg("%s, line %d, zhuangbei_id[%llu] is the not same id of cailiao_zb_id"
                    , __FILE__, __LINE__, zb_id);
                return false;
            }
        }
    }

    //
    jinglian_time++;

    unsigned int silver_need_count = CS::ZBJinglianNeedSilver(zb_colour, jinglian_time);
    if(silver_total_count < silver_need_count)
    {
        LogMsg("%s, line %d,  silver_need_count=[%u] silver_total_count[%u]"
                            , __FILE__, __LINE__, silver_need_count, silver_total_count);
            
        return false;
    }


    //先从模板库中取出装备的精炼属性
    unsigned int zhuangbei_type, zhuangbei_colour, zhuangbei_level;
    std::vector<std::string> total_jinglian_attr_str_vec;
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_type, zhuangbei_name, zhuangbei_colour, "
            " zhuangbei_level, "
            "jinglian_level_1_attr,"
            "jinglian_level_2_attr,"
            "jinglian_level_3_attr,"
            "jinglian_level_4_attr,"
            "jinglian_level_5_attr,"
            "jinglian_level_6_attr,"
            "jinglian_level_7_attr,"
            "jinglian_level_8_attr,"
            "jinglian_level_9_attr"
            " from hellgate.zhuangbei_name_list_copy where zhuangbei_name_id=%u"
            , zb_name_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                
                //精炼属性
                {
                    unsigned int jinglian_max_time 
                        = CS::getJingLianMaxTimes(zb_colour, zhuangbei_level);
                    
                    for(int i=1; i<=jinglian_max_time; ++i)
                    {
                        char str[32];
                        sprintf(str, "jinglian_level_%d_attr", i);
                        /*if(strlen(Mysql_Thread_Conn->GetField(str)) > 0)
                        {
                            total_jinglian_attr_str_vec.push_back(std::string(Mysql_Thread_Conn->GetField(str)));
                        }
                        else
                        {
                            LogMsg("%s, line %d, jinglian attr count error zhuangbei_group_id[%u]."
                                , __FILE__, __LINE__, group_id);
                            return false;
                        }*/
                    }
                }
                
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_name_id=[%u] not exist"
                        , __FILE__, __LINE__, zb_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //入库
    {
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list set "
            " jinglian_level=%u "
            " where zhuangbei_id=%llu"
            , jinglian_time
            , zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //回收强化材料
    for(int i=0; i<cailiao_vec.size(); i++)
    {
        ObtainItem(hero_id, cailiao_vec[i].type, cailiao_vec[i].count);
    }

    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need_count, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除材料装
    {
        char sql[1024];
        sprintf(sql, "delete from hellgate.zhuangbei_list where zhuangbei_id=%llu"
            , cailiao_zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    __ZhuangbeiDetail detail;
    unsigned int owner_id;
    getZhuangbeiDetail(zb_id, owner_id, detail);
    jinglian_attr_vec = detail.jinglian_attr_vec;

    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }
    
    return true;
}



void ProcServerThread::DealwithChangeTaskStat(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChangeTaskStat", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ChangeTaskStat* chg = (SPCmd_ChangeTaskStat*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ChangeTaskStat))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        chg->task_id = ntohl(chg->task_id);
        chg->stat = ntohl(chg->stat);
    }
    unsigned int main_hero_id = pack->main_hero_id;

    //首先获取主任务进度
    unsigned int maintask_last_actived  = 1;
    unsigned int maintask_status = TaskStatus_NotGot;
    {
        //
        char sql[1024];

        sprintf(sql, "select maintask_last_actived, status "
            " from hellgate.hero_maintask_progress "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                maintask_status = atoi(Mysql_Thread_Conn->GetField("status"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //
    if((maintask_last_actived < chg->task_id) || !canTaskStat1ChangeToStat2ByClient(maintask_status, chg->stat))
    {
        //
        int rspDataLen = sizeof(SPCmd_ChangeTaskStatRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = changeTaskStatRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ChangeTaskStatRsp* rspBody = (SPCmd_ChangeTaskStatRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    //修改状态和进度
    ChangeTaskStat(main_hero_id, chg->task_id, chg->stat);
/*
    //先记录获取经验之前的状态
    HeroInfo heroinfo_before;
    GetHeroBasicInfo(main_hero_id,heroinfo_before);
    
    //如果是提交主线任务，则需要领取任务奖励
    unsigned int exp_reward = 0;
    unsigned int silver_reward = 0;
    if(chg->stat == TaskStatus_Submitted)
    {
        //
        char sql[1024];

        sprintf(sql, "select experience, silver "
            " from hellgate.main_task_reward "
            " where task_id=%u"
            , chg->task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                exp_reward = atoi(Mysql_Thread_Conn->GetField("experience"));
                silver_reward = atoi(Mysql_Thread_Conn->GetField("silver"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //
        obtainExp(main_hero_id,exp_reward);
        ObtainItem(main_hero_id,ItemsType_Silver,silver_reward);
    }
*/
/*服务器已不再需要检测升级，所有升级都是由客户发升级命令触发。
    //检查是否升级
    HeroInfo heroinfo_after;
    GetHeroBasicInfo(main_hero_id, heroinfo_after);
    std::vector<HeroDetail> hero_detail_vec;
    if(heroinfo_after.level > heroinfo_before.level)
    {
        //升级了，将所有角色detail返回
        
        //获取英雄列表
        std::vector<unsigned int> hero_id_vec;
        hero_id_vec.insert(hero_id_vec.end(), main_hero_id); //先把主英雄加进去
        {
            char sql[1024];
            sprintf(sql, "select hero_id from hellgate.hero_infor where parent_hero_id=%u"
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    unsigned int assit_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    hero_id_vec.insert(hero_id_vec.end(), assit_id);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        

        //获取hero detail
        for(int i=0; i<hero_id_vec.size(); ++i)
        {
            HeroDetail detail;
            GetHeroDetail(hero_id_vec[i], detail);

            hero_detail_vec.insert(hero_detail_vec.end(), detail);
        }
    }
    */
    //
    int rspDataLen = sizeof(SPCmd_ChangeTaskStatRsp) 
        + sizeof(HeroDetail)*0;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = changeTaskStatRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ChangeTaskStatRsp* rspBody = (SPCmd_ChangeTaskStatRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->exp = htonl(0);
    rspBody->silver = htonl(0);

    rspBody->hero_count = htonl(0);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    return;
}


void ProcServerThread::DealwithQueryMarket(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryMarket", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryMarket* qry = (SPCmd_QueryMarket*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryMarket))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    //
    std::vector<MarketItem> item_vec;
    bool result_flag = query_market_info(main_hero_id, item_vec);
    
    //
    int rspDataLen = sizeof(SPCmd_QueryMarketRsp) + sizeof(MarketItem)*item_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryMarketRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryMarketRsp* rspBody = (SPCmd_QueryMarketRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->item_count = htons(item_vec.size());
    MarketItem* p = rspBody->item_arr;
    for(int i=0; i<item_vec.size(); ++i, ++p)
    {
        p->id = htonl(item_vec[i].id);
        p->sell_type = htons(item_vec[i].sell_type);
        if(item_vec[i].sell_type <= AttachType_Props) { //道具
            p->sell_item.item.type = htonl(item_vec[i].sell_item.item.type);
            p->sell_item.item.count = htonl(item_vec[i].sell_item.item.count);
        }
        else if(item_vec[i].sell_type == AttachType_PropsDebris) { //道具碎片
            p->sell_item.item_debris.item_id = htonl(item_vec[i].sell_item.item_debris.item_id);
            p->sell_item.item_debris.suipian_id = htonl(item_vec[i].sell_item.item_debris.suipian_id);
            p->sell_item.item_debris.suipian_count = htonl(item_vec[i].sell_item.item_debris.suipian_count);
        }
        else if(item_vec[i].sell_type == AttachType_ArmsDebris) { //装备碎片
            p->sell_item.zb_debris.zb_group_id = htonl(item_vec[i].sell_item.zb_debris.zb_group_id);
            p->sell_item.zb_debris.suipian_id = htonl(item_vec[i].sell_item.zb_debris.suipian_id);
            p->sell_item.zb_debris.suipian_count = htonl(item_vec[i].sell_item.zb_debris.suipian_count);
        }
        else if(item_vec[i].sell_type == AttachType_GiftBag) { //礼包
            p->sell_item.gift.id = htonl(item_vec[i].sell_item.gift.id);
            p->sell_item.gift.count = htonl(item_vec[i].sell_item.gift.count);
        }
        else if(item_vec[i].sell_type == AttachType_Vitality) { //体力
            p->sell_item.vitality = htonl(item_vec[i].sell_item.vitality);
        }
        else {
            continue;
        }

        p->is_unlimit = item_vec[i].is_unlimit;
        p->sell_count = htonl(item_vec[i].sell_count);
        p->need_type = htons(item_vec[i].need_type);
        if(item_vec[i].need_type == AttachType_Gold || item_vec[i].need_type == AttachType_Silver) { 
            //金币与银币
            p->need_item.item.type = htonl(item_vec[i].need_item.item.type);
            p->need_item.item.count = htonl(item_vec[i].need_item.item.count);
        }
        else {
            continue;
        }

        
        p->discount = htons(item_vec[i].discount);
        p->sale_time = htonl(item_vec[i].sale_time);
        p->level_type = htons(item_vec[i].level_type);
        p->level = htonl(item_vec[i].level);
        p->bought_times = htonl(item_vec[i].bought_times);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithBuyItemInMarket(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithBuyItemInMarket", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_BuyItemInMarket* buy = (SPCmd_BuyItemInMarket*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_BuyItemInMarket))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        buy->id = ntohl(buy->id);
        buy->buy_times = ntohs(buy->buy_times);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    bool result_flag = check_and_buy_item(main_hero_id, buy->id, buy->buy_times);
        
    //
    int rspDataLen = sizeof(SPCmd_BuyItemInMarketRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = buyItemInMarketRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_BuyItemInMarketRsp* rspBody = (SPCmd_BuyItemInMarketRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithHeartBeat(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithHeartBeat", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_HeartBeat* beat = (SPCmd_HeartBeat*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_HeartBeat))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        beat = beat;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    unsigned int current_vit;
    std::vector<MarqueeMessage> msg_vec;
    bool result_flag = query_heart_beat_info(main_hero_id, current_vit, msg_vec);
    
    //
    int rspDataLen = sizeof(SPCmd_HeartBeatRsp) + sizeof(MarqueeMessage) * msg_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = heartBeatRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_HeartBeatRsp* rspBody = (SPCmd_HeartBeatRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->current_vit = htonl(current_vit);
    rspBody->msg_count = (unsigned char)msg_vec.size();

    MarqueeMessage *p = rspBody->msg_arr;
    for(int i=0; i<msg_vec.size(); ++i, ++p) {
        p->uid = htonl(msg_vec[i].uid);
        p->type = htons(msg_vec[i].type);
        strcpy(p->subject, msg_vec[i].subject);
        p->object.group_id = htonl(msg_vec[i].object.group_id);
        p->count = htons(msg_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryAnotherTeamInfo(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryAnotherTeamInfo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryAnotherTeamInfo* query = (SPCmd_QueryAnotherTeamInfo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryAnotherTeamInfo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query->hero_id = ntohl(query->hero_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //获取英雄列表
    unsigned int hero_id_arr[4] = {0,0,0,0};
    {
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position<>0 order by position "
            , query->hero_id, query->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int assit_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                unsigned int position = atoi(Mysql_Thread_Conn->GetField("position"));
                if(position > 4)
                {
                    LogMsg("%s, line %d,hero_id[%u] position[%u]", __FILE__, __LINE__, query->hero_id, position);
                    assert(false);
                }

                hero_id_arr[position-1] = assit_id;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //获取hero detail
    HeroDetail hero_detail_arr[4];
    for(int i=0; i<4; ++i)
    {
        HeroDetail detail;
        GetHeroDetail(hero_id_arr[i], detail);

        hero_detail_arr[i] = detail;
    }
    
    std::vector<SkillInfo> skill_vec;
    { //查询技能
        char sql[1024];
        sprintf(sql, "select own_hero_id, skill_id, skill_type, skill_level, is_equiped "
            " from hellgate.skill_in_team where main_hero_id=%u and is_equiped=1 "
            " and own_hero_id in(select hero_id from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position<>0) "
            , query->hero_id
            , query->hero_id, query->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                SkillInfo info;
                
                info.owner_hero_id = atoi(Mysql_Thread_Conn->GetField("own_hero_id"));
                info.skill_id = atoi(Mysql_Thread_Conn->GetField("skill_id"));
                info.skill_type = atoi(Mysql_Thread_Conn->GetField("skill_type"));
                info.skill_level = atoi(Mysql_Thread_Conn->GetField("skill_level"));
                info.is_equiped = (bool)atoi(Mysql_Thread_Conn->GetField("is_equiped"));

                skill_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    { //获取装备列表
        char sql[1024];
        sprintf(sql, "select zhuangbei_id"
            " from hellgate.zhuangbei_list"
            " where owner_hero_id=%u and zhuangbei_hero_id<>0"
            , query->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
    }
    
    //
    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryAnotherTeamInfoRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryAnotherTeamInfoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryAnotherTeamInfoRsp* rspBody = (SPCmd_QueryAnotherTeamInfoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //
    for(int i=0; i<4; ++i) {
        hton_hero_detail(hero_detail_arr[i],rspBody->hero_arr[i]);
    }

    for(int i=0; i<4&&i<skill_vec.size(); ++i) {
        rspBody->skill_arr[i].skill_id = htonl(skill_vec[i].skill_id);
        rspBody->skill_arr[i].skill_type = htonl(skill_vec[i].skill_type);
        rspBody->skill_arr[i].skill_level = htonl(skill_vec[i].skill_level);
        rspBody->skill_arr[i].owner_hero_id = htonl(skill_vec[i].owner_hero_id);
        rspBody->skill_arr[i].is_equiped = skill_vec[i].is_equiped;
    }

    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithChargeVitality(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChargeVitality", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ChargeVitality* buy = (SPCmd_ChargeVitality*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ChargeVitality))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        buy = buy;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询体力购买次数
    unsigned int vati_num = getHeroVipInfo(main_hero_id, VIP_FIELD_TYPE_VITALITY);

    //查询余额
    unsigned int gold_balance = getItemCountInTeam(main_hero_id, ItemsType_Gold);

    if((vati_num <= 0) || (gold_balance < Vitality_Price))
    {
        LogMsg("%s, line %d, hero_id[%u] balance not enough or not buy times"
                        , __FILE__, __LINE__, main_hero_id);

        //
        int rspDataLen = sizeof(SPCmd_ChargeVitalityRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = chargeVitalityRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ChargeVitalityRsp* rspBody = (SPCmd_ChargeVitalityRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        return;
    }

    //先充满体力
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set vit_current=vit_current+%u "
            " where hero_id=%u"
            , Vitality_Total, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再扣钱
    gold_balance -= Vitality_Price;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , gold_balance, main_hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //体力购买次数减1
    updateHeroVipInfo(main_hero_id, VIP_FIELD_TYPE_VITALITY, vati_num-1);
    
    //
    int rspDataLen = sizeof(SPCmd_ChargeVitalityRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = chargeVitalityRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ChargeVitalityRsp* rspBody = (SPCmd_ChargeVitalityRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->gold_balance = htonl(gold_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


struct _SuitInfoDB
{
    unsigned int suit_id;
    std::string name;
    unsigned int group_id[6];
    std::string attr[5];
};
void ProcServerThread::DealwithQueryAllSuitName(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryAllSuitName", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryAllSuitName* query = (SPCmd_QueryAllSuitName*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryAllSuitName))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryAllSuitNameRsp) + m_suit_vec.size()*sizeof(SuitNameInfo);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryAllSuitNameRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryAllSuitNameRsp* rspBody = (SPCmd_QueryAllSuitNameRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //
    rspBody->suit_count = htonl(m_suit_vec.size());

    SuitNameInfo* p = (SuitNameInfo*)rspBody->data;
    for(int i=0; i<m_suit_vec.size(); ++i)
    {
        memcpy(p, &m_suit_vec[i], sizeof(SuitNameInfo));
        
        p->suit_id = htonl(p->suit_id);
        
        p->group_id_1 = htonl(p->group_id_1);
        p->group_id_2 = htonl(p->group_id_2);
        p->group_id_3 = htonl(p->group_id_3);
        p->group_id_4 = htonl(p->group_id_4);
        p->group_id_5 = htonl(p->group_id_5);
        p->group_id_6 = htonl(p->group_id_6);

        p->zhuangbei_type_1 = htonl(p->zhuangbei_type_1);
        p->zhuangbei_type_2 = htonl(p->zhuangbei_type_2);
        p->zhuangbei_type_3 = htonl(p->zhuangbei_type_3);
        p->zhuangbei_type_4 = htonl(p->zhuangbei_type_4);
        p->zhuangbei_type_5 = htonl(p->zhuangbei_type_5);
        p->zhuangbei_type_6 = htonl(p->zhuangbei_type_6);

        for(int j=0; j<5; ++j)
        {
            p->suit_attr[j][0].attr_type = htonl(m_suit_vec[i].suit_attr[j][0].attr_type);
            p->suit_attr[j][0].attr_value = htonl(m_suit_vec[i].suit_attr[j][0].attr_value);

            p->suit_attr[j][1].attr_type = htonl(m_suit_vec[i].suit_attr[j][1].attr_type);
            p->suit_attr[j][1].attr_value = htonl(m_suit_vec[i].suit_attr[j][1].attr_value);
        }


        //
        p++;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryAllShenbingList(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryAllShenbingList", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryAllShenbingList* query = (SPCmd_QueryAllShenbingList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryAllShenbingList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;
    

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryAllShenbingListRsp) 
            + sizeof(DuanzaoGroupZBInfo)*m_shenbing_vec.size();
    for(int i=0; i<m_shenbing_vec.size(); ++i)
    {
        for(int j=0; j<m_shenbing_vec[i].attr_vec.size(); ++j)
        {
            rspDataLen += m_shenbing_vec[i].attr_vec[j].length()+1;
        }

        rspDataLen += m_shenbing_vec[i].desc.length()+1;
    }
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryAllShenbingListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryAllShenbingListRsp* rspBody = (SPCmd_QueryAllShenbingListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //
    rspBody->shenbing_count = htonl(m_shenbing_vec.size());

    DuanzaoGroupZBInfo* p = (DuanzaoGroupZBInfo*)rspBody->zb_arr;
    for(int i=0; i<m_shenbing_vec.size(); ++i)
    {
        p->ratio = htonl(m_shenbing_vec[i].ratio);
        
        p->zb_group_id = htonl(m_shenbing_vec[i].zb_group_id);
        p->profession_id = htonl(m_shenbing_vec[i].profession_id);
        p->next_group_id = htonl(m_shenbing_vec[i].next_group_id);
        p->need_expend_group_id = htonl(m_shenbing_vec[i].need_expend_group_id);
        p->zhuangbei_type = htonl(m_shenbing_vec[i].zhuangbei_type);
        p->zhuangbei_colour = htonl(m_shenbing_vec[i].zhuangbei_colour);
        p->level = htonl(m_shenbing_vec[i].level);
        strncpy(p->zhuangbei_name, m_shenbing_vec[i].zhuangbei_name, ZhuangbeiNameMaxLen);
        p->zhuangbei_name[ZhuangbeiNameMaxLen] = 0;
        strncpy(p->zhuangbei_pic, m_shenbing_vec[i].zhuangbei_pic, ZhuangbeiPicMaxLen);
        p->zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;

        p->gongji_min_min = htonl(m_shenbing_vec[i].gongji_min_min);
        p->gongji_min_max = htonl(m_shenbing_vec[i].gongji_min_max);
        p->gongji_max_min = htonl(m_shenbing_vec[i].gongji_max_min);
        p->gongji_max_max = htonl(m_shenbing_vec[i].gongji_max_max);
        p->wufang_min = htonl(m_shenbing_vec[i].wufang_min);
        p->wufang_max = htonl(m_shenbing_vec[i].wufang_max);
        p->hole1_percent = htonl(m_shenbing_vec[i].hole1_percent);
        p->hole2_percent = htonl(m_shenbing_vec[i].hole2_percent);
        p->hole3_percent = htonl(m_shenbing_vec[i].hole3_percent);

        p->attr_str_count = htonl(m_shenbing_vec[i].attr_vec.size());

        char* str = p->attr_str;
        for(int j=0; j<m_shenbing_vec[i].attr_vec.size(); ++j)
        {
            strcpy(str, m_shenbing_vec[i].attr_vec[j].c_str());

            str += m_shenbing_vec[i].attr_vec[j].length()+1;
        }

        //desc
        strcpy(str, m_shenbing_vec[i].desc.c_str());
        str += m_shenbing_vec[i].desc.length() + 1;
        
        //
        p = (DuanzaoGroupZBInfo*)str;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithQueryFubenDiaoluo(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryFubenDiaoluo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryFubenDiaoluo* query = (SPCmd_QueryFubenDiaoluo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryFubenDiaoluo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query->task_id = ntohl(query->task_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //先查询道具掉落
    std::vector<unsigned int> item_type_vec;
    {
        char sql[1024];
        sprintf(sql, "select "
            " special_item_type_1, "
            " special_item_type_2, "
            " special_item_type_3, "
            " special_item_type_4, "
            " special_item_type_5, "
            " special_item_type_6, "
            " special_item_type_7, "
            " special_item_type_8, "
            " special_item_type_9, "
            " special_item_type_10 "
            " from hellgate.task_template_test where task_id=%u and task_type=%u "
            , query->task_id, (int)GuanQiaType_BOSS);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                

                for(int i=1; i<11; ++i)
                {
                    char type_str[32];
                    sprintf(type_str, "special_item_type_%d", i);
                    unsigned int type = atoi(Mysql_Thread_Conn->GetField(type_str));
                    if(type > 0)
                    {
                        item_type_vec.push_back(type);
                    }
                    
                }
            }
            else
            {
                LogMsg("%s, line %d, task_id[%u] not exist"
                        , __FILE__, __LINE__, query->task_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    //先查group_id
    std::vector<unsigned int> group_id_vec;
    {
        char sql[1024];
        sprintf(sql, "select "
            " special_zb_group_id_1, "
            " special_zb_group_id_2, "
            " special_zb_group_id_3, "
            " special_zb_group_id_4, "
            " special_zb_group_id_5, "
            " special_zb_group_id_6, "
            " special_zb_group_id_7, "
            " special_zb_group_id_8, "
            " special_zb_group_id_9, "
            " special_zb_group_id_10 "
            " from hellgate.task_template_test where task_id=%u and task_type=%u "
            , query->task_id, (int)GuanQiaType_BOSS);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                

                for(int i=1; i<11; ++i)
                {
                    char id_str[32];
                    sprintf(id_str, "special_zb_group_id_%d", i);
                    unsigned int id = atoi(Mysql_Thread_Conn->GetField(id_str));
                    if(id > 0)
                    {
                        group_id_vec.push_back(id);
                    }
                    
                }
            }
            else
            {
                LogMsg("%s, line %d, task_id[%u] not exist"
                        , __FILE__, __LINE__, query->task_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //过滤掉不可用装备
    HeroInfo main_hero_info;
    GetHeroBasicInfo(main_hero_id, main_hero_info);
    group_id_vec = filterZBGroupCannotUse((Profession)main_hero_info.profession_id, group_id_vec);

    //再查info
    std::vector<FubenDiaoluoZBInfo> zb_info_vec;
    std::vector< std::vector<std::string> > zb_attr_str_vec;
    std::vector<std::string> zb_desc_vec;
    for(int i=0; i<group_id_vec.size(); ++i)
    {
        char sql[2048];
        sprintf(sql, "select distinct(group_id), zhuangbei_type, "
            " zhuangbei_colour, zhuangbei_name, zhuangbei_pic, zhuangbei_level, "
            " gongji_min_min, gongji_min_max, gongji_max_min, gongji_max_max, "
            " wufang_min, wufang_max, hole1_percent, hole2_percent, hole3_percent, "
            " attr_1, attr_2, attr_3, attr_4, attr_5, attr_6, attr_7, attr_8, attr_9, attr_10, "
            " zhuangbei_desc "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_name_list_copy.group_id=%u "
            , group_id_vec[i]);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                FubenDiaoluoZBInfo info;
                
                info.group_id = group_id_vec[i];
                info.is_suipian = false; //不是碎片
                
                info.zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                info.zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                
                strncpy(info.zhuangbei_name, Mysql_Thread_Conn->GetField("zhuangbei_name"), ZhuangbeiNameMaxLen);
                info.zhuangbei_name[ZhuangbeiNameMaxLen] = 0;

                strncpy(info.zhuangbei_pic, Mysql_Thread_Conn->GetField("zhuangbei_pic"), ZhuangbeiPicMaxLen);
                info.zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;
                
                info.level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));

                info.gongji_min_min = atoi(Mysql_Thread_Conn->GetField("gongji_min_min"));
                info.gongji_min_max = atoi(Mysql_Thread_Conn->GetField("gongji_min_max"));
                info.gongji_max_min = atoi(Mysql_Thread_Conn->GetField("gongji_max_min"));
                info.gongji_max_max = atoi(Mysql_Thread_Conn->GetField("gongji_max_max"));
                info.wufang_min = atoi(Mysql_Thread_Conn->GetField("wufang_min"));
                info.wufang_max = atoi(Mysql_Thread_Conn->GetField("wufang_max"));
                
                get_zb_hole_percent(info.level, info.zhuangbei_colour, info.zhuangbei_type,
                    info.hole1_percent, info.hole2_percent, info.hole3_percent);
                

                std::vector<std::string> attr_vec;
                if(strlen(Mysql_Thread_Conn->GetField("attr_1")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_1")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_2")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_2")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_3")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_3")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_4")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_4")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_5")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_5")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_6")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_6")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_7")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_7")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_8")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_8")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_9")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_9")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_10")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_10")));
                }

                //
                std::string desc = (Mysql_Thread_Conn->GetField("zhuangbei_desc"));

                //
                zb_info_vec.push_back(info);
                zb_attr_str_vec.push_back(attr_vec);
                zb_desc_vec.push_back(desc);
            }
            else
            {
                LogMsg("%s, line %d, group_id[%u] not exist"
                        , __FILE__, __LINE__, group_id_vec[i]);
                
                Mysql_Thread_Conn->FreeResult();
                
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再查装备碎片掉落
    std::vector<unsigned int> zb_suipian_group_id_vec;
    if(query->task_id >= HellTaskId_Min)
    {
        
        char sql[1024];
        sprintf(sql, "select diaoluo_zb_group_id from hellgate.hell_task_chuanqi_suipian "
            " where profession_id=%u and task_id=%u"
            , main_hero_info.profession_id, query->task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                unsigned int shenbing_zb_group_id = atoi(Mysql_Thread_Conn->GetField("diaoluo_zb_group_id"));

                zb_suipian_group_id_vec.push_back(shenbing_zb_group_id);
            } 
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再查info
    for(int i=0; i<zb_suipian_group_id_vec.size(); ++i)
    {
        char sql[2048];
        sprintf(sql, "select distinct(group_id), zhuangbei_type, "
            " zhuangbei_colour, zhuangbei_name, zhuangbei_pic, zhuangbei_level, "
            " gongji_min_min, gongji_min_max, gongji_max_min, gongji_max_max, "
            " wufang_min, wufang_max, hole1_percent, hole2_percent, hole3_percent, "
            " attr_1, attr_2, attr_3, attr_4, attr_5, attr_6, attr_7, attr_8, attr_9, attr_10, "
            " zhuangbei_desc "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_name_list_copy.group_id=%u "
            , zb_suipian_group_id_vec[i]);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                FubenDiaoluoZBInfo info;
                
                info.group_id = zb_suipian_group_id_vec[i];
                info.is_suipian = true; //是碎片
                
                info.zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                info.zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                
                strncpy(info.zhuangbei_name, Mysql_Thread_Conn->GetField("zhuangbei_name"), ZhuangbeiNameMaxLen);
                info.zhuangbei_name[ZhuangbeiNameMaxLen] = 0;

                strncpy(info.zhuangbei_pic, Mysql_Thread_Conn->GetField("zhuangbei_pic"), ZhuangbeiPicMaxLen);
                info.zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;
                
                info.level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));

                info.gongji_min_min = atoi(Mysql_Thread_Conn->GetField("gongji_min_min"));
                info.gongji_min_max = atoi(Mysql_Thread_Conn->GetField("gongji_min_max"));
                info.gongji_max_min = atoi(Mysql_Thread_Conn->GetField("gongji_max_min"));
                info.gongji_max_max = atoi(Mysql_Thread_Conn->GetField("gongji_max_max"));
                info.wufang_min = atoi(Mysql_Thread_Conn->GetField("wufang_min"));
                info.wufang_max = atoi(Mysql_Thread_Conn->GetField("wufang_max"));
                
                get_zb_hole_percent(info.level, info.zhuangbei_colour, info.zhuangbei_type,
                    info.hole1_percent, info.hole2_percent, info.hole3_percent);

                std::vector<std::string> attr_vec;
                if(strlen(Mysql_Thread_Conn->GetField("attr_1")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_1")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_2")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_2")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_3")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_3")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_4")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_4")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_5")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_5")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_6")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_6")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_7")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_7")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_8")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_8")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_9")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_9")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_10")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_10")));
                }

                //
                std::string desc = (Mysql_Thread_Conn->GetField("zhuangbei_desc"));

                //
                zb_info_vec.push_back(info);
                zb_attr_str_vec.push_back(attr_vec);
                zb_desc_vec.push_back(desc);
            }
            else
            {
                LogMsg("%s, line %d, group_id[%u] not exist"
                        , __FILE__, __LINE__, zb_suipian_group_id_vec[i]);
                
                Mysql_Thread_Conn->FreeResult();
                
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryFubenDiaoluoRsp) + item_type_vec.size()*sizeof(unsigned int) 
                       + sizeof(unsigned int) + zb_info_vec.size()*sizeof(FubenDiaoluoZBInfo);
    for(int i=0; i<zb_attr_str_vec.size(); ++i)
    {
        for(int j=0; j<zb_attr_str_vec[i].size(); ++j)
        {
            rspDataLen += (zb_attr_str_vec[i])[j].length()+1;
        }

        rspDataLen += zb_desc_vec[i].length()+1;
    }
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryFubenDiaoluoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryFubenDiaoluoRsp* rspBody = (SPCmd_QueryFubenDiaoluoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //item
    rspBody->item_count = htonl(item_type_vec.size());
    for(int i=0; i<item_type_vec.size(); ++i)
    {
        rspBody->item_type_arr[i] = htonl(item_type_vec[i]);
    }
    

    //
    unsigned int* p_count = rspBody->item_type_arr + item_type_vec.size();
    *p_count = htonl(zb_info_vec.size());

    FubenDiaoluoZBInfo* p = (FubenDiaoluoZBInfo*)(p_count+1);
    for(int i=0; i<zb_info_vec.size(); ++i)
    {
        p->group_id = htonl(zb_info_vec[i].group_id);
        p->zhuangbei_type = htonl(zb_info_vec[i].zhuangbei_type);
        p->zhuangbei_colour = htonl(zb_info_vec[i].zhuangbei_colour);
        p->level = htonl(zb_info_vec[i].level);
        strncpy(p->zhuangbei_name, zb_info_vec[i].zhuangbei_name, ZhuangbeiNameMaxLen);
        p->zhuangbei_name[ZhuangbeiNameMaxLen] = 0;
        strncpy(p->zhuangbei_pic, zb_info_vec[i].zhuangbei_pic, ZhuangbeiPicMaxLen);
        p->zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;

        p->gongji_min_min = htonl(zb_info_vec[i].gongji_min_min);
        p->gongji_min_max = htonl(zb_info_vec[i].gongji_min_max);
        p->gongji_max_min = htonl(zb_info_vec[i].gongji_max_min);
        p->gongji_max_max = htonl(zb_info_vec[i].gongji_max_max);
        p->wufang_min = htonl(zb_info_vec[i].wufang_min);
        p->wufang_max = htonl(zb_info_vec[i].wufang_max);
        p->hole1_percent = htonl(zb_info_vec[i].hole1_percent);
        p->hole2_percent = htonl(zb_info_vec[i].hole2_percent);
        p->hole3_percent = htonl(zb_info_vec[i].hole3_percent);

        p->attr_str_count = htonl(zb_attr_str_vec[i].size());

        char* str = p->attr_str;
        for(int j=0; j<zb_attr_str_vec[i].size(); ++j)
        {
            strcpy(str, (zb_attr_str_vec[i])[j].c_str());

            str += (zb_attr_str_vec[i])[j].length()+1;
        }

        //desc
        strcpy(str, zb_desc_vec[i].c_str());
        str += zb_desc_vec[i].length() + 1;
        
        //
        p = (FubenDiaoluoZBInfo*)str;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithArenaEnter(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithArenaEnter", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ArenaEnter* enter = (SPCmd_ArenaEnter*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ArenaEnter))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询竞技场随机模式还剩多少次
    unsigned int arena_time_remainder = 0;
    {
        
        char sql[1024];
        sprintf(sql, "select free_fight_remainder_time from hellgate.arena_hero_info where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);

            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                arena_time_remainder = atoi(Mysql_Thread_Conn->GetField("free_fight_remainder_time"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(arena_time_remainder == 0)
    {
        //
        int rspDataLen = sizeof(SPCmd_ArenaEnterRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = arenaEnterRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ArenaEnterRsp* rspBody = (SPCmd_ArenaEnterRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    HeroInfo main_hero_info;
    GetHeroBasicInfo(main_hero_id, main_hero_info);

    std::vector<ArenaHero> arena_partner_vec;
    //进入竞技场数据结构
    bool isReEnter = false;
    pthread_mutex_lock(&m_arena.mutex);
    {
        //根据level找到相应的房间 
        ArenaRoom* room = getArenaRoom(main_hero_info.level, enter->hardLevel);

        //检查自己是否已经在房间中。这种情况可能是客户端重连或占位机器人造成
        std::vector<ArenaHero>::iterator pos = room->hero_vec.begin();
        for(; pos!=room->hero_vec.end(); ++pos)
        {
            if(pos->hero_id == main_hero_id)
            {
                isReEnter = true;
                
                //把自己删除
                room->hero_vec.erase(pos);
                break;
            }
        }

        //
        arena_partner_vec = room->hero_vec;
        

        assert(room->hero_vec.size() <= ARENA_ROOM_HERO_COUNT-1);
        
        if(room->hero_vec.size() < ARENA_ROOM_HERO_COUNT-1)
        {
            if(room->hero_vec.size() == 0)
            {
                //我是第一个进房间的
                room->create_time = time(0);
            }
            
            //把自己放入房间 
            ArenaHero arena_hero;
            arena_hero.hero_id = main_hero_id;
            arena_hero.type = ArenaHeroType_OnlinePlayer;
            
            room->hero_vec.push_back(arena_hero);
        }
        else
        {
            //房间已经满了，清空 
            room->hero_vec.clear();
            room->create_time = 0;
        }
    }
    pthread_mutex_unlock(&m_arena.mutex);

    //先给所有前面进入的玩家发送update
    if(!isReEnter)
    {
        //给所有在线partner发update
        for(int i=0; i<arena_partner_vec.size(); ++i)
        {
            if(arena_partner_vec[i].type == ArenaHeroType_OnlinePlayer)
            {
                sendArenaUpdateRoomRsp(arena_partner_vec[i].hero_id, main_hero_id);
            }
        }
    }
    //然后给自己回复
    sendArenaEnterRsp(pack->client_id, main_hero_id, pack->fd_account, arena_partner_vec);

    //如果房间满了，则开打
    if(arena_partner_vec.size() == ARENA_ROOM_HERO_COUNT-1)
    {
        //生成并发送竞技结果
        ArenaHero arena_hero;
        arena_hero.hero_id = main_hero_id;
        arena_hero.type = ArenaHeroType_OnlinePlayer;
        arena_partner_vec.push_back(arena_hero);
        
        sendArenaBattleAndGiftRsp(arena_partner_vec);
        
    }


    return;
}

void ProcServerThread::DealwithArenaGetGift(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithArenaGetGift", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ArenaGetGift* get = (SPCmd_ArenaGetGift*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ArenaGetGift))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->gift_id = ntohl(get->gift_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    bool err_code = Error;
    {
        GiftJifen gift;
        if(!getArenaGiftBox(main_hero_id, get->gift_id,gift))
        {
            LogMsg("%s, line %d,getGiftBox failed. hero_id[%u], gift_id[%u]"
                , __FILE__, __LINE__, main_hero_id, get->gift_id);
        }
        else
        {
            //增加积分
            {
                char sql[1024];
                sprintf(sql, "update hellgate.arena_hero_info set jifen=jifen+%u"
                    " where hero_id=%u"
                    , gift.jifen
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            err_code = Success;
        }
    }

    //
    //
    int rspDataLen = sizeof(SPCmd_ArenaGetGiftRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = arenaGetGiftRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ArenaGetGiftRsp* rspBody = (SPCmd_ArenaGetGiftRsp*)((rspHead)+1);
    rspBody->err_code = htonl(err_code);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryArenaTeamBasicInfo(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryArenaTeamBasicInfo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryArenaTeamBasicInfo* query = (SPCmd_QueryArenaTeamBasicInfo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryArenaTeamBasicInfo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;
    
    //
    ArenaTeamBasicInfo team_info;
    getAndRefreshHeroArenaBasicInfo(main_hero_id, team_info);
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryArenaTeamBasicInfoRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryArenaTeamBasicInfoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryArenaTeamBasicInfoRsp* rspBody = (SPCmd_QueryArenaTeamBasicInfoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->team_info.free_fight_remainder_time = htonl(team_info.free_fight_remainder_time);
    rspBody->team_info.challenge_remainder_time = htonl(team_info.challenge_remainder_time);
    rspBody->team_info.jifen = htonl(team_info.jifen);
    rspBody->team_info.buy_challenge_remainder_time = htonl(team_info.buy_challenge_remainder_time);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithQueryArenaMarket(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryArenaMarket", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryArenaMarket* query = (SPCmd_QueryArenaMarket*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryArenaMarket))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;
    
    //
    std::vector<ArenaMarketItem> item_vec;
    {
        char sql[1024];
        sprintf(sql, "select item_type, item_count, jifen_count "
            " from hellgate.arena_market");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ArenaMarketItem item;
                
                item.item_type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.item_count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                item.jifen_count = atoi(Mysql_Thread_Conn->GetField("jifen_count"));

                item_vec.insert(item_vec.end(), item);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryArenaMarketRsp) + sizeof(ArenaMarketItem)*item_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryArenaMarketRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryArenaMarketRsp* rspBody = (SPCmd_QueryArenaMarketRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->item_count = htonl(item_vec.size());
    for(int i=0; i<item_vec.size(); ++i)
    {
        rspBody->item_arr[i].item_type = htonl(item_vec[i].item_type);
        rspBody->item_arr[i].item_count = htonl(item_vec[i].item_count);
        rspBody->item_arr[i].jifen_count = htonl(item_vec[i].jifen_count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithRefreshArenaChlgList(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithArenaChlgListRefresh", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_RefreshArenaChallengeList* refresh = (SPCmd_RefreshArenaChallengeList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_RefreshArenaChallengeList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        refresh = refresh;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    unsigned int gold_balance = 0;
    unsigned int silver_balance = 0;
    ItemInfo item;
    std::vector<ArenaChlgerHeroInfo> hero_vec;
    if(!checkAndRefreshArenaChlgList(main_hero_id
        , hero_vec, gold_balance, silver_balance, item))
    {
        //
        int rspDataLen = sizeof(SPCmd_RefreshArenaChallengeListRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = refreshArenaChlgListRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_RefreshArenaChallengeListRsp* rspBody = (SPCmd_RefreshArenaChallengeListRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_RefreshArenaChallengeListRsp)+sizeof(ArenaChlgerHeroInfo)*hero_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = refreshArenaChlgListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_RefreshArenaChallengeListRsp* rspBody = (SPCmd_RefreshArenaChallengeListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->gold_balance = htonl(gold_balance);
    rspBody->silver_balance = htonl(silver_balance);

    rspBody->item_need.type = htonl(item.type);
    rspBody->item_need.count = htonl(item.count);
    
    rspBody->hero_count = htonl(hero_vec.size());
    for(int i=0; i<hero_vec.size(); ++i)
    {
        rspBody->hero_arr[i].jifen = htonl(hero_vec[i].jifen);
        rspBody->hero_arr[i].has_win = htonl(hero_vec[i].has_win);

        hton_hero_info(hero_vec[i].hero_info, rspBody->hero_arr[i].hero_info);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}

void ProcServerThread::DealwithQueryArenaChlgList(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryArenaChlgList", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryArenaChallengeList* query = (SPCmd_QueryArenaChallengeList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryArenaChallengeList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    HeroInfo main_hero_info;
    GetHeroBasicInfo(main_hero_id,main_hero_info);

    //
    std::vector<ArenaChlgerHeroInfo> hero_vec;
    unsigned int refresh_timestamp = 0;
    unsigned int refresh_times = 0;
    bool has_record = false;
    {
        char sql[1024];
        sprintf(sql, "select  "
            " refresh_timestamp, refresh_times, "
            " chlger_hero_id_1, jifen_1, chlg_win_1, "
            " chlger_hero_id_2, jifen_2, chlg_win_2, "
            " chlger_hero_id_3, jifen_3, chlg_win_3, "
            " chlger_hero_id_4, jifen_4, chlg_win_4, "
            " chlger_hero_id_5, jifen_5, chlg_win_5, "
            " chlger_hero_id_6, jifen_6, chlg_win_6 "
            " from hellgate.arena_hero_chlg_list"
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_record = true;
                
                refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                refresh_times = atoi(Mysql_Thread_Conn->GetField("refresh_times"));

                for(int i=1;i<=6; ++i)
                {
                    char hero_id_str[32];
                    char jifen_str[32];
                    char chlg_win_str[32];
                    sprintf(hero_id_str, "chlger_hero_id_%u", i);
                    sprintf(jifen_str, "jifen_%u", i);
                    sprintf(chlg_win_str, "chlg_win_%u", i);

                    ArenaChlgerHeroInfo info;
                    info.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_id_str));
                    info.jifen = atoi(Mysql_Thread_Conn->GetField(jifen_str));
                    info.has_win = (bool)atoi(Mysql_Thread_Conn->GetField(chlg_win_str));

                    

                    hero_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //查询出对手信息
        for(int i=0; i<hero_vec.size(); ++i)
        {
            GetHeroBasicInfo(hero_vec[i].hero_info.hero_id,hero_vec[i].hero_info);
        }
        
    }
    
    //如果还没有记录则创建
    if(!has_record)
    {
        refresh_times = 0;

        //选择对手列表
        std::vector<unsigned int> robot_id_vec;
        for(int i=0; i<6; ++i)
        {
            std::vector<unsigned int> hero_id_except;
            hero_id_except.push_back(main_hero_id);
            hero_id_except.insert(hero_id_except.end(), robot_id_vec.begin(), robot_id_vec.end());
            std::vector<unsigned int> temp_vec;

            unsigned int robot_level_min = 0;
            if(main_hero_info.level >= 3)
            {
                robot_level_min = main_hero_info.level - 3;
            }
            getRobot(robot_level_min,main_hero_info.level+3, hero_id_except,1,temp_vec);

            robot_id_vec.push_back(temp_vec[0]);
        }
        //查询出对手信息
        for(int i=0; i<robot_id_vec.size(); ++i)
        {
            HeroInfo hero_info;
            GetHeroBasicInfo(robot_id_vec[i],hero_info);

            //计算应得积分
            unsigned int jifen = ArenaChallenge_NormalJifen;
            if(hero_info.level > main_hero_info.level+1)
            {
                jifen = ArenaChallenge_HighJifen;
            }
            else if(hero_info.level < main_hero_info.level-1)
            {
                 jifen = ArenaChallenge_LowJifen;
            }

            ArenaChlgerHeroInfo chlger_info;
            memcpy(&chlger_info.hero_info, &hero_info, sizeof(hero_info));
            chlger_info.has_win = false;
            chlger_info.jifen = jifen;

            hero_vec.push_back(chlger_info);
        }

        //已等级来从大到小的排序
        arena_bubble_sort(hero_vec);

        //
        char sql[1024];
        sprintf(sql, "insert into hellgate.arena_hero_chlg_list "
            " set hero_id=%u, refresh_timestamp=%u, refresh_times=%u, "
            " chlger_hero_id_1=%u, jifen_1=%u, chlg_win_1=0, "
            " chlger_hero_id_2=%u, jifen_2=%u, chlg_win_2=0, "
            " chlger_hero_id_3=%u, jifen_3=%u, chlg_win_3=0, "
            " chlger_hero_id_4=%u, jifen_4=%u, chlg_win_4=0, "
            " chlger_hero_id_5=%u, jifen_5=%u, chlg_win_5=0, "
            " chlger_hero_id_6=%u, jifen_6=%u, chlg_win_6=0 "
            , main_hero_id, (unsigned int)time(0), refresh_times
            , hero_vec[0].hero_info.hero_id, hero_vec[0].jifen
            , hero_vec[1].hero_info.hero_id, hero_vec[1].jifen
            , hero_vec[2].hero_info.hero_id, hero_vec[2].jifen
            , hero_vec[3].hero_info.hero_id, hero_vec[3].jifen
            , hero_vec[4].hero_info.hero_id, hero_vec[4].jifen
            , hero_vec[5].hero_info.hero_id, hero_vec[5].jifen);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        bool need_refresh = isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour);
        if(!need_refresh)
        {
            //检查是否所有对手都已经战胜了
            bool all_win = true;
            for(int i=0; i<hero_vec.size(); ++i)
            {
                if(!hero_vec[i].has_win)
                {
                    all_win = false;
                    break;
                }
            }

            if(all_win)
            {
                need_refresh = true;
            }
        }
        
        if(need_refresh)
        {
            refresh_times = 0;
            hero_vec.clear();
            
            {
                std::vector<unsigned int> robot_id_vec;
                for(int i=0; i<6; ++i)
                {
                    std::vector<unsigned int> hero_id_except;
                    hero_id_except.push_back(main_hero_id);
                    hero_id_except.insert(hero_id_except.end(), robot_id_vec.begin(), robot_id_vec.end());
                    std::vector<unsigned int> temp_vec;
                    
                    unsigned int robot_level_min = 0;
                    if(main_hero_info.level >= 3)
                    {
                        robot_level_min = main_hero_info.level - 3;
                    }
                    getRobot(robot_level_min,main_hero_info.level+3, hero_id_except,1,temp_vec);

                    robot_id_vec.push_back(temp_vec[0]);
                }
                //查询出对手信息
                for(int i=0; i<robot_id_vec.size(); ++i)
                {
                    HeroInfo hero_info;
                    GetHeroBasicInfo(robot_id_vec[i],hero_info);

                    //计算应得积分
                    unsigned int jifen = ArenaChallenge_NormalJifen;
                    if(hero_info.level > main_hero_info.level+1)
                    {
                        jifen = ArenaChallenge_HighJifen;
                    }
                    else if(hero_info.level < main_hero_info.level-1)
                    {
                         jifen = ArenaChallenge_LowJifen;
                    }

                    ArenaChlgerHeroInfo chlger_info;
                    memcpy(&chlger_info.hero_info, &hero_info, sizeof(hero_info));
                    chlger_info.has_win = false;
                    chlger_info.jifen = jifen;

                    hero_vec.push_back(chlger_info);
                }
                
                //已等级来从大到小的排序
                arena_bubble_sort(hero_vec);

                //
                char sql[1024];
                sprintf(sql, "update hellgate.arena_hero_chlg_list "
                    " set refresh_timestamp=%u, refresh_times=%u, "
                    " chlger_hero_id_1=%u, jifen_1=%u, chlg_win_1=0, "
                    " chlger_hero_id_2=%u, jifen_2=%u, chlg_win_2=0, "
                    " chlger_hero_id_3=%u, jifen_3=%u, chlg_win_3=0, "
                    " chlger_hero_id_4=%u, jifen_4=%u, chlg_win_4=0, "
                    " chlger_hero_id_5=%u, jifen_5=%u, chlg_win_5=0, "
                    " chlger_hero_id_6=%u, jifen_6=%u, chlg_win_6=0 "
                    " where hero_id=%u"
                    , (unsigned int)time(0), refresh_times
                    , hero_vec[0].hero_info.hero_id, hero_vec[0].jifen
                    , hero_vec[1].hero_info.hero_id, hero_vec[1].jifen
                    , hero_vec[2].hero_info.hero_id, hero_vec[2].jifen
                    , hero_vec[3].hero_info.hero_id, hero_vec[3].jifen
                    , hero_vec[4].hero_info.hero_id, hero_vec[4].jifen
                    , hero_vec[5].hero_info.hero_id, hero_vec[5].jifen
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryArenaChallengeListRsp)+sizeof(ArenaChlgerHeroInfo)*hero_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryArenaChlgListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryArenaChallengeListRsp* rspBody = (SPCmd_QueryArenaChallengeListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    ItemInfo item;
    CS::refreshArenaChlgListNeedItem(refresh_times +1, item);

    rspBody->item_need.type = htonl(item.type);
    rspBody->item_need.count = htonl(item.count);
    
    rspBody->hero_count = htonl(hero_vec.size());
    for(int i=0; i<hero_vec.size(); ++i)
    {
        rspBody->hero_arr[i].jifen = htonl(hero_vec[i].jifen);
        rspBody->hero_arr[i].has_win = htonl(hero_vec[i].has_win);

        hton_hero_info(hero_vec[i].hero_info, rspBody->hero_arr[i].hero_info);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}


void ProcServerThread::DealwithArenaChallenge(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithArenaChallenge", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ArenaChallenge* challenge = (SPCmd_ArenaChallenge*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ArenaChallenge))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        challenge->challenge_hero_id = ntohl(challenge->challenge_hero_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //判断合法性并查询出本次战斗可能得到的积分
    unsigned int jifen_thisfight = 0;
    if(!checkArenaChallengeValideAndGetJifen(main_hero_id,challenge->challenge_hero_id, jifen_thisfight))
    {
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ArenaChallengeRsp);
        
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = arenaChallengeRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ArenaChallengeRsp* rspBody = (SPCmd_ArenaChallengeRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);
        

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    

    //fight
    FightScript script_hero;
    {
        //查询我方上阵阵型
        unsigned int team_pos_vec[4] = {0, 0, 0, 0};
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //查询对方阵型
        unsigned int comp_pos_vec[4] = {0, 0, 0, 0};
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , challenge->challenge_hero_id, challenge->challenge_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                    }
                    else
                    {
                        comp_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //查询双方排名
        unsigned int order_a =0;
        unsigned int order_b =0;
        query_both_two_order(main_hero_id, challenge->challenge_hero_id, order_a, order_b);

        //查询双方等级
        unsigned int hero_a_level = 0;
        {
            HeroInfo info;
            GetHeroBasicInfo(main_hero_id,info);
            hero_a_level = info.level;
        }
        unsigned int hero_b_level = 0;
        {
            HeroInfo info;
            GetHeroBasicInfo(challenge->challenge_hero_id,info);
            hero_b_level = info.level;
        }
        

        FirstBloodBoard fb = FBB_Random;
        if(order_a < order_b)
            fb = FBB_BoardA;
        else if(order_a > order_b)
            fb = FBB_BoardB;
        
        //生成战斗脚本
        {
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_TopHeroChallenge;
            f_sud.heroId = 0;
            f_sud.taskId = 0;
            f_sud.gridId = 0;
            f_sud.hero_a_level = hero_a_level;
            f_sud.hero_b_level = hero_b_level;
            FightScriptBuilder scriptBuild;
            f_sud.fightIndex = 1;

            FightScript script_comp;
        
            scriptBuild.genScript(team_pos_vec, comp_pos_vec
                , script_hero, script_comp
                , this
                , userData
                , fb
                , BATTLE_ROUND_LIMIT);
        }
    }

    

    //是否胜利
    if(script_hero.endResult.myResult == Result_Win)
    {
        //得积分
        {
            char sql[1024];
            sprintf(sql, "update hellgate.arena_hero_info set jifen=jifen+%u"
                " where hero_id=%u"
                , jifen_thisfight
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        //修改战胜状态
        {
            //
            std::vector<ArenaChlgerHeroInfo> hero_vec;
            bool has_record = false;
            {
                char sql[1024];
                sprintf(sql, "select  "
                    " chlger_hero_id_1, jifen_1, chlg_win_1, "
                    " chlger_hero_id_2, jifen_2, chlg_win_2, "
                    " chlger_hero_id_3, jifen_3, chlg_win_3, "
                    " chlger_hero_id_4, jifen_4, chlg_win_4, "
                    " chlger_hero_id_5, jifen_5, chlg_win_5, "
                    " chlger_hero_id_6, jifen_6, chlg_win_6 "
                    " from hellgate.arena_hero_chlg_list"
                    " where hero_id=%u"
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        has_record = true;

                        for(int i=1;i<=6; ++i)
                        {
                            char hero_id_str[32];
                            char jifen_str[32];
                            char chlg_win_str[32];
                            sprintf(hero_id_str, "chlger_hero_id_%u", i);
                            sprintf(jifen_str, "jifen_%u", i);
                            sprintf(chlg_win_str, "chlg_win_%u", i);

                            ArenaChlgerHeroInfo info;
                            info.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_id_str));
                            info.jifen = atoi(Mysql_Thread_Conn->GetField(jifen_str));
                            info.has_win = (bool)atoi(Mysql_Thread_Conn->GetField(chlg_win_str));

                            hero_vec.push_back(info);
                        }
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            //找到index
            int chlger_index = 0;
            for(; chlger_index<hero_vec.size(); ++chlger_index)
            {
                if(hero_vec[chlger_index].hero_info.hero_id == challenge->challenge_hero_id)
                {
                    break;
                }
            }
            if(chlger_index == hero_vec.size())
            {
                assert(false);
                return;
            }
            //修改战胜状态
            {
                char sql[1024];
                sprintf(sql, "update hellgate.arena_hero_chlg_list set  "
                    " chlg_win_%d=1 "
                    " where hero_id=%u"
                    , chlger_index+1
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
         //胜利，扣挑战次数 失败不扣
        {
            char sql[1024];
            sprintf(sql, "update hellgate.arena_hero_info set "
                " challenge_remainder_time=challenge_remainder_time-1 "
                " where hero_id=%u"
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

   

    //
    ArenaTeamBasicInfo team_info;
    getAndRefreshHeroArenaBasicInfo(main_hero_id, team_info);
    

    //
    int script_buf_len = 0;
    char* script_buf = 0;
    FightScriptBuilder scriptBuild;
    std::vector<FightScript> script_vec;
    script_vec.push_back(script_hero);
    script_buf = scriptBuild.FightScriptVec_2_CharArr(script_vec, script_buf_len);
    CMemGuard guard(script_buf);

    //

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ArenaChallengeRsp) 
            +script_buf_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = arenaChallengeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ArenaChallengeRsp* rspBody = (SPCmd_ArenaChallengeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    
    rspBody->jifen_after_fight = htonl(team_info.jifen);

    char* rspScript = (char*)((&rspBody->jifen_after_fight) + 1);

    //
    memcpy(rspScript, script_buf, script_buf_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithArenaMarketBuy(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithArenaMarketBuy", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ArenaMarketBuy* buy = (SPCmd_ArenaMarketBuy*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ArenaMarketBuy))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        buy->item_type = ntohl(buy->item_type);
        buy->item_count = ntohl(buy->item_count);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    unsigned int jifen_balance = 0;
    if(!checkAndBuyItemInArenaMarket(main_hero_id, buy->item_type, buy->item_count, jifen_balance))
    {
        //
        int rspDataLen = sizeof(SPCmd_ArenaMarketBuyRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = arenaMarketBuyRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ArenaMarketBuyRsp* rspBody = (SPCmd_ArenaMarketBuyRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        rspBody->jifen_balance = htonl(jifen_balance);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_ArenaMarketBuyRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = arenaMarketBuyRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ArenaMarketBuyRsp* rspBody = (SPCmd_ArenaMarketBuyRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->jifen_balance = htonl(jifen_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithArenaBuyChlgTime(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithArenaBuyChlgTime", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ArenaBuyChallengeTime* buy = (SPCmd_ArenaBuyChallengeTime*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ArenaBuyChallengeTime))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        buy->buy_time = ntohl(buy->buy_time);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    unsigned int chlg_remainder_time = 0;
    unsigned int buy_chlg_remainder_time = 0;
    unsigned int gold_balance = 0;
    if(!checkAndBuyChlgTime(main_hero_id, buy->buy_time
        , chlg_remainder_time, buy_chlg_remainder_time, gold_balance))
    {
        //
        int rspDataLen = sizeof(SPCmd_ArenaBuyChallengeTimeRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = arenaBuyChlgTimeRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ArenaBuyChallengeTimeRsp* rspBody = (SPCmd_ArenaBuyChallengeTimeRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_ArenaBuyChallengeTimeRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = arenaBuyChlgTimeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ArenaBuyChallengeTimeRsp* rspBody = (SPCmd_ArenaBuyChallengeTimeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->challenge_remainder_time = htonl(chlg_remainder_time);
    rspBody->buy_challenge_remainder_time = htonl(buy_chlg_remainder_time);
    rspBody->gold_balance = htonl(gold_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithRefreshZahuopu(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithRefreshZahuopu", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_RefreshZahuopu* refresh = (SPCmd_RefreshZahuopu*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_RefreshZahuopu))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        refresh = refresh;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    unsigned int silver_balance = 0;
    unsigned int silver_need_for_manual_refresh = 0;
    unsigned int draw_need_coupons = 0;
    std::vector<ZahuopuItem> item_vec;
    if(!checkAndRefreshZahuopu(main_hero_id
        , item_vec, silver_balance, silver_need_for_manual_refresh, draw_need_coupons))
    {
        //
        int rspDataLen = sizeof(SPCmd_RefreshZahuopuRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = refreshZahuopuRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_RefreshZahuopuRsp* rspBody = (SPCmd_RefreshZahuopuRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    unsigned int coupons_balance= getItemCountInTeam(main_hero_id, ItemsType_DaiGouJuan);
    
    //
    int rspDataLen = sizeof(SPCmd_RefreshZahuopuRsp)+sizeof(ZahuopuItem)*item_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = refreshZahuopuRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_RefreshZahuopuRsp* rspBody = (SPCmd_RefreshZahuopuRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->silver_balance = htonl(silver_balance);
    rspBody->silver_need_for_refresh = htonl(silver_need_for_manual_refresh);
    rspBody->draw_need_coupons = htonl(draw_need_coupons);
    rspBody->coupons_balance = htonl(coupons_balance);

    if(item_vec.size() != 6)
    {
        LogMsg("%s, line %d,zahuopu item_vec.size(0=%d", __FILE__, __LINE__, item_vec.size());
        assert(false);
        
        return;
    }
    
    for(int i=0; i<item_vec.size(); ++i)
    {
        rspBody->item_arr[i].item_type = htonl(item_vec[i].item_type);
        rspBody->item_arr[i].suipian_id = htonl(item_vec[i].suipian_id);
        rspBody->item_arr[i].count = htonl(item_vec[i].count );
        rspBody->item_arr[i].already_got = item_vec[i].already_got;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}

void ProcServerThread::DealwithQueryZahuopu(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryZahuopu", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryZahuopu* query = (SPCmd_QueryZahuopu*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryZahuopu))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    unsigned int silver_need_for_manual_refresh = 0;
    unsigned int draw_need_coupons = 0;
    std::vector<ZahuopuItem> item_vec;
    unsigned int refresh_timestamp = 0;
    unsigned int already_get_item_count = 0;
    bool has_record = false;
    {
        char sql[1024];
        sprintf(sql, "select  "
            " already_get_item_count, refresh_timestamp, next_manual_refresh_need_silver, "
            " draw_need_coupons, "
            " item_type_1, suipian_id_1, count_1,  get_order_1, "
            " item_type_2, suipian_id_2, count_2,  get_order_2, "
            " item_type_3, suipian_id_3, count_3,  get_order_3, "
            " item_type_4, suipian_id_4, count_4,  get_order_4, "
            " item_type_5, suipian_id_5, count_5,  get_order_5, "
            " item_type_6, suipian_id_6, count_6,  get_order_6 "
            " from hellgate.zahuopu"
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_record = true;

                already_get_item_count = atoi(Mysql_Thread_Conn->GetField("already_get_item_count"));
                refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                silver_need_for_manual_refresh = atoi(Mysql_Thread_Conn->GetField("next_manual_refresh_need_silver"));
                draw_need_coupons = atoi(Mysql_Thread_Conn->GetField("draw_need_coupons"));

                for(int i=1;i<=6; ++i)
                {
                    char item_type_str[32];
                    char suipian_id_str[32];
                    char count_str[32];
                    char order_str[32];
                    sprintf(item_type_str, "item_type_%u", i);
                    sprintf(suipian_id_str, "suipian_id_%u", i);
                    sprintf(count_str, "count_%u", i);
                    sprintf(order_str, "get_order_%u", i);

                    ZahuopuItem item;
                    item.item_type = atoi(Mysql_Thread_Conn->GetField(item_type_str));
                    item.suipian_id = atoi(Mysql_Thread_Conn->GetField(suipian_id_str));
                    item.count = atoi(Mysql_Thread_Conn->GetField(count_str));
                    unsigned int order = atoi(Mysql_Thread_Conn->GetField(order_str));
                    if(order <= already_get_item_count)
                    {
                        item.already_got = true;
                    }
                    else
                    {
                        item.already_got = false;
                    }
                    

                    item_vec.push_back(item);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
    }
    //如果还没有记录则创建
    if(!has_record)
    {
        //stub 暂时固定1000银币
        silver_need_for_manual_refresh = 1000;
        //stub 暂时固定5个代购券
        draw_need_coupons = 5;

        //
        item_vec.clear();
        std::vector<unsigned int> order_vec;
        getRandom6ZahuopuItem(item_vec, order_vec);

        //
        char sql[1024];
        sprintf(sql, "insert into hellgate.zahuopu "
            " set hero_id=%u, refresh_timestamp=%u, next_manual_refresh_need_silver=%u, "
            " draw_need_coupons=%u, already_get_item_count=0, "
            " item_type_1=%u, suipian_id_1=%u, count_1=%u, get_order_1=%u, "
            " item_type_2=%u, suipian_id_2=%u, count_2=%u, get_order_2=%u, "
            " item_type_3=%u, suipian_id_3=%u, count_3=%u, get_order_3=%u, "
            " item_type_4=%u, suipian_id_4=%u, count_4=%u, get_order_4=%u, "
            " item_type_5=%u, suipian_id_5=%u, count_5=%u, get_order_5=%u, "
            " item_type_6=%u, suipian_id_6=%u, count_6=%u, get_order_6=%u"
            , main_hero_id, (unsigned int)time(0), silver_need_for_manual_refresh, draw_need_coupons
            , item_vec[0].item_type, item_vec[0].suipian_id, item_vec[0].count, order_vec[0]
            , item_vec[1].item_type, item_vec[1].suipian_id, item_vec[1].count, order_vec[1]
            , item_vec[2].item_type, item_vec[2].suipian_id, item_vec[2].count, order_vec[2]
            , item_vec[3].item_type, item_vec[3].suipian_id, item_vec[3].count, order_vec[3]
            , item_vec[4].item_type, item_vec[4].suipian_id, item_vec[4].count, order_vec[4]
            , item_vec[5].item_type, item_vec[5].suipian_id, item_vec[5].count, order_vec[5]);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
        
    }
    else
    {
        bool need_refresh = isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour);
        if(!need_refresh)
        {
            //检查是否所有物品都抽完了

            if(already_get_item_count == 6)
            {
                need_refresh = true;
            }
        }
        if(need_refresh)
        {
            //stub
            silver_need_for_manual_refresh = 1000;
            
            
            {
                item_vec.clear();
                std::vector<unsigned int> order_vec;
                getRandom6ZahuopuItem(item_vec, order_vec);

                //
                char sql[1024];
                sprintf(sql, "update hellgate.zahuopu "
                    " set refresh_timestamp=%u, next_manual_refresh_need_silver=%u, "
                    " draw_need_coupons=%u, already_get_item_count=0, "
                    " item_type_1=%u, suipian_id_1=%u, count_1=%u, get_order_1=%u, "
                    " item_type_2=%u, suipian_id_2=%u, count_2=%u, get_order_2=%u, "
                    " item_type_3=%u, suipian_id_3=%u, count_3=%u, get_order_3=%u, "
                    " item_type_4=%u, suipian_id_4=%u, count_4=%u, get_order_4=%u, "
                    " item_type_5=%u, suipian_id_5=%u, count_5=%u, get_order_5=%u, "
                    " item_type_6=%u, suipian_id_6=%u, count_6=%u, get_order_6=%u"
                    " where hero_id=%u"
                    , (unsigned int)time(0), silver_need_for_manual_refresh, draw_need_coupons
                    , item_vec[0].item_type, item_vec[0].suipian_id, item_vec[0].count, order_vec[0]
                    , item_vec[1].item_type, item_vec[1].suipian_id, item_vec[1].count, order_vec[1]
                    , item_vec[2].item_type, item_vec[2].suipian_id, item_vec[2].count, order_vec[2]
                    , item_vec[3].item_type, item_vec[3].suipian_id, item_vec[3].count, order_vec[3]
                    , item_vec[4].item_type, item_vec[4].suipian_id, item_vec[4].count, order_vec[4]
                    , item_vec[5].item_type, item_vec[5].suipian_id, item_vec[5].count, order_vec[5]
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
    }
    
    unsigned int coupons_balance = getItemCountInTeam(main_hero_id, ItemsType_DaiGouJuan);
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryZahuopuRsp)+sizeof(ZahuopuItem)*item_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryZahuopuRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryZahuopuRsp* rspBody = (SPCmd_QueryZahuopuRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->silver_need_for_refresh = htonl(silver_need_for_manual_refresh);
    rspBody->draw_need_coupons = htonl(draw_need_coupons);
    rspBody->coupons_balance = htonl(coupons_balance);

    if(item_vec.size() != 6)
    {
        LogMsg("%s, line %d,zahuopu item_vec.size(0=%d", __FILE__, __LINE__, item_vec.size());
        assert(false);
        
        return;
    }
    
    for(int i=0; i<item_vec.size(); ++i)
    {
        rspBody->item_arr[i].item_type = htonl(item_vec[i].item_type);
        rspBody->item_arr[i].suipian_id = htonl(item_vec[i].suipian_id);
        rspBody->item_arr[i].count = htonl(item_vec[i].count );
        rspBody->item_arr[i].already_got = item_vec[i].already_got;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}

void ProcServerThread::DealwithZahuopuGetOneItem(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithZahuopuGetOneItem", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ZahuopuGetOneItem* get = (SPCmd_ZahuopuGetOneItem*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ZahuopuGetOneItem))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //判断合法性并查询出本次战斗可能得到的积分
    ZahuopuItem item_zahuopu;
    unsigned int item_list_index = 0;
    unsigned int gold_balance = 0;
    unsigned int coupons_balance = 0;
    if(!checkAndZahuopuGetOneItem(main_hero_id,item_zahuopu, item_list_index, gold_balance, coupons_balance))
    {
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ZahuopuGetOneItemRsp);
        
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = zahuopuGetOneItemRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ZahuopuGetOneItemRsp* rspBody = (SPCmd_ZahuopuGetOneItemRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);
        

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ZahuopuGetOneItemRsp);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = zahuopuGetOneItemRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ZahuopuGetOneItemRsp* rspBody = (SPCmd_ZahuopuGetOneItemRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->get_index = htonl(item_list_index);
    rspBody->gold_balance = htonl(gold_balance);
    rspBody->coupons_balance = htonl(coupons_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithTeamBossEnter(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithTeamBossEnter", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TeamBossEnter* enter = (SPCmd_TeamBossEnter*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TeamBossEnter))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询体力
    bool vit_enought = false;
    
    {
        int vit_current = 0;
        
        char sql[1024];
        sprintf(sql, "select vit_current from hellgate.hero_infor where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);

            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                vit_current = atoi(Mysql_Thread_Conn->GetField("vit_current"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        if(vit_current >= TeamBossVittalityNeed)
        {
            vit_enought = true;
        }
    }
    if(!vit_enought)
    {
        //
        int rspDataLen = sizeof(SPCmd_TeamBossEnterRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = teamBossEnterRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_TeamBossEnterRsp* rspBody = (SPCmd_TeamBossEnterRsp*)((rspHead)+1);
        rspBody->err_code = htonl(TiliNotEnought);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    HeroInfo main_hero_info;
    GetHeroBasicInfo(main_hero_id, main_hero_info);

    std::vector<TeamBossHero> partner_vec;
    //进入团队boss数据结构
    bool isReEnter = false;
    pthread_mutex_lock(&m_teamBossHall.mutex);
    {
        //根据level找到相应的房间 
        TeamBossRoom* room = getTeamBossRoom(main_hero_info.level, enter->hardLevel);

        //检查自己是否已经在房间中。这种情况可能是客户端重连或占位机器人造成
        std::vector<TeamBossHero>::iterator pos = room->hero_vec.begin();
        for(; pos!=room->hero_vec.end(); ++pos)
        {
            if(pos->hero_id == main_hero_id)
            {
                isReEnter= true;
                
                //把自己删除
                room->hero_vec.erase(pos);
                break;
            }
        }

        //
        partner_vec = room->hero_vec;
        

        assert(room->hero_vec.size() <= TEAMBOSS_ROOM_HERO_COUNT-1);
        
        if(room->hero_vec.size() < TEAMBOSS_ROOM_HERO_COUNT-1)
        {
            if(room->hero_vec.size() == 0)
            {
                //我是第一个进房间的
                room->create_time = time(0);
            }
            
            //把自己放入房间 
            TeamBossHero teamboss_hero;
            teamboss_hero.hero_id = main_hero_id;
            teamboss_hero.type = TeamBossHeroType_OnlinePlayer;
            
            room->hero_vec.push_back(teamboss_hero);
        }
        else
        {
            //房间已经满了，清空 
            room->hero_vec.clear();
            room->create_time = 0;
        }
    }
    pthread_mutex_unlock(&m_teamBossHall.mutex);

    //先给所有前面进入的玩家发送update
    if(!isReEnter)
    {
        //给所有在线partner发update
        for(int i=0; i<partner_vec.size(); ++i)
        {
            if(partner_vec[i].type == TeamBossHeroType_OnlinePlayer)
            {
                sendTeamBossUpdateRoomRsp(partner_vec[i].hero_id, main_hero_id);
            }
        }
    }
    //然后给自己回复
    sendTeamBossEnterRsp(pack->client_id, main_hero_id, pack->fd_account, partner_vec);

    //如果房间满了，则开打
    if(partner_vec.size() == TEAMBOSS_ROOM_HERO_COUNT-1)
    {
        //生成并发送竞技结果
        TeamBossHero teamboss_hero;
        teamboss_hero.hero_id = main_hero_id;
        teamboss_hero.type = TeamBossHeroType_OnlinePlayer;
        partner_vec.push_back(teamboss_hero);
        
        sendTeamBossBattleAndGiftRsp(main_hero_info.level, enter->hardLevel, partner_vec);
    }

    return;
}

void ProcServerThread::DealwithTeamBossGetGift(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithTeamBossGetGift", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TeamBossGetGift* get = (SPCmd_TeamBossGetGift*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TeamBossGetGift))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->gift_id = ntohl(get->gift_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //消耗体力
    bool vit_enought = subVitality(main_hero_id, TeamBossVittalityNeed);
    if(!vit_enought)
    {
        //
        int rspDataLen = sizeof(SPCmd_TeamBossGetGiftRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = teamBossGetGiftRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_TeamBossGetGiftRsp* rspBody = (SPCmd_TeamBossGetGiftRsp*)((rspHead)+1);
        rspBody->err_code = htonl(TiliNotEnought);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //
    bool err_code = Error;
    {
        GiftData gift;
        if(!getTeamBossGiftBox(main_hero_id, get->gift_id,gift))
        {
            LogMsg("%s, line %d,getGiftBox failed. hero_id[%u], gift_id[%u]"
                , __FILE__, __LINE__, main_hero_id, get->gift_id);
        }
        else if(gift.type != GiftType_Item)
        {
            LogMsg("%s, line %d,gift type[%u] not support"
                , __FILE__, __LINE__, (int)(gift.type));
        }
        else
        {
            ObtainItem(main_hero_id, gift.data_union.item.type, gift.data_union.item.count);

            err_code = Success;
        }
        
    }

    //
    //
    int rspDataLen = sizeof(SPCmd_TeamBossGetGiftRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = teamBossGetGiftRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TeamBossGetGiftRsp* rspBody = (SPCmd_TeamBossGetGiftRsp*)((rspHead)+1);
    rspBody->err_code = htonl(err_code);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithCityGuardEnter(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCityGuardEnter", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CityGuardEnter* enter = (SPCmd_CityGuardEnter*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CityGuardEnter))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        enter = enter;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //初始化
    unsigned int last_total_turns;
    unsigned int last_total_silver;
    unsigned int sucess_turn;
    unsigned int current_silver;
    if(heroEnterCityGuard(main_hero_id, last_total_turns, last_total_silver
        , sucess_turn, current_silver) != 0)
    {
        //
        int rspDataLen = sizeof(SPCmd_CityGuardEnterRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = cityGuardEnterRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_CityGuardEnterRsp* rspBody = (SPCmd_CityGuardEnterRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    

    //
    //
    int rspDataLen = sizeof(SPCmd_CityGuardEnterRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = cityGuardEnterRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CityGuardEnterRsp* rspBody = (SPCmd_CityGuardEnterRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->sucess_turn = htonl(sucess_turn);
    rspBody->current_silver = htonl(current_silver);
    rspBody->last_total_turns = htonl(last_total_turns);
    rspBody->last_silver = htonl(last_total_silver);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithCityGuardGetNextMonster(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCityGuardGetNextMonster", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CityGuardGetNextMonster* get = (SPCmd_CityGuardGetNextMonster*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CityGuardGetNextMonster))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    unsigned int last_total_turns = 0;
    unsigned int last_total_silver = 0;
    unsigned int sucess_turn = 0;
    unsigned int current_silver = 0;
    unsigned int next_monster_team_id = 0;
    unsigned int next_turn_silver = 0;
    {
        char sql[1024];
        sprintf(sql, "select last_total_turns, last_total_silver, sucess_turn, current_silver "
            " , next_monster_team_id, next_turn_silver"
            " from hellgate.cityguard_hero_info where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                last_total_turns = atoi(Mysql_Thread_Conn->GetField("last_total_turns"));
                last_total_silver = atoi(Mysql_Thread_Conn->GetField("last_total_silver"));
                sucess_turn = atoi(Mysql_Thread_Conn->GetField("sucess_turn"));
                current_silver = atoi(Mysql_Thread_Conn->GetField("current_silver"));
                next_monster_team_id = atoi(Mysql_Thread_Conn->GetField("next_monster_team_id"));
                next_turn_silver = atoi(Mysql_Thread_Conn->GetField("next_turn_silver"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    if(next_monster_team_id == 0)
    {
        LogMsg("%s, line %d, hero_id[%u], no cityguard data"
                    , __FILE__, __LINE__, main_hero_id);

        //
        int rspDataLen = sizeof(SPCmd_CityGuardGetNextMonsterRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = cityGuardGetNextMonsterRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_CityGuardGetNextMonsterRsp* rspBody = (SPCmd_CityGuardGetNextMonsterRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    if(next_turn_silver == 0)
    {
        assert(false);
    }

    
    //获取leader信息
    unsigned int monster_leader_prof = 0;
    {
        unsigned int leader_id = 0;
        {
            char sql[1024];
            sprintf(sql, "select team_leader_index, monster_id_1, monster_id_2, monster_id_3, monster_id_4"
                " from hellgate.cityguard_monster_team where monster_team_id=%u"
                , next_monster_team_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    unsigned int team_leader_index = atoi(Mysql_Thread_Conn->GetField("team_leader_index"));
                    unsigned int monster_id_1 = atoi(Mysql_Thread_Conn->GetField("monster_id_1"));
                    unsigned int monster_id_2 = atoi(Mysql_Thread_Conn->GetField("monster_id_2"));
                    unsigned int monster_id_3 = atoi(Mysql_Thread_Conn->GetField("monster_id_3"));
                    unsigned int monster_id_4 = atoi(Mysql_Thread_Conn->GetField("monster_id_4"));

                    switch(team_leader_index)
                    {
                        case 1:
                            leader_id = monster_id_1;
                            break;
                        case 2:
                            leader_id = monster_id_2;
                            break;
                        case 3:
                            leader_id = monster_id_3;
                            break;
                        case 4:
                            leader_id = monster_id_4;
                            break;
                        default:
                            LogMsg("%s, line %d, mysql team_leader_index. [%u]"
                            , __FILE__, __LINE__, team_leader_index);
                            assert(false);
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        GuaiWuData data;
        unsigned int skill_type;
        GetMonsterDetail(leader_id, data, skill_type);
        monster_leader_prof = (unsigned int)data.profession;
    }
    
    //
    int rspDataLen = sizeof(SPCmd_CityGuardGetNextMonsterRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = cityGuardGetNextMonsterRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CityGuardGetNextMonsterRsp* rspBody = (SPCmd_CityGuardGetNextMonsterRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->monster_leader_profession = htonl(monster_leader_prof);
    rspBody->silver = htonl(next_turn_silver);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithCityGuardFight(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCityGuardFight", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CityGuardFight* fight = (SPCmd_CityGuardFight*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CityGuardFight))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    unsigned int cur_silver = 0;
    unsigned int next_silver = 0;
    getCityGuardCurrentSilverAndNextSilver(main_hero_id,cur_silver,next_silver);

    //判断是放弃还是迎战
    int total_get_silver = 0;
    char* script_buf = 0;
    int script_buf_len = 0;
    if(fight->fight)
    {
        
        //查询我方上阵阵型
        unsigned int team_pos_vec[4] = {0, 0, 0, 0};
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //查询怪物阵型
        unsigned int monster_pos_vec[4] = {0, 0, 0, 0};
        {
            unsigned int next_monster_team_id = 0;
            {
                char sql[1024];
                sprintf(sql, "select next_monster_team_id "
                    " from hellgate.cityguard_hero_info where hero_id=%u"
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        next_monster_team_id = atoi(Mysql_Thread_Conn->GetField("next_monster_team_id"));
                    }
                    else
                    {
                        LogMsg("%s, line %d, error."
                            , __FILE__, __LINE__);
                        return;
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
            {
                char sql[1024];
                sprintf(sql, "select monster_id_1, monster_id_2, monster_id_3, monster_id_4 "
                    " from hellgate.cityguard_monster_team where monster_team_id=%u"
                    , next_monster_team_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        monster_pos_vec[0] = atoi(Mysql_Thread_Conn->GetField("monster_id_1"));
                        monster_pos_vec[1] = atoi(Mysql_Thread_Conn->GetField("monster_id_2"));
                        monster_pos_vec[2] = atoi(Mysql_Thread_Conn->GetField("monster_id_3"));
                        monster_pos_vec[3] = atoi(Mysql_Thread_Conn->GetField("monster_id_4"));
                    }
                    else
                    {
                        LogMsg("%s, line %d, error."
                            , __FILE__, __LINE__);
                        return;
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
        
        
        //生成战斗脚本
        {
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_CityGuard;
            f_sud.heroId = 0;
            f_sud.taskId = 0;
            f_sud.gridId = 0;
            FightScriptBuilder scriptBuild;
            f_sud.fightIndex = 1;

            FightScript script_hero;
            FightScript script_monster;
        
            scriptBuild.genScript(team_pos_vec, monster_pos_vec
                , script_hero, script_monster
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);

            if(script_hero.endResult.myResult == Result_Win)
            {
                setNextTurnCityGuardMonsterTeamAndSilver(main_hero_id);

                total_get_silver = cur_silver + next_silver;
            }
            else
            {
                clearCityGuardMonsterTeamAndSilver(main_hero_id, false);

                //
                total_get_silver = cur_silver - next_silver;
                if(total_get_silver < 0)
                {
                    total_get_silver = 0;
                }
            }

            //
            std::vector<FightScript> script_vec;
            script_vec.push_back(script_hero);
            script_buf = scriptBuild.FightScriptVec_2_CharArr(script_vec, script_buf_len);
        }
    }
    else
    {
        char sql[1024];
        sprintf(sql, "select current_silver "
            " from hellgate.cityguard_hero_info where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                total_get_silver = atoi(Mysql_Thread_Conn->GetField("current_silver"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //
        clearCityGuardMonsterTeamAndSilver(main_hero_id, true);
    }

    
    
    //
    int rspDataLen;
    if(fight->fight)
    {
        rspDataLen = sizeof(SPCmd_CityGuardFightRsp) + script_buf_len;
    }
    else
    {
        rspDataLen = sizeof(SPCmd_CityGuardFightRsp);
    }
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = cityGuardFightRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CityGuardFightRsp* rspBody = (SPCmd_CityGuardFightRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->silver = htonl(total_get_silver);
    rspBody->isFighting = (fight->fight);

    if(fight->fight)
    {
        memcpy(rspBody->fightScript, script_buf, script_buf_len);
        delete script_buf;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithTopHeroGetList(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithTopHeroGetList", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopHeroGetList* get = (SPCmd_TopHeroGetList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopHeroGetList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;
        
    unsigned int hero_order = 0, next_chlg_time = 0;
    std::vector<HeroAndOrder> order_vec;
    std::vector<TopHeroReport> report_vec;
    bool result_flag = query_top_hero_list(main_hero_id, hero_order, next_chlg_time, order_vec, report_vec);
    
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_TopHeroGetListRsp) + sizeof(HeroAndOrder)*(order_vec.size()-10)
        + sizeof(TopHeroReport)*(report_vec.size());
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topHeroGetListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopHeroGetListRsp* rspBody = (SPCmd_TopHeroGetListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    
    rspBody->my_order = htonl(hero_order);
    rspBody->next_chlg_time = htonl(next_chlg_time);
    rspBody->hero_count = htonl(order_vec.size()-10);
    rspBody->report_count = htonl(report_vec.size());
    
    for(int i=0; i<10; ++i)
    {
        hton_hero_info(order_vec[i].hero_info, rspBody->top10_hero[i].hero_info);
        rspBody->top10_hero[i].order = htonl(order_vec[i].order);
        rspBody->top10_hero[i].zhandouli = htonl(order_vec[i].zhandouli);
    }

    HeroAndOrder *p_o = (HeroAndOrder*)rspBody->data;
    for(int i=10; i<order_vec.size(); i++, p_o++)
    {
        hton_hero_info(order_vec[i].hero_info, p_o->hero_info);
        p_o->order = htonl(order_vec[i].order);
        p_o->zhandouli = htonl(order_vec[i].zhandouli);
    }

    

    TopHeroReport *p = (TopHeroReport*)p_o;
    for(int i=0; i<report_vec.size(); i++, p++)
    {
        hton_hero_info(report_vec[i].challenger.hero_info, p->challenger.hero_info);
        p->challenger.order = htonl(report_vec[i].challenger.order);
        p->challenger.zhandouli = htonl(report_vec[i].challenger.zhandouli);
        
        hton_hero_info(report_vec[i].be_challenger.hero_info, p->be_challenger.hero_info);
        p->be_challenger.order = htonl(report_vec[i].be_challenger.order);
        p->be_challenger.zhandouli = htonl(report_vec[i].be_challenger.zhandouli);

        p->other_order = htonl(report_vec[i].other_order);
        p->challenger_win = htonl(report_vec[i].challenger_win);
        p->fight_time = htonl(report_vec[i].fight_time);
    }
    
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithTopHeroChallenge(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithTopHeroChallenge", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopHeroChallenge* challenge = (SPCmd_TopHeroChallenge*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopHeroChallenge))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        challenge->hero_id = ntohl(challenge->hero_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int order_after_fight, next_chlg_time;
    int script_len = 0;
    char *fight_script = NULL;
    bool result_flag = check_and_challenge_top_hero(main_hero_id, challenge->hero_id,
        order_after_fight, next_chlg_time, &fight_script, script_len);
    

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_TopHeroChallengeRsp) + script_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topHeroChallengeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopHeroChallengeRsp* rspBody = (SPCmd_TopHeroChallengeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag? Success : Error);

    
    rspBody->order_after_fight = htonl(order_after_fight);
    rspBody->next_chlg_time = htonl(next_chlg_time);

    /*
    rspBody->hero_count = htonl(other_hero_vec.size());
    for(int i=0; i<other_hero_vec.size(); ++i)
    {
        rspBody->hero_arr[i].hero_info.hero_id = htonl(other_hero_vec[i].hero_info.hero_id);
        rspBody->hero_arr[i].hero_info.profession_id = htonl(other_hero_vec[i].hero_info.profession_id);
        rspBody->hero_arr[i].hero_info.level = htonl(other_hero_vec[i].hero_info.level);
        strncpy(rspBody->hero_arr[i].hero_info.name, other_hero_vec[i].hero_info.name, HeroNameMaxLen);
        rspBody->hero_arr[i].hero_info.name[HeroNameMaxLen] = 0;
    }

    char* rspScript = (char*)(rspBody->order_after_fight + other_hero_vec.size());
    */
    
    memcpy(rspBody->fightScript, fight_script, script_len);
    delete fight_script;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithTopHeroClearCDTime(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithTopHeroClearCDTime", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopHeroClearCDTime* clr = (SPCmd_TopHeroClearCDTime*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopHeroClearCDTime))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        clr = clr;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int gold_balance, next_chlg_time;
    bool result_flag = clear_top_hero_cd_time(main_hero_id, gold_balance, next_chlg_time);
    

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_TopHeroClearCDTimeRsp);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topHeroClearCDTimeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopHeroClearCDTimeRsp* rspBody = (SPCmd_TopHeroClearCDTimeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag? Success : Error);
    
    rspBody->gold_balance = htonl(gold_balance);
    rspBody->next_chlg_time = htonl(next_chlg_time);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithTopArenaQueryStatus(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithTopArenaQueryStatus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopArenaQueryStatus* enter = (SPCmd_TopArenaQueryStatus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopArenaQueryStatus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        enter = enter;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    unsigned int round = TopArenaRoundType_NUL;
    unsigned int next_top_arena_time = 0;
    TopArenaInfo player_arr_8_4[4];  	//8进4选手
	TopArenaInfo player_arr_4_2[2];  	//4进2选手
	TopArenaInfo player_arr_2_1[1];  	//2进1选手
	TopArenaStat stat[3];
	
    pthread_mutex_lock(&m_toparena.mutex);
    {
        round = m_toparena.round;
        next_top_arena_time = m_toparena.next_top_arena_time;

        for(int i=0; i<3; i++) {
            stat[i] = m_toparena.stat[i];
        }

        for(int i=0; i<4; i++) {
            player_arr_8_4[i] = m_toparena.player_arr_8_4[i];
        }

        for(int i=0; i<2; i++) {
            player_arr_4_2[i] = m_toparena.player_arr_4_2[i];
        }

        for(int i=0; i<1; ++i)
        {
            player_arr_2_1[i] = m_toparena.player_arr_2_1[i];
        }
    }
    pthread_mutex_unlock(&m_toparena.mutex);

    //查询玩家竞猜情况
    TopArenaGuessInfo guess_info_arr[3];
    for(int i=0; i<3; i++) {
        guess_info_arr[i].is_joined = false;
    }
    
    if(stat[0] != TopArenaStat_Invalide){//查询8-4玩家竞猜情况
        char sql[1024];
        sprintf(sql, "select guess_game, guess_result, wager "
            " from hellgate.top_arena_guess_8_4 "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            TopArenaGuessInfo info;
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                int guess_game = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                int a_lost = atoi(Mysql_Thread_Conn->GetField("guess_result"));
                int wager = atoi(Mysql_Thread_Conn->GetField("wager"));
                
                guess_info_arr[0].is_joined = true;
                guess_info_arr[0].player = player_arr_8_4[guess_game -1];
                guess_info_arr[0].guess_winer = a_lost;
                guess_info_arr[0].wager = wager;

                if(stat[0] != TopArenaStat_Finished )
                    guess_info_arr[0].result = 0;
                else {
                    if((bool)a_lost == (!player_arr_8_4[guess_game -1].winer))
                        guess_info_arr[0].result = 1;
                    else
                        guess_info_arr[0].result = 2;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(stat[1] != TopArenaStat_Invalide){//查询4-2玩家竞猜情况
        char sql[1024];
        sprintf(sql, "select guess_game, guess_result, wager "
            " from hellgate.top_arena_guess_4_2 "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            TopArenaGuessInfo info;
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                int guess_game = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                int a_lost = atoi(Mysql_Thread_Conn->GetField("guess_result"));
                int wager = atoi(Mysql_Thread_Conn->GetField("wager"));
                
                guess_info_arr[1].is_joined = true;
                guess_info_arr[1].player = player_arr_4_2[guess_game -1];
                guess_info_arr[1].guess_winer = a_lost;
                guess_info_arr[1].wager = wager;

                if(stat[1] != TopArenaStat_Finished )
                    guess_info_arr[1].result = 0;
                else {
                    if((bool)a_lost == (!player_arr_4_2[guess_game -1].winer))
                        guess_info_arr[1].result = 1;
                    else
                        guess_info_arr[1].result = 2;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(stat[2] != TopArenaStat_Invalide){//查询2-1玩家竞猜情况
        char sql[1024];
        sprintf(sql, "select guess_game, guess_result, wager "
            " from hellgate.top_arena_guess_2_1 "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            TopArenaGuessInfo info;
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                int guess_game = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                int a_lost = atoi(Mysql_Thread_Conn->GetField("guess_result"));
                int wager = atoi(Mysql_Thread_Conn->GetField("wager"));
                
                guess_info_arr[2].is_joined = true;
                guess_info_arr[2].player = player_arr_2_1[guess_game -1];
                guess_info_arr[2].guess_winer = a_lost;
                guess_info_arr[2].wager = wager;

                if(stat[2] != TopArenaStat_Finished )
                    guess_info_arr[2].result = 0;
                else {
                    if((bool)a_lost == (!player_arr_2_1[guess_game -1].winer))
                        guess_info_arr[2].result = 1;
                    else
                        guess_info_arr[2].result = 2;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    //
    int rspDataLen = sizeof(SPCmd_TopArenaQueryStatusRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topArenaQueryStatusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopArenaQueryStatusRsp* rspBody = (SPCmd_TopArenaQueryStatusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //rspBody->round = htonl(round);
    rspBody->next_top_arena_time = htonl(next_top_arena_time);

    for(int i=0; i<3; ++i)
    {
        rspBody->stat[i] = htonl(stat[i]);
        
        rspBody->guess[i].is_joined = guess_info_arr[i].is_joined;
        hton_top_arena_info(guess_info_arr[i].player, rspBody->guess[i].player);

        rspBody->guess[i].guess_winer = htons(guess_info_arr[i].guess_winer);
        rspBody->guess[i].result = htons(guess_info_arr[i].result);
        rspBody->guess[i].wager = htonl(guess_info_arr[i].wager);
    }
    
    if(stat[0] != TopArenaStat_Invalide) {
        for(int i=0; i<4; i++) {
            hton_top_arena_info(player_arr_8_4[i], rspBody->player_arr_8_4[i]);
        }
    }
    if(stat[1] != TopArenaStat_Invalide) {
        for(int i=0; i<2; i++) {
            hton_top_arena_info(player_arr_4_2[i], rspBody->player_arr_4_2[i]);
        }
    }
    if(stat[2] != TopArenaStat_Invalide) {
        for(int i=0; i<1; i++) {
            hton_top_arena_info(player_arr_2_1[i], rspBody->player_arr_2_1[i]);
        }
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}


void ProcServerThread::DealwithTopArenaGuess(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithTopArenaGuess", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopArenaGuess* guess = (SPCmd_TopArenaGuess*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopArenaGuess))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        guess->round = ntohs(guess->round);
        guess->group = ntohs(guess->group);
        guess->wager = ntohl(guess->wager);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int silver_balance = 0;
    bool result_flag = check_and_guess_top_arena(main_hero_id, guess->round, guess->group, 
        guess->guess_winer, guess->wager, silver_balance);


    int rspDataLen = sizeof(SPCmd_TopArenaGuessRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topArenaGuessRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopArenaGuessRsp* rspBody = (SPCmd_TopArenaGuessRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->silver_balance = htonl(silver_balance);


    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithTopArenaReplay(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithTopArenaReplay", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopArenaReplay* watch = (SPCmd_TopArenaReplay*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopArenaReplay))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        watch->round = ntohs(watch->round);
        watch->group = ntohs(watch->group);
        watch->times = ntohs(watch->times);
    }
    
    if(watch->times > 2) {
        LogMsg("%s, line %d, replay times[%d] error", __FILE__, __LINE__, watch->times +1);
        return;
    }

    if(watch->round == TopArenaRoundType_8_4) {
        if(watch->group  > 3){
            LogMsg("%s, line %d, replay group[%d] error", __FILE__, __LINE__, watch->group +1);
            return;
        }
    }
    else if(watch->round == TopArenaRoundType_4_2) {
        if(watch->group  > 1){
            LogMsg("%s, line %d, replay group[%d] error", __FILE__, __LINE__, watch->group +1);
            return;
        }
    }
    else if(watch->round == TopArenaRoundType_2_1) {
        if(watch->group  > 0){
            LogMsg("%s, line %d, replay group[%d] error", __FILE__, __LINE__, watch->group +1);
            return;
        }
    }
    else {
        LogMsg("%s, line %d, replay round[%d] error", __FILE__, __LINE__, watch->round);
        return;
    }
    

    //unsigned int main_hero_id = pack->main_hero_id;

    int script_len = 0;
    char* script_p = NULL;
    pthread_mutex_lock(&m_toparena.mutex);
    {
        if(watch->round == TopArenaRoundType_8_4) {
            if(m_toparena.stat[0] == TopArenaStat_Finished) {
                script_len = m_toparena.script_arr_8_4[watch->group].len[watch->times];
                script_p = new char[script_len];
                memcpy(script_p, m_toparena.script_arr_8_4[watch->group].script[watch->times], script_len);
            }
        }
        else if(watch->round == TopArenaRoundType_4_2) {
            if(m_toparena.stat[1] == TopArenaStat_Finished) {
                script_len = m_toparena.script_arr_4_2[watch->group].len[watch->times];
                script_p = new char[script_len];
                memcpy(script_p, m_toparena.script_arr_4_2[watch->group].script[watch->times], script_len);
            }
        }
        else if(watch->round == TopArenaRoundType_2_1) {
            if(m_toparena.stat[2] == TopArenaStat_Finished) {
                script_len = m_toparena.script_arr_2_1[watch->group].len[watch->times];
                script_p = new char[script_len];
                memcpy(script_p, m_toparena.script_arr_2_1[watch->group].script[watch->times], script_len);
            }
        }
    }
    pthread_mutex_unlock(&m_toparena.mutex);

    
    //CMemGuard guard(script_p);
    
    //
    int rspDataLen = sizeof(SPCmd_TopArenaReplayRsp) + script_len;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topArenaReplayRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopArenaReplayRsp* rspBody = (SPCmd_TopArenaReplayRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    //rspBody->script_len = htonl(script_len);

    memcpy(rspBody->fight_script, script_p, script_len);
    if(script_p)
        delete script_p;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithTopArenaQueryGuess(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithTopArenaQueryGuess", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_TopArenaQueryGuess* query = (SPCmd_TopArenaQueryGuess*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_TopArenaQueryGuess))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query->round = ntohs(query->round);
        query->group = ntohs(query->group);
    }

    //unsigned int main_hero_id = pack->main_hero_id;

    TopArenaHeroValue value;
    bool result_flag = query_top_arena_value(query->round, query->group, value);

    //
    //
    int rspDataLen = sizeof(SPCmd_TopArenaQueryGuessRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = topArenaQueryGuessRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TopArenaQueryGuessRsp* rspBody = (SPCmd_TopArenaQueryGuessRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->hero_value_a = htonl(value.value_a);
    rspBody->hero_value_b = htonl(value.value_b);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    return;
}

void ProcServerThread::DealwithSystemGiftGetGift(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithSystemGiftGetGift", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_SystemGiftGetGift* get = (SPCmd_SystemGiftGetGift*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_SystemGiftGetGift))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->gift_id = ntohl(get->gift_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询玩家获奖情况
    unsigned int item_id = 0;
    unsigned int item_count = 0;
    {
        char sql[1024];
        sprintf(sql, "select item_id, item_count"
            " from hellgate.system_gift "
            " where system_gift_id=%u and hero_id=%u and expired_time>%u and is_actived<>0 "
            , get->gift_id, main_hero_id, (unsigned int)time(0));
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                item_id = atoi(Mysql_Thread_Conn->GetField("item_id"));
                item_count = atoi(Mysql_Thread_Conn->GetField("item_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    if(item_id > 0)
    {
        ObtainItem(main_hero_id, item_id, item_count);
    }
    else
    {
        int rspDataLen = sizeof(SPCmd_SystemGiftGetGiftRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = systemGiftGetGiftRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_SystemGiftGetGiftRsp* rspBody = (SPCmd_SystemGiftGetGiftRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //
    int rspDataLen = sizeof(SPCmd_SystemGiftGetGiftRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = systemGiftGetGiftRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SystemGiftGetGiftRsp* rspBody = (SPCmd_SystemGiftGetGiftRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->item_id = htonl(item_id);
    rspBody->item_count = htonl(item_count);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithSystemGiftQuery(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithSystemGiftQuery", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_SystemGiftQuery* query = (SPCmd_SystemGiftQuery*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_SystemGiftQuery))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询玩家获奖情况
    std::vector<systemGift> gift_vec;
    {
        char sql[1024];
        sprintf(sql, "select system_gift_id, is_actived, item_id, item_count, gift_desc"
            " from hellgate.system_gift "
            " where hero_id=%u and expired_time>%u"
            , main_hero_id, (unsigned int)time(0));
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                systemGift gift;
                gift.gift_id= atoi(Mysql_Thread_Conn->GetField("system_gift_id"));
                gift.is_actived = atoi(Mysql_Thread_Conn->GetField("is_actived"));
                gift.hero_id = main_hero_id;
                gift.item_id = atoi(Mysql_Thread_Conn->GetField("item_id"));
                gift.item_count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                strncpy(gift.gift_desc, Mysql_Thread_Conn->GetField("gift_desc"), SystemGiftDesc_MaxLen);
                gift.gift_desc[SystemGiftDesc_MaxLen] = 0;

                gift_vec.push_back(gift);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    int rspDataLen = sizeof(SPCmd_SystemGiftQueryRsp) + sizeof(systemGift)*gift_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = systemGiftQueryRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SystemGiftQueryRsp* rspBody = (SPCmd_SystemGiftQueryRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->gift_count = htonl(gift_vec.size());
    for(int i=0; i<gift_vec.size(); ++i)
    {
        rspBody->gift_arr[i].gift_id = htonl(gift_vec[i].gift_id);
        rspBody->gift_arr[i].is_actived = (gift_vec[i].is_actived);
        rspBody->gift_arr[i].hero_id = htonl(gift_vec[i].hero_id);
        rspBody->gift_arr[i].item_id = htonl(gift_vec[i].item_id);
        rspBody->gift_arr[i].item_count = htonl(gift_vec[i].item_count);
        strcpy(rspBody->gift_arr[i].gift_desc, gift_vec[i].gift_desc);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}

void ProcServerThread::DealwithDuanzaoListQuery(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithDuanzaoListQuery", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_DuanzaoListQuery* query = (SPCmd_DuanzaoListQuery*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_DuanzaoListQuery))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id,hero_info);

    //查询
    std::vector<DuanzaoGroup> group_vec;
    {
        char sql[1024];
        sprintf(sql, "select duanzao_group_id, duanzao_group_name, open_level"
            ", gold_need, item_id, item_count "
            " from hellgate.zhuangbei_duanzao ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                DuanzaoGroup group;
                
                group.duanzao_group_id = atoi(Mysql_Thread_Conn->GetField("duanzao_group_id"));
                
                strncpy(group.group_name, Mysql_Thread_Conn->GetField("duanzao_group_name"), DUANZAO_GROUP_NAME_MAX_LEN);
                group.group_name[DUANZAO_GROUP_NAME_MAX_LEN] = 0;

                group.open_level = atoi(Mysql_Thread_Conn->GetField("open_level"));

                group.gold_need = atoi(Mysql_Thread_Conn->GetField("gold_need"));

                group.item_id = atoi(Mysql_Thread_Conn->GetField("item_id"));
                group.item_count = atoi(Mysql_Thread_Conn->GetField("item_count"));

                group_vec.push_back(group);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    int rspDataLen = sizeof(SPCmd_DuanzaoListQueryRsp) + sizeof(DuanzaoGroup)*group_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = duanzaoListQueryRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_DuanzaoListQueryRsp* rspBody = (SPCmd_DuanzaoListQueryRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->group_count = htonl(group_vec.size());
    for(int i=0; i<group_vec.size(); ++i)
    {
        rspBody->group_arr[i].duanzao_group_id = htonl(group_vec[i].duanzao_group_id);
        rspBody->group_arr[i].open_level = htonl(group_vec[i].open_level);
        strcpy(rspBody->group_arr[i].group_name, group_vec[i].group_name);
        rspBody->group_arr[i].gold_need = htonl(group_vec[i].gold_need);
        rspBody->group_arr[i].item_id = htonl(group_vec[i].item_id);
        rspBody->group_arr[i].item_count = htonl(group_vec[i].item_count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}

struct _ZhuangbeiGroupAndWeight
{
    unsigned int group_id;
    unsigned int weight;
};
void ProcServerThread::DealwithDuanzao(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithDuanzao", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Duanzao* dz = (SPCmd_Duanzao*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Duanzao))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        dz->profession = ntohl(dz->profession);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    if(!check_and_draw_shenbing(main_hero_id, dz->profession, dz->is_times_10, zhuangbei_vec)) {
    
        int rspDataLen = sizeof(SPCmd_DuanzaoRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = duanzaoRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_DuanzaoRsp* rspBody = (SPCmd_DuanzaoRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        return;
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_DuanzaoRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = duanzaoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_DuanzaoRsp* rspBody = (SPCmd_DuanzaoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());

    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
    
}

void ProcServerThread::DealwithDuanzaoGroupZBQuery(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithDuanzaoGroupZBQuery", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_DuanzaoGroupZBQuery* query = (SPCmd_DuanzaoGroupZBQuery*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_DuanzaoGroupZBQuery))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query->duanzao_group_id = ntohl(query->duanzao_group_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id,hero_info);

    //查询group_id
    std::vector<unsigned int> group_id_vec;
    std::vector<unsigned int> group_weight_vec;
    unsigned int total_weight = 0;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_group_id, weight "
            " from hellgate.duanzao_group "
            " where duanzao_group_id=%u"
            , query->duanzao_group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int group_id;
                unsigned int weight;
                
                group_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_group_id"));
                weight = atoi(Mysql_Thread_Conn->GetField("weight"));

                group_id_vec.push_back(group_id);
                group_weight_vec.push_back(weight);
                total_weight += weight;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //查询group信息
    std::vector<DuanzaoGroupZBInfo> zb_info_vec;
    std::vector< std::vector<std::string> > zb_attr_str_vec;
    std::vector<std::string> zb_desc_vec;
    for(int i=0; i<group_id_vec.size(); ++i)
    {
        char sql[1024];
        sprintf(sql, "select distinct(group_id), zhuangbei_type, "
            " zhuangbei_colour, zhuangbei_name, zhuangbei_pic, zhuangbei_level, "
            " gongji_min_min, gongji_min_max, gongji_max_min, gongji_max_max, "
            " wufang_min, wufang_max, hole1_percent, hole2_percent, hole3_percent, "
            " attr_1, attr_2, attr_3, attr_4, attr_5, attr_6, attr_7, attr_8, attr_9, attr_10, "
            " zhuangbei_desc "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_name_list_copy.group_id=%u "
            , group_id_vec[i]);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                DuanzaoGroupZBInfo info;

                //
                info.ratio = group_weight_vec[i]/total_weight;
                if(info.ratio < 1)
                {
                    info.ratio = 1;
                }

                info.zb_group_id = group_id_vec[i];
                
                info.zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                info.zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                
                strncpy(info.zhuangbei_name, Mysql_Thread_Conn->GetField("zhuangbei_name"), ZhuangbeiNameMaxLen);
                info.zhuangbei_name[ZhuangbeiNameMaxLen] = 0;

                strncpy(info.zhuangbei_pic, Mysql_Thread_Conn->GetField("zhuangbei_pic"), ZhuangbeiPicMaxLen);
                info.zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;
                
                info.level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));

                info.gongji_min_min = atoi(Mysql_Thread_Conn->GetField("gongji_min_min"));
                info.gongji_min_max = atoi(Mysql_Thread_Conn->GetField("gongji_min_max"));
                info.gongji_max_min = atoi(Mysql_Thread_Conn->GetField("gongji_max_min"));
                info.gongji_max_max = atoi(Mysql_Thread_Conn->GetField("gongji_max_max"));
                info.wufang_min = atoi(Mysql_Thread_Conn->GetField("wufang_min"));
                info.wufang_max = atoi(Mysql_Thread_Conn->GetField("wufang_max"));
                
                get_zb_hole_percent(info.level, info.zhuangbei_colour, info.zhuangbei_type,
                    info.hole1_percent, info.hole2_percent, info.hole3_percent);

                std::vector<std::string> attr_vec;
                if(strlen(Mysql_Thread_Conn->GetField("attr_1")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_1")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_2")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_2")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_3")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_3")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_4")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_4")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_5")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_5")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_6")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_6")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_7")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_7")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_8")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_8")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_9")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_9")));
                }
                if(strlen(Mysql_Thread_Conn->GetField("attr_10")) > 0)
                {
                    attr_vec.insert(attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_10")));
                }

                //
                std::string desc = (Mysql_Thread_Conn->GetField("zhuangbei_desc"));

                //
                zb_info_vec.push_back(info);
                zb_attr_str_vec.push_back(attr_vec);
                zb_desc_vec.push_back(desc);
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_group_id not exist. [%u]"
                        , __FILE__, __LINE__, group_id_vec[i]);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

    }

    //
    int rspDataLen = sizeof(SPCmd_DuanzaoGroupZBQueryRsp) + sizeof(DuanzaoGroupZBInfo)*zb_info_vec.size();
    for(int i=0; i<zb_attr_str_vec.size(); ++i)
    {
        for(int j=0; j<zb_attr_str_vec[i].size(); ++j)
        {
            rspDataLen += (zb_attr_str_vec[i])[j].length()+1;
        }

        rspDataLen += zb_desc_vec[i].length()+1;
    }
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = duanzaoGroupZBQueryRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_DuanzaoGroupZBQueryRsp* rspBody = (SPCmd_DuanzaoGroupZBQueryRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->zb_count = htonl(zb_info_vec.size());
    DuanzaoGroupZBInfo* p = (DuanzaoGroupZBInfo*)rspBody->zb_arr;
    for(int i=0; i<zb_info_vec.size(); ++i)
    {
        p->ratio = htonl(zb_info_vec[i].ratio);
        
        p->zb_group_id = htonl(zb_info_vec[i].zb_group_id);
        p->zhuangbei_type = htonl(zb_info_vec[i].zhuangbei_type);
        p->zhuangbei_colour = htonl(zb_info_vec[i].zhuangbei_colour);
        p->level = htonl(zb_info_vec[i].level);
        strncpy(p->zhuangbei_name, zb_info_vec[i].zhuangbei_name, ZhuangbeiNameMaxLen);
        p->zhuangbei_name[ZhuangbeiNameMaxLen] = 0;
        strncpy(p->zhuangbei_pic, zb_info_vec[i].zhuangbei_pic, ZhuangbeiPicMaxLen);
        p->zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;

        p->gongji_min_min = htonl(zb_info_vec[i].gongji_min_min);
        p->gongji_min_max = htonl(zb_info_vec[i].gongji_min_max);
        p->gongji_max_min = htonl(zb_info_vec[i].gongji_max_min);
        p->gongji_max_max = htonl(zb_info_vec[i].gongji_max_max);
        p->wufang_min = htonl(zb_info_vec[i].wufang_min);
        p->wufang_max = htonl(zb_info_vec[i].wufang_max);
        p->hole1_percent = htonl(zb_info_vec[i].hole1_percent);
        p->hole2_percent = htonl(zb_info_vec[i].hole2_percent);
        p->hole3_percent = htonl(zb_info_vec[i].hole3_percent);

        p->attr_str_count = htonl(zb_attr_str_vec[i].size());

        char* str = p->attr_str;
        for(int j=0; j<zb_attr_str_vec[i].size(); ++j)
        {
            strcpy(str, (zb_attr_str_vec[i])[j].c_str());

            str += (zb_attr_str_vec[i])[j].length()+1;
        }

        //desc
        strcpy(str, zb_desc_vec[i].c_str());
        str += zb_desc_vec[i].length() + 1;
        
        //
        p = (DuanzaoGroupZBInfo*)str;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQuerySubtaskList(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithQuerySubtaskList", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QuerySubTaskList* query = (SPCmd_QuerySubTaskList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QuerySubTaskList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询subtask
    std::vector<SubTaskInfor> task_vec;
    {
        char sql[1024];
        sprintf(sql, "select hero_subtask.task_id, "
            " task_type, reward_item_id, reward_item_count, task_desc"
            " from hellgate.hero_subtask, hellgate.subtask_list "
            " where hellgate.hero_subtask.task_id=hellgate.subtask_list.task_id and hero_id=%u"
            " and task_status=%u"
            , main_hero_id, TaskStatus_Got);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                SubTaskInfor info;
                
                info.task_id = atoi(Mysql_Thread_Conn->GetField("task_id"));
                info.task_type = atoi(Mysql_Thread_Conn->GetField("task_type"));
                info.reward_item_id = atoi(Mysql_Thread_Conn->GetField("reward_item_id"));
                info.reward_item_count = atoi(Mysql_Thread_Conn->GetField("reward_item_count"));
                strncpy(info.desc, Mysql_Thread_Conn->GetField("task_desc"), SubTaskDescMaxLen);
                info.desc[SubTaskDescMaxLen] = 0;

                task_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_QuerySubTaskListRsp) + sizeof(SubTaskInfor)*task_vec.size();
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = querySubTaskListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QuerySubTaskListRsp* rspBody = (SPCmd_QuerySubTaskListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->task_count = htonl(task_vec.size());
    for(int i=0; i<task_vec.size(); ++i)
    {
        rspBody->task_arr[i].task_id = htonl(task_vec[i].task_id);
        rspBody->task_arr[i].task_type = htonl(task_vec[i].task_type);
        rspBody->task_arr[i].reward_item_id = htonl(task_vec[i].reward_item_id);
        rspBody->task_arr[i].reward_item_count = htonl(task_vec[i].reward_item_count);
        strcpy(rspBody->task_arr[i].desc, task_vec[i].desc);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryMainTaskReward(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithQueryMainTaskReward", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryMainTaskReward* query = (SPCmd_QueryMainTaskReward*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryMainTaskReward))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //查询subtask
    std::vector<main_task_reward> reward_vec;
    {
        char sql[1024];
        sprintf(sql, "select task_id, experience, silver "
            " from hellgate.main_task_reward"
            " order by task_id"
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                main_task_reward reward;

                reward.task_id = atoi(Mysql_Thread_Conn->GetField("task_id"));
                reward.exp = atoi(Mysql_Thread_Conn->GetField("experience"));
                reward.silver = atoi(Mysql_Thread_Conn->GetField("silver"));

                reward_vec.push_back(reward);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_QueryMainTaskRewardRsp) + sizeof(main_task_reward)*reward_vec.size();
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryMainTaskRewardRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryMainTaskRewardRsp* rspBody = (SPCmd_QueryMainTaskRewardRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->task_count = htonl(reward_vec.size());
    for(int i=0; i<reward_vec.size(); ++i)
    {
        rspBody->task_reward[i].task_id = htonl(reward_vec[i].task_id);
        rspBody->task_reward[i].exp = htonl(reward_vec[i].exp);
        rspBody->task_reward[i].silver = htonl(reward_vec[i].silver);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithChargeGold(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChargeGold", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ChargeGold* buy = (SPCmd_ChargeGold*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ChargeGold))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        buy->gold_packet_id = ntohl(buy->gold_packet_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    bool b_success = true;

    ChargePacketInfo charge_info;
    {//查询充值包
        char sql[1024];
        sprintf(sql, "select charge, gold_count, present_count from hellgate.charge_packet_temp "
            " where id=%u "
            , buy->gold_packet_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                charge_info.id = buy->gold_packet_id;
                charge_info.charge = atoi(Mysql_Thread_Conn->GetField("charge"));
                charge_info.gold_count = atoi(Mysql_Thread_Conn->GetField("gold_count"));
                charge_info.present_count = atoi(Mysql_Thread_Conn->GetField("present_count"));
            } else {
                b_success= true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    bool b_first_charged = true;
    unsigned int total_charge = 0;
    VIP_Info v_info;
    {//查询历史充值
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.hero_vip_info where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                b_first_charged = (bool)atoi(Mysql_Thread_Conn->GetField("first_charge"));
                v_info.total_charge = total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                v_info.level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                v_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                v_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                v_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                v_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                v_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                v_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                v_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));
            }
            else{
                b_success= true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    /*
    std::vector<ItemInfo> item_vec;
    if(!b_first_charged) {// 是否第一次充值
        char sql[1024];
        sprintf(sql, "select item_type, item_count from hellgate.system_bonus_temp_old "
            " where id=%u order by item_type "
            , BonusType_First_Charge);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ItemInfo info;
                info.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                info.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                if(info.count >0)  {
                    item_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */
    
    //根据充值总额决定VIP等级
    total_charge += charge_info.charge;
    unsigned int vip_level = 0;
    std::vector<VIP_Info> vip_vec;
    //查询vip功能模板
    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.vip_template order by level desc");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                VIP_Info tmp_v_info;
                tmp_v_info.level = atoi(Mysql_Thread_Conn->GetField("level"));
                tmp_v_info.total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                tmp_v_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                tmp_v_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                tmp_v_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                tmp_v_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                tmp_v_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                tmp_v_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                tmp_v_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));

                vip_vec.insert(vip_vec.end(), tmp_v_info);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    int old_num=0;
    int new_num=0;
    for(int i=0; i<vip_vec.size(); i++){
        if(v_info.level == vip_vec[i].level){
            old_num = i;
            break;
        }
    }
    for(int i=0; i<vip_vec.size(); i++){
        if(total_charge >= vip_vec[i].total_charge){
            new_num = i;
            break;
        }
    }

    vip_level = vip_vec[new_num].level;
    
    //查询余额
    unsigned int gold_balance = getItemCountInTeam(main_hero_id, ItemsType_Gold);
    
    //充金币
    unsigned int added_gold = charge_info.present_count;
    added_gold += b_first_charged ? charge_info.gold_count : charge_info.gold_count*2;
    gold_balance += added_gold;
    {
        ObtainItem(main_hero_id, ItemsType_Gold, added_gold);
        if(!b_first_charged) { //首次充值赠送的道具发到邮件
            insert_and_send_email(main_hero_id, 0, EmailType_Bonus, EmailID_First_Charge);
        }
    }

    
    {//修改hero_info
        char sql[1024];
        sprintf(sql, "update hellgate.hero_vip_info set vip_level=%u, total_charge=%u "
            ", buy_vitality_num=%u, sweep_num=%u, buy_arena_num=%u, over_creep_num=%u "
            ", cast_silver_num=%u, honor_exchange=%u, refresh_reward_num=%u "
            " where hero_id=%u"
            , vip_level, total_charge
            , vip_vec[new_num].priv.buy_vitality_num - (vip_vec[old_num].priv.buy_vitality_num - v_info.priv.buy_vitality_num)
            , vip_vec[new_num].priv.sweep_num - (vip_vec[old_num].priv.sweep_num - v_info.priv.sweep_num)
            , vip_vec[new_num].priv.buy_arena_num - (vip_vec[old_num].priv.buy_arena_num - v_info.priv.buy_arena_num)
            , vip_vec[new_num].priv.over_creep_num
            , vip_vec[new_num].priv.cast_silver_num - (vip_vec[old_num].priv.cast_silver_num - v_info.priv.cast_silver_num)
            , vip_vec[new_num].priv.honor_exchange
            , vip_vec[new_num].priv.refresh_reward_num - (vip_vec[old_num].priv.refresh_reward_num - v_info.priv.refresh_reward_num)
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(!b_first_charged){//修改hero_info
        char sql[1024];
        sprintf(sql, "update hellgate.hero_vip_info set first_charge=1 "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    unsigned int next_vip_level = vip_level +1;
    unsigned int next_need_charge = 0;
    bool b_max_level = true;
    {//查询下一等级所需金额
        for(int i=0; i<vip_vec.size(); i++)  {
            if(vip_vec[i].level == next_vip_level) {
                b_max_level = false;
                next_need_charge = vip_vec[i].total_charge;
                
                if(next_need_charge < total_charge)
                    next_need_charge = 0;
                else
                    next_need_charge -= total_charge;
            }
        }
        if(b_max_level) { //已达到最高vip等级
            next_vip_level = vip_level;
        }
    }
   
    //
    int rspDataLen = sizeof(SPCmd_ChargeGoldRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = chargeGoldRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ChargeGoldRsp* rspBody = (SPCmd_ChargeGoldRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->gold_balance = htonl(gold_balance);
    rspBody->vip_level = htonl(vip_level);
    rspBody->next_vip_level = htonl(next_vip_level);
    rspBody->next_need_charge = htonl(next_need_charge);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithQueryChargePacket(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryChargePacket", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryChargePacket* get = (SPCmd_QueryChargePacket*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryChargePacket))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    std::vector<ChargePacketInfo> packet_vec;
    {//查询充值包
        char sql[1024];
        sprintf(sql, "select * from hellgate.charge_packet_temp order by charge desc ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ChargePacketInfo info;
                info.id = atoi(Mysql_Thread_Conn->GetField("id"));
                info.charge = atoi(Mysql_Thread_Conn->GetField("charge"));
                info.gold_count = atoi(Mysql_Thread_Conn->GetField("gold_count"));
                info.present_count = atoi(Mysql_Thread_Conn->GetField("present_count"));

                if(info.charge >0)  {
                    packet_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    bool b_first_charged = false;
    unsigned int vip_level = 0;
    unsigned int total_charge = 0;
    
    //查询历史充值
    {
        char sql[1024];
        sprintf(sql, "select vip_level,  total_charge, first_charge "
            " from hellgate.hero_vip_info where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                b_first_charged = (bool)atoi(Mysql_Thread_Conn->GetField("first_charge"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int next_vip_level = vip_level +1;
    unsigned int next_need_charge = 0;
    {//查询下一等级所需金额
        char sql[1024];
        sprintf(sql, "select total_charge from hellgate.vip_template "
            " where level=%u "
            , next_vip_level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL){
                next_need_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                
                if(next_need_charge < total_charge)
                    next_need_charge = 0;
                else
                    next_need_charge -= total_charge;
            }
            else {//已经达到最高级
                next_vip_level = vip_level;
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    std::vector<ItemInfo> item_vec;
    if(!b_first_charged) { //第一次充值
        std::map<unsigned int, __EmailInfo>::iterator p 
            = m_email_internal_map.find(EmailID_First_Charge);
        
        if(p != m_email_internal_map.end()) {
            item_vec = p->second.item_vec;
        }
    }
    
    //
    int rspDataLen = sizeof(SPCmd_QueryChargePacketRsp) 
        +sizeof(ChargePacketInfo)*packet_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryChargePacketRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryChargePacketRsp* rspBody = (SPCmd_QueryChargePacketRsp*)((rspHead)+1);
    bzero(rspBody, sizeof(SPCmd_QueryChargePacketRsp));
    rspBody->err_code = htonl(Success);

    rspBody->next_vip_level = htonl(next_vip_level);
    rspBody->next_need_charge = htonl(next_need_charge);
    
    rspBody->b_first_charged = b_first_charged;
    if(!b_first_charged) {
        ItemInfo *p = rspBody->first_present_item;
        for(int i=0; i<item_vec.size()&&i<5; i++, p++) {
            p->type = htonl(item_vec[i].type);
            p->count = htonl(item_vec[i].count);
        }
    }

    rspBody->count = htonl(packet_vec.size());

    ChargePacketInfo *p = rspBody->info;
    for(int i=0; i<packet_vec.size(); i++, p++) {
            p->id = htonl(packet_vec[i].id);
            p->charge = htonl(packet_vec[i].charge);
            p->gold_count = htonl(packet_vec[i].gold_count);
            p->present_count = htonl(packet_vec[i].present_count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithQueryTeamSkillList(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryTeamSkillList", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryTeamSkillList* query = (SPCmd_QueryTeamSkillList*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryTeamSkillList))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    

    //
    std::vector<SkillInfo> skill_vec;
    //查询
    {
        char sql[1024];
        sprintf(sql, "select own_hero_id, skill_id, skill_type, skill_level, is_equiped "
            " from hellgate.skill_in_team where main_hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                SkillInfo info;
                
                info.owner_hero_id = atoi(Mysql_Thread_Conn->GetField("own_hero_id"));
                info.skill_id = atoi(Mysql_Thread_Conn->GetField("skill_id"));
                info.skill_type = atoi(Mysql_Thread_Conn->GetField("skill_type"));
                info.skill_level = atoi(Mysql_Thread_Conn->GetField("skill_level"));
                info.is_equiped = (bool)atoi(Mysql_Thread_Conn->GetField("is_equiped"));

                skill_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(skill_vec.size() == 0)
    {
        LogMsg("%s, line %d, hero_id[%u] has no skill"
                        , __FILE__, __LINE__, main_hero_id);

        Mysql_Thread_Conn->FreeResult();
        return;
    }
    
    //
    int rspDataLen = sizeof(SPCmd_QueryTeamSkillListRsp) + sizeof(SkillInfo)*skill_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryTeamSkillListRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryTeamSkillListRsp* rspBody = (SPCmd_QueryTeamSkillListRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->skill_count = htonl(skill_vec.size());
    for(int i=0; i<skill_vec.size(); ++i)
    {
        rspBody->skill_arr[i].skill_id = htonl(skill_vec[i].skill_id);
        rspBody->skill_arr[i].skill_type = htonl(skill_vec[i].skill_type);
        rspBody->skill_arr[i].skill_level = htonl(skill_vec[i].skill_level);
        rspBody->skill_arr[i].owner_hero_id = htonl(skill_vec[i].owner_hero_id);
        rspBody->skill_arr[i].is_equiped = (skill_vec[i].is_equiped);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}
void ProcServerThread::DealwithEquipSkill(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithEquipSkill", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_EquipSkill* equip = (SPCmd_EquipSkill*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_EquipSkill))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        equip->hero_id = ntohl(equip->hero_id);
        equip->skill_id = ntohl(equip->skill_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;
    

    //
    //查询hero是否有此skill
    bool skill_exist = false;
    {
        char sql[1024];
        sprintf(sql, "select skill_id "
            " from hellgate.skill_in_team where own_hero_id=%u"
            , equip->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!skill_exist)
    {
        //
        int rspDataLen = sizeof(SPCmd_EquipSkillRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = equipSkillRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_EquipSkillRsp* rspBody = (SPCmd_EquipSkillRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //
    {
        char sql[1024];
        sprintf(sql, "update hellgate.skill_in_team set is_equiped=0 where own_hero_id=%u"
            , equip->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    {
        char sql[1024];
        sprintf(sql, "update hellgate.skill_in_team set is_equiped=1 where own_hero_id=%u and skill_id=%u"
            , equip->hero_id, equip->skill_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //技能换了 重新计算战斗力
    calculate_fight_capacity(equip->hero_id);
    
    //
    int rspDataLen = sizeof(SPCmd_EquipSkillRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = equipSkillRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_EquipSkillRsp* rspBody = (SPCmd_EquipSkillRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}
void ProcServerThread::DealwithActorLearnSkill(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithEquipSkill", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ActorLearnSkill* learn = (SPCmd_ActorLearnSkill*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ActorLearnSkill))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        learn->hero_id = ntohl(learn->hero_id);
        learn->item_id = ntohl(learn->item_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    

    //
    //查询hero是否有此item
    unsigned int item_count = getItemCountInTeam(main_hero_id, learn->item_id);
    if(item_count == 0)
    {
        //
        int rspDataLen = sizeof(SPCmd_ActorLearnSkillRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = actorLearnSkillRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ActorLearnSkillRsp* rspBody = (SPCmd_ActorLearnSkillRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //检查hero是否已经学会了此技能
    bool skill_learned = false;
    {
        char sql[1024];
        sprintf(sql, "select skill_id "
            " from hellgate.skill_in_team where own_hero_id=%u and skill_type=%u"
            , learn->hero_id, learn->item_id-ItemsType_SkillBook_MinId);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_learned = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(skill_learned)
    {
        //
        int rspDataLen = sizeof(SPCmd_ActorLearnSkillRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = actorLearnSkillRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ActorLearnSkillRsp* rspBody = (SPCmd_ActorLearnSkillRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //生成skill_id
    unsigned skill_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select max(skill_id) max_skill_id "
            " from hellgate.skill_in_team where main_hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_id = atoi(Mysql_Thread_Conn->GetField("max_skill_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    skill_id++;

    //
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.skill_in_team set "
            " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=0"
            , main_hero_id, learn->hero_id, skill_id, learn->item_id-ItemsType_SkillBook_MinId);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //扣书
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-1 where hero_id=%u and item_type=%u"
            , main_hero_id, learn->item_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    int rspDataLen = sizeof(SPCmd_ActorLearnSkillRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = actorLearnSkillRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ActorLearnSkillRsp* rspBody = (SPCmd_ActorLearnSkillRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->new_skill.skill_id = ntohl(skill_id);
    rspBody->new_skill.skill_type = ntohl(learn->item_id-ItemsType_SkillBook_MinId);
    rspBody->new_skill.skill_level = ntohl(1);
    rspBody->new_skill.owner_hero_id = ntohl(learn->hero_id);
    rspBody->new_skill.is_equiped = false;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithQueryTeamShenbingSuipian(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryTeamShenbingSuipian", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryTeamShenbingSuipian* query = (SPCmd_QueryTeamShenbingSuipian*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryTeamShenbingSuipian))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    

    std::vector<ShenbingSuipianInfo> suipian_vec;
    //查询
    {
        char sql[1024];
        sprintf(sql, "select zb_group_id, suipian_id, suipian_count "
            " from hellgate.shenbing_suipian_in_team where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ShenbingSuipianInfo info;
                info.zb_group_id = atoi(Mysql_Thread_Conn->GetField("zb_group_id"));
                info.suipian_id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                info.suipian_count = atoi(Mysql_Thread_Conn->GetField("suipian_count"));

                suipian_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryTeamShenbingSuipianRsp)
        + sizeof(ShenbingSuipianInfo)*suipian_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryTeamShenbingSuipianRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryTeamShenbingSuipianRsp* rspBody = (SPCmd_QueryTeamShenbingSuipianRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->suipian_info_count = htonl(suipian_vec.size());
    for(int i=0; i<suipian_vec.size(); ++i)
    {
        rspBody->suipian_into_arr[i].zb_group_id = htonl(suipian_vec[i].zb_group_id);
        rspBody->suipian_into_arr[i].suipian_id = htonl(suipian_vec[i].suipian_id);
        rspBody->suipian_into_arr[i].suipian_count = htonl(suipian_vec[i].suipian_count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithShenbingHecheng(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithShenbingHecheng", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ShenbingHecheng* hecheng = (SPCmd_ShenbingHecheng*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ShenbingHecheng))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        hecheng->zb_group_id = ntohl(hecheng->zb_group_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    

    unsigned int zb_suipian_arr[5] = {0,0,0,0,0};
    //查询
    {
        char sql[1024];
        sprintf(sql, "select suipian_id, suipian_count "
            " from hellgate.shenbing_suipian_in_team where hero_id=%u and zb_group_id=%u"
            , main_hero_id, hecheng->zb_group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int suipian_id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                unsigned int suipian_count = atoi(Mysql_Thread_Conn->GetField("suipian_count"));

                if(suipian_id > 5)
                {
                    LogMsg("%s, line %d, item_suipian_id=[%u]. shit"
                        , __FILE__, __LINE__, suipian_id);
                    continue;
                }

                if(zb_suipian_arr[suipian_id-1] > 0)
                {
                    LogMsg("%s, line %d, item_suipian_id=[%u]. shit"
                        , __FILE__, __LINE__, suipian_id);
                    continue;
                }
                
                zb_suipian_arr[suipian_id-1] = suipian_count;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int min_suipian_count = 0xffffffff;
    for(int i=0; i<5; ++i)
    {
        if(zb_suipian_arr[i] < min_suipian_count)
        {
            min_suipian_count = zb_suipian_arr[i];
        }
    }

    if(min_suipian_count == 0)
    {
        //
        int rspDataLen = sizeof(SPCmd_ShenbingHechengRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = shenbingHechengRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ShenbingHechengRsp* rspBody = (SPCmd_ShenbingHechengRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //通过group_id找到name_id
    unsigned int zb_name_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_name_id "
            " from hellgate.zhuangbei_name_list_copy where group_id=%u"
            , hecheng->zb_group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(zb_name_id == 0)
    {
        LogMsg("%s, line %d, zb_group_id[%u] invalide. "
                        , __FILE__, __LINE__, hecheng->zb_group_id);
        return;
    }

    //先合成
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    for(int i=0; i<min_suipian_count; ++i)
    {
        __ZhuangbeiDetail zb_detail;
        if(!createZhuangbei(zb_name_id, hecheng->zb_group_id,main_hero_id,zb_detail))
        {
            LogMsg("%s, line %d, zb_group_id[%u] hecheng failed. "
                            , __FILE__, __LINE__, hecheng->zb_group_id);
            return;
        }
        zb_detail.zhuangbei_id = ObtainZhuangbei(main_hero_id, zb_name_id, zb_detail);

        zhuangbei_vec.push_back(zb_detail);
    }

    
    //合成传奇插入到跑马灯消息队列中
    insert_marquee_message(MarqueeType_Compound, main_hero_id, hecheng->zb_group_id);
    

    //扣碎片
    {
        char sql[1024];
        sprintf(sql, "update hellgate.shenbing_suipian_in_team set suipian_count=suipian_count-%d "
            " where hero_id=%u and zb_group_id=%u"
            , min_suipian_count
            , main_hero_id, hecheng->zb_group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    int rspDataLen = sizeof(SPCmd_ShenbingHechengRsp) + zhuangbei_detail_data_len;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = shenbingHechengRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ShenbingHechengRsp* rspBody = (SPCmd_ShenbingHechengRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());

    memcpy(&rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryTeamItemSuipian(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryTeamItemSuipian", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryTeamItemSuipian* query = (SPCmd_QueryTeamItemSuipian*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryTeamItemSuipian))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    

    std::vector<ItemSuipianInfo> suipian_vec;
    //查询
    {
        char sql[1024];
        sprintf(sql, "select item_type, suipian_id, suipian_count "
            " from hellgate.item_suipian_in_team where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ItemSuipianInfo info;
                info.item_id = atoi(Mysql_Thread_Conn->GetField("item_type"));
                info.suipian_id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                info.suipian_count = atoi(Mysql_Thread_Conn->GetField("suipian_count"));

                suipian_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryTeamItemSuipianRsp)
        + sizeof(ItemSuipianInfo)*suipian_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryTeamItemSuipianRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryTeamItemSuipianRsp* rspBody = (SPCmd_QueryTeamItemSuipianRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->suipian_info_count = htonl(suipian_vec.size());
    for(int i=0; i<suipian_vec.size(); ++i)
    {
        rspBody->suipian_into_arr[i].item_id = htonl(suipian_vec[i].item_id);
        rspBody->suipian_into_arr[i].suipian_id = htonl(suipian_vec[i].suipian_id);
        rspBody->suipian_into_arr[i].suipian_count = htonl(suipian_vec[i].suipian_count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithItemHecheng(Packet* pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithItemHecheng", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ItemHecheng* hecheng = (SPCmd_ItemHecheng*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ItemHecheng))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        hecheng->item_id = ntohl(hecheng->item_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    

    unsigned int item_suipian_arr[5] = {0,0,0,0,0};
    //查询
    {
        char sql[1024];
        sprintf(sql, "select suipian_id, suipian_count "
            " from hellgate.item_suipian_in_team where hero_id=%u and item_type=%u"
            , main_hero_id, hecheng->item_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int suipian_id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                unsigned int suipian_count = atoi(Mysql_Thread_Conn->GetField("suipian_count"));

                if(suipian_id > 5)
                {
                    LogMsg("%s, line %d, item_suipian_id=[%u]. shit"
                        , __FILE__, __LINE__, suipian_id);
                    continue;
                }

                if(item_suipian_arr[suipian_id-1] > 0)
                {
                    LogMsg("%s, line %d, item_suipian_id=[%u]. shit"
                        , __FILE__, __LINE__, suipian_id);
                    continue;
                }
                
                item_suipian_arr[suipian_id-1] = suipian_count;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int min_suipian_count = 0xffffffff;
    for(int i=0; i<5; ++i)
    {
        if(item_suipian_arr[i] < min_suipian_count)
        {
            min_suipian_count = item_suipian_arr[i];
        }
    }
    if(min_suipian_count == 0)
    {
        //
        int rspDataLen = sizeof(SPCmd_ItemHechengRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = itemHechengRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ItemHechengRsp* rspBody = (SPCmd_ItemHechengRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //先合成
    ObtainItem(main_hero_id,hecheng->item_id,min_suipian_count);

    //扣碎片
    {
        char sql[1024];
        sprintf(sql, "update hellgate.item_suipian_in_team set suipian_count=suipian_count-%d "
            " where hero_id=%u and item_type=%u"
            , min_suipian_count
            , main_hero_id, hecheng->item_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    int rspDataLen = sizeof(SPCmd_ItemHechengRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = itemHechengRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ItemHechengRsp* rspBody = (SPCmd_ItemHechengRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->item_info.type = htonl(hecheng->item_id);
    rspBody->item_info.count = htonl(min_suipian_count);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithQueryHellTaskHeroInfo(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryHellTaskHeroInfo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryHellTaskHeroInfo* query = (SPCmd_QueryHellTaskHeroInfo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryHellTaskHeroInfo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);
    if(hero_info.level < HERO_LEVEL_HELL_TASK_OPEN)
    {
        //
        int rspDataLen = sizeof(SPCmd_QueryHellTaskHeroInfoRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = queryHellTaskHeroInfoRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_QueryHellTaskHeroInfoRsp* rspBody = (SPCmd_QueryHellTaskHeroInfoRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    
    //
    unsigned int battle_time_remainder = 0;
    unsigned int last_active_task_id = 0;
    getAndRefreshHellTaskHeroInfo(main_hero_id, battle_time_remainder, last_active_task_id);
    
    
    //
    int rspDataLen = sizeof(SPCmd_QueryHellTaskHeroInfoRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryHellTaskHeroInfoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryHellTaskHeroInfoRsp* rspBody = (SPCmd_QueryHellTaskHeroInfoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->battle_time_remainder = htonl(battle_time_remainder);
    rspBody->last_active_task_id = htonl(last_active_task_id);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithHellTaskBattle(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithHellTaskBattle", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_HellTaskBattle* bt = (SPCmd_HellTaskBattle*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_HellTaskBattle))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        bt->task_id = ntohl(bt->task_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);

    
    //判断有效性
    unsigned int battle_time_remainder = 0;
    unsigned int last_active_task_id = 0;
    getAndRefreshHellTaskHeroInfo(main_hero_id, battle_time_remainder, last_active_task_id);
    if(hero_info.level < HERO_LEVEL_HELL_TASK_OPEN
        || battle_time_remainder == 0
        || bt->task_id > last_active_task_id
        || bt->task_id < HellTaskId_Min
        || bt->task_id > HellTaskId_Max)
    {
        //
        int rspDataLen = sizeof(SPCmd_HellTaskBattleRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = hellTaskBattleRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_HellTaskBattleRsp* rspBody = (SPCmd_HellTaskBattleRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //刷新棋盘
    refreshChessBoard(main_hero_id, bt->task_id);

    //查询我方上阵阵型
    unsigned int team_pos_vec[4] = {0, 0, 0, 0};
    {
        std::vector<int> arr;
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , main_hero_id, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, main_hero_id, pos);
                }
                else
                {
                    team_pos_vec[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询怪物阵型
    unsigned int monster_pos_vec_1[4] = {0, 0, 0, 0};
    unsigned int monster_pos_vec_2[4] = {0, 0, 0, 0};
    unsigned int monster_pos_vec_3[4] = {0, 0, 0, 0};
    getGuanQiaGuaiWu(main_hero_id, bt->task_id, 0
        , monster_pos_vec_1, monster_pos_vec_2, monster_pos_vec_3);

    //地狱副本一律6波怪物
    unsigned int guaiwuAttachTime = getGuaiwuAttackCountOfTask(bt->task_id,0);
    
    //生成战斗脚本
    std::vector<FightScript> team_script_vec;
    bool battle_win = true;
    char* fight_script = 0;
    int fight_script_len = 0;
    {
        ScriptBuilderUserData userData;
        FightSUD f_sud;
        userData.data = &f_sud;
        
        HeroState teamHp;
        f_sud.heroId = main_hero_id;
        f_sud.taskId = bt->task_id;
        f_sud.gridId = 0;
        FightScriptBuilder scriptBuild;

        unsigned int fight_index = 1;
        if(guaiwuAttachTime >= 3)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 4)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 2)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_2
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 5)            
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_2
                , team_script, monster_script
                , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            //
            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }

        if(battle_win) //最后一个波一定是需要的
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_3
                , team_script, monster_script
                 , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }
        if(battle_win && guaiwuAttachTime >= 6)
        {
            FightScript team_script;
            FightScript monster_script;
            f_sud.fightIndex = fight_index;
            f_sud.heroHpAfterLastFight = teamHp;
            teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_3
                , team_script, monster_script
                 , this
                , userData
                , FBB_BoardA
                , BATTLE_ROUND_LIMIT);
            team_script_vec.push_back(team_script);

            battle_win = (team_script.endResult.myResult == Result_Win);
            fight_index++;
        }

        //rspHead = scriptBuild.FightScript_2_Package(team_script_vec);
        fight_script = scriptBuild.FightScriptVec_2_CharArr(team_script_vec,fight_script_len);
    }

    
    //当前任务关打赢了，开启下一关
    unsigned int task_id_plus = 0;
    if(battle_win && bt->task_id==last_active_task_id && bt->task_id<HellTaskId_Max)
    {
        task_id_plus = 1;
    }

    //开启下一关，并扣次数 
    {
        //
        char sql[1024];

        sprintf(sql, "update hellgate.hell_task_hero_info set last_active_task_id=last_active_task_id+%u, "
            " battle_time_remainder=battle_time_remainder-1 "
            " where hero_id=%u"
            , task_id_plus
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    int rspDataLen = sizeof(SPCmd_HellTaskBattleRsp) + fight_script_len;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = hellTaskBattleRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_HellTaskBattleRsp* rspBody = (SPCmd_HellTaskBattleRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->fightNum = htonl(team_script_vec.size());
    memcpy(rspBody->fightScript_array, fight_script, fight_script_len);
    delete[] fight_script;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);


    return;
}

void ProcServerThread::DealwithQueryYuanshenOfHero(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryYuanshenOfHero", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryYuanshenOfHero* query = (SPCmd_QueryYuanshenOfHero*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryYuanshenOfHero))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query->hero_id = ntohl(query->hero_id);
    }

    HeroInfo hero_info;
    if(!GetHeroBasicInfo(query->hero_id, hero_info)
        || hero_info.is_yuanshen
        || hero_info.level != HERO_MAX_LEVEL)
    {
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_QueryYuanshenOfHeroRsp);
        
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = queryYuanshenOfHeroRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_QueryYuanshenOfHeroRsp* rspBody = (SPCmd_QueryYuanshenOfHeroRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);
        

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    if(!hero_info.is_yuanshen && hero_info.level == HERO_MAX_LEVEL){
        //等级达到了 没有元神 重新创建元神
        createYuanshen(query->hero_id);
    }

    
    //查询hero对应的元神的id
    unsigned int yuanshen_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select hero_id "
            " from hellgate.hero_infor where zhenshen_id=%u"
            , query->hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                yuanshen_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                
            }
            else
            {
                LogMsg("%s, line %d, yuanshen of hero[%u] not found"
                        , __FILE__, __LINE__, query->hero_id);
                
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(yuanshen_id == 0)
    {
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_QueryYuanshenOfHeroRsp);
        
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = queryYuanshenOfHeroRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_QueryYuanshenOfHeroRsp* rspBody = (SPCmd_QueryYuanshenOfHeroRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);
        

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    
    HeroDetail detail;
    GetHeroDetail(yuanshen_id, detail);

    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_id"
            " from hellgate.zhuangbei_list"
            " where zhuangbei_hero_id=%u"
            , yuanshen_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
    }
    
    //
    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryYuanshenOfHeroRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryYuanshenOfHeroRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryYuanshenOfHeroRsp* rspBody = (SPCmd_QueryYuanshenOfHeroRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //
    hton_hero_detail(detail,rspBody->hero_detail);

    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::DealwithChurchLevelUp(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChurchLevelUp", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ChurchLevelUp* levelup = (SPCmd_ChurchLevelUp*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ChurchLevelUp))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        levelup = levelup;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    unsigned int silver_balance;
    unsigned int dalishi_balance;
    unsigned int huagangyan_balance;
    unsigned int mocai_balance;
    unsigned int shuijinshi_balance;

    unsigned int new_church_level;

    if(!checkAndChurchLevelUp(main_hero_id
        ,new_church_level, silver_balance, dalishi_balance, huagangyan_balance
        , mocai_balance, shuijinshi_balance))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_ChurchLevelUpRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = churchLevelUpRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_ChurchLevelUpRsp* rspBody = (SPCmd_ChurchLevelUpRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ChurchLevelUpRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = churchLevelUpRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ChurchLevelUpRsp* rspBody = (SPCmd_ChurchLevelUpRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    
    rspBody->church_level = htonl(new_church_level);

    rspBody->silver_balance= htonl(silver_balance);
    
    rspBody->dalishi_balance = htonl(dalishi_balance);
    rspBody->huagangyan_balance = htonl(huagangyan_balance);
    rspBody->mucai_balance = htonl(mocai_balance);
    rspBody->shuijinshi_balance = htonl(shuijinshi_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}

unsigned int ProcServerThread::getChurchLevel(unsigned int main_hero_id)
{
    unsigned int level = 1;
    {
        char sql[1024];
        sprintf(sql, "select church_level "
            " from hellgate.hero_list where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                level = atoi(Mysql_Thread_Conn->GetField("church_level"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return level;
}

bool ProcServerThread::checkAndChurchLevelUp(unsigned int main_hero_id
    ,unsigned int & new_church_level
    ,unsigned int & silver_balance,unsigned int & dalishi_balance
    ,unsigned int & huagangyan_balance,unsigned int & mocai_balance
    ,unsigned int & shuijinshi_balance)
{
    unsigned int church_level = getChurchLevel(main_hero_id);
    new_church_level = church_level + 1;

    //
    if(church_level >= HERO_MAX_STAGE)
    {
        return false;
    }

    //
    unsigned int dalishi_need, huagangyan_need, mocai_need, shuijinshi_need;
    CS::churchLevelUpNeedItemCount(new_church_level
        , dalishi_need, huagangyan_need, mocai_need, shuijinshi_need);

    //查询道具
    dalishi_balance = getItemCountInTeam(main_hero_id, ItemsType_Dalishi);
    if(dalishi_balance < dalishi_need)
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup dalishi_balance=[%d]", __FILE__, __LINE__, dalishi_balance);
#endif //_DEBUG

        return false;
    }

    //查询道具
    huagangyan_balance = getItemCountInTeam(main_hero_id, ItemsType_Huagangyan);
    if(huagangyan_balance < huagangyan_need)
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup huagangyan_balance=[%d]", __FILE__, __LINE__, huagangyan_balance);
#endif //_DEBUG

        return false;
    }

    //查询道具
    mocai_balance = getItemCountInTeam(main_hero_id, ItemsType_Mucai);
    if(mocai_balance < mocai_need)
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup mocai_balance=[%d]", __FILE__, __LINE__, mocai_balance);
#endif //_DEBUG

        return false;
    }

    //查询道具
    shuijinshi_balance = getItemCountInTeam(main_hero_id, ItemsType_Shuijingshi);
    if(shuijinshi_balance < shuijinshi_need)
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup shuijinshi_balance=[%d]", __FILE__, __LINE__, shuijinshi_balance);
#endif //_DEBUG

        return false;
    }

    //查询银币
    silver_balance = getItemCountInTeam(main_hero_id, ItemsType_Silver);
    if(silver_balance < CS::churchLevelUpNeedSilver(new_church_level))
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup silver_balance=[%d]", __FILE__, __LINE__, silver_balance);
#endif //_DEBUG

        return false;
    }

    //升级
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_list "
            " set church_level=%u "
            " where hero_id=%u"
            , new_church_level, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //扣钱
    silver_balance -= CS::churchLevelUpNeedSilver(new_church_level);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_balance, main_hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //扣道具
    dalishi_balance -= dalishi_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , dalishi_balance, main_hero_id, ItemsType_Dalishi);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //扣道具
    huagangyan_balance -= huagangyan_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , huagangyan_balance, main_hero_id, ItemsType_Huagangyan);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //扣道具
    mocai_balance -= mocai_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , mocai_balance, main_hero_id, ItemsType_Mucai);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //扣道具
    shuijinshi_balance -= shuijinshi_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , shuijinshi_balance, main_hero_id, ItemsType_Shuijingshi);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

void ProcServerThread::DealWithSkillLevelUp(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealWithSkillLevelUp", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_SkillLevelUp* levelup = (SPCmd_SkillLevelUp*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_SkillLevelUp))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        levelup->owner_hero_id = ntohl(levelup->owner_hero_id);
        levelup->skill_id = ntohl(levelup->skill_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    if(!isHeroBelong2Team(levelup->owner_hero_id, main_hero_id))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_SkillLevelUpRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = skillLevelUpRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_SkillLevelUpRsp* rspBody = (SPCmd_SkillLevelUpRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }

    //
    unsigned int new_skill_level;
    unsigned int silver_balance;
    ItemInfo skill_book;


    if(!checkAndSkillLevelUp(main_hero_id, levelup->owner_hero_id, levelup->skill_id
        , new_skill_level, silver_balance, skill_book))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_SkillLevelUpRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = skillLevelUpRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_SkillLevelUpRsp* rspBody = (SPCmd_SkillLevelUpRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_SkillLevelUpRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = skillLevelUpRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SkillLevelUpRsp* rspBody = (SPCmd_SkillLevelUpRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->new_skill_level = htonl(new_skill_level);
    rspBody->skill_book_end.type = htonl(skill_book.type);
    rspBody->skill_book_end.count = htonl(skill_book.count);
    rspBody->silver_balance = htonl(silver_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}

bool ProcServerThread::checkAndSkillLevelUp(unsigned int main_hero_id
    , unsigned int owner_hero_id, unsigned int skill_id
    , unsigned int& new_skill_level,unsigned int & silver_balance,ItemInfo& skill_book)
{
    //首先查询skill的现有等级
    unsigned int skill_type = 0;;
    unsigned int skill_level = 0;
    bool is_equiped = false;
    {
        char sql[1024];
        sprintf(sql, "select skill_type, skill_level, is_equiped "
            " from hellgate.skill_in_team where own_hero_id=%u and skill_id=%u"
            , owner_hero_id, skill_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_type = atoi(Mysql_Thread_Conn->GetField("skill_type"));
                skill_level = atoi(Mysql_Thread_Conn->GetField("skill_level"));
                is_equiped = (bool)atoi(Mysql_Thread_Conn->GetField("is_equiped"));
            }
            else
            {
                LogMsg("%s, line %d, owner_hero_id[%u] skill_id[%u] not found"
                        , __FILE__, __LINE__, owner_hero_id, skill_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    new_skill_level = skill_level+1;

    //
    if(skill_level >= SKILL_MAX_LEVEL)
    {
        LogMsg("%s, line %d, owner_hero_id[%u] skill_id[%u] already max_level"
                        , __FILE__, __LINE__, owner_hero_id, skill_id);
        return false;
    }


    //查询技能书
    skill_book.type = ItemsType_SkillBook_MinId + skill_type;
    skill_book.count = getItemCountInTeam(main_hero_id, skill_book.type);

    if(skill_book.count < 1)
    {
#ifdef _DEBUG
LogMsg("%s, line %d,skill levelup skillbook[%u] not enought", __FILE__, __LINE__, skill_book.type);
#endif //_DEBUG

        return false;
    }

    //查询银币
    silver_balance = getItemCountInTeam(main_hero_id, ItemsType_Silver);

    if(silver_balance < CS::skillLevelUpNeedSilver(new_skill_level))
    {
#ifdef _DEBUG
LogMsg("%s, line %d,levelup silver_balance=[%d]", __FILE__, __LINE__, silver_balance);
#endif //_DEBUG

        return false;
    }

    //升级
    {
        char sql[1024];
        sprintf(sql, "update hellgate.skill_in_team "
            " set skill_level=%u "
            " where own_hero_id=%u and skill_id=%u"
            , new_skill_level, owner_hero_id, skill_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
    }


    //扣钱
    silver_balance -= CS::skillLevelUpNeedSilver(new_skill_level);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_balance, main_hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //扣道具
    skill_book.count--;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , skill_book.count, main_hero_id, skill_book.type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(is_equiped) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(owner_hero_id);
    }

    return true;
}

void ProcServerThread::DealWithGetZhuangbeiAlbum(Packet * pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealWithGetZhuangbeiAlbum", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetZhuangbeiAlbum* query = (SPCmd_GetZhuangbeiAlbum*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetZhuangbeiAlbum))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query->profession = ntohl(query->profession);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    std::vector<__DuanzaoGroupZBInfo> legend_vec;
    std::vector<__DuanzaoGroupZBInfo> xiyou_vec;
    if(!query_zhuangbei_album(main_hero_id, query->profession, 
        legend_vec, xiyou_vec)) 
    {
    
        int rspDataLen = sizeof(SPCmd_GetZhuangbeiAlbumRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = getZhuangbeiAlbumRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_GetZhuangbeiAlbumRsp* rspBody = (SPCmd_GetZhuangbeiAlbumRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        return;
    }


    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetZhuangbeiAlbumRsp) 
            + sizeof(DuanzaoGroupZBInfo) *(legend_vec.size() +xiyou_vec.size());
    for(int i=0; i<legend_vec.size(); ++i)
    {
        for(int j=0; j<legend_vec[i].attr_vec.size(); ++j)
        {
            rspDataLen += legend_vec[i].attr_vec[j].length()+1;
        }

        rspDataLen += legend_vec[i].desc.length()+1;
    }
    for(int i=0; i<xiyou_vec.size(); ++i)
    {
        for(int j=0; j<xiyou_vec[i].attr_vec.size(); ++j)
        {
            rspDataLen += xiyou_vec[i].attr_vec[j].length()+1;
        }

        rspDataLen += xiyou_vec[i].desc.length()+1;
    }
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getZhuangbeiAlbumRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetZhuangbeiAlbumRsp* rspBody = (SPCmd_GetZhuangbeiAlbumRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->legend_count = htonl(legend_vec.size());
    rspBody->xiyou_count = htonl(xiyou_vec.size());


    unsigned int zb_len;
    char *tmp_p = rspBody->zb_arr;
    DuanzaoGroupZBInfo* p = (DuanzaoGroupZBInfo*)tmp_p;

    for(int i=0; i<legend_vec.size(); ++i)
    {
        legend_vec[i].convert2ZBInfoAndHton(p, zb_len);
        tmp_p += zb_len;
        p = (DuanzaoGroupZBInfo*)(tmp_p);
    }
    
    for(int i=0; i<xiyou_vec.size(); ++i)
    {
        xiyou_vec[i].convert2ZBInfoAndHton(p, zb_len);
        tmp_p += zb_len;
        p = (DuanzaoGroupZBInfo*)(tmp_p);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


void ProcServerThread::DealwithQueryBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryBonus* get = (SPCmd_QueryBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->type = ntohl(get->type);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //查询奖励池
    std::vector<__BonusInfo> bonus_vec[BonusType_Reward];
    bool result_flag = query_bonus(main_hero_id, get->type, bonus_vec);

    int total_length = 0; //计算奖励总长度
    for(int i=0; i<BonusType_Reward; ++i) {
        for(int j=0; j<bonus_vec[i].size(); ++j) {
            total_length += bonus_vec[i][j].get_length();
        }
    }

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryBonusRsp) + total_length;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryBonusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryBonusRsp* rspBody = (SPCmd_QueryBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    for(int i=0; i<BonusType_Reward; ++i) {
        rspBody->type[i] = htonl(i+1);
        rspBody->count[i] = htonl(bonus_vec[i].size());
    }

    char * tmp_p = rspBody->bonus_arr;
    BonusInfo* p = (BonusInfo*)tmp_p;
    for(int i=0; i<BonusType_Reward; ++i) {
        for(int j=0; j<bonus_vec[i].size(); ++j) {
            unsigned int bonus_out_len = 0;
            bonus_vec[i][j].convert2_bonus_info_hton(p, bonus_out_len);
            tmp_p += bonus_out_len;
            p = (BonusInfo*) (tmp_p);
        }
    }

    for(int i=0; i<BonusType_Reward; ++i) {
        bonus_vec[i].clear();
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetBonus* get = (SPCmd_GetBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->type = ntohl(get->type);
        get->id = ntohl(get->id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    bool result_flag = check_and_get_bonus(main_hero_id, get->type, get->id, zhuangbei_vec);

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetBonusRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getBonusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetBonusRsp* rspBody = (SPCmd_GetBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->type = htonl(get->type);
    rspBody->id = htonl(get->id);
    rspBody->zb_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->detail, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetChessBox(Packet * pack)
{
#if 0
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetChessBox", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetChessBox* get = (SPCmd_GetChessBox*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetChessBox))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->task_id = ntohl(get->task_id);
        get->grid_id = ntohl(get->grid_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    std::vector<ItemInfo> item_vec;
    bool result_flag = check_and_get_chess_box(main_hero_id, get->task_id, get->grid_id, item_vec);

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetChessBoxRsp) + sizeof(ItemInfo)*item_vec.size();
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getChessBoxRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetChessBoxRsp* rspBody = (SPCmd_GetChessBoxRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->count = htonl(item_vec.size());

    ItemInfo* p = rspBody->item_arr;
    for(int i=0; i<item_vec.size(); ++i, ++p) {
        p->type = htonl(item_vec[i].type);
        p->count = htonl(item_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
#endif
}


void ProcServerThread::DealwithQueryRateTask(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryRateTask", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryRateTask* get = (SPCmd_QueryRateTask*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryRateTask))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    std::vector<RateStarInfo> task_star_vec;
    std::vector<RateStarInfo> chap_star_vec;
    { //查询英雄关卡评级状态
        char sql[1024];
        sprintf(sql, "select * from hellgate.rate_task_stat "
            " where hero_id=%u order by task_id "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                RateStarInfo info;
                info.star = atoi(Mysql_Thread_Conn->GetField("star"));
                info.is_get_cuprum = atoi(Mysql_Thread_Conn->GetField("is_get_cuprum"));
                info.is_get_silver = atoi(Mysql_Thread_Conn->GetField("is_get_silver"));
                info.is_get_gold = atoi(Mysql_Thread_Conn->GetField("is_get_gold"));
                
                task_star_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
        //查询英雄章节评级状态
        sprintf(sql, "select * from hellgate.rate_chapter_stat "
            " where hero_id=%u order by task_id "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                RateStarInfo info;
                info.star = atoi(Mysql_Thread_Conn->GetField("star"));
                if(info.star >= 2) { //章节评级没有银星 2就表示是金星
                    info.star = RateStarLevel_Gold;
                }
                
                info.is_get_cuprum = atoi(Mysql_Thread_Conn->GetField("is_get_cuprum"));
                info.is_get_silver = atoi(Mysql_Thread_Conn->GetField("is_get_silver"));
                info.is_get_gold = atoi(Mysql_Thread_Conn->GetField("is_get_gold"));
                
                chap_star_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + sizeof(SPCmd_QueryRateTaskRsp)];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryRateTaskRsp;
    (rspHead)->data_len = sizeof(SPCmd_QueryRateTaskRsp);
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryRateTaskRsp* rspBody = (SPCmd_QueryRateTaskRsp*)((rspHead)+1);
    bzero(rspBody, sizeof(SPCmd_QueryRateTaskRsp));
    
    rspBody->err_code = htonl(Success);
    
    //因为表中可能没写入当前关卡的星级 所以提前加一个关卡
    unsigned int task_size = task_star_vec.size();
    if(task_size < MAX_TASK_NUM) task_size++;
    
    rspBody->task_max = htons(task_size);
    rspBody->chap_max = htons(chap_star_vec.size());

    for(int i=0; i<task_star_vec.size() && i<MAX_TASK_NUM; ++i) {
        rspBody->task_info[i].star = htons(task_star_vec[i].star);
        rspBody->task_info[i].is_get_cuprum = task_star_vec[i].is_get_cuprum;
        rspBody->task_info[i].is_get_silver = task_star_vec[i].is_get_silver;
        rspBody->task_info[i].is_get_gold = task_star_vec[i].is_get_gold;
    }
    
    for(int i=0; i<chap_star_vec.size() && i<MAX_CHAPTER_NUM; ++i) {
        rspBody->chap_info[i].star = htons(chap_star_vec[i].star);
        rspBody->chap_info[i].is_get_cuprum = chap_star_vec[i].is_get_cuprum;
        rspBody->chap_info[i].is_get_silver = chap_star_vec[i].is_get_silver;
        rspBody->chap_info[i].is_get_gold = chap_star_vec[i].is_get_gold;
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

struct __RateBonus {
    RateStarLevel star;		//RateStarLevel 星级 
    unsigned int exp;			//奖励经验 0:没有此奖励, >0:有经验
    std::vector<ItemInfo> item_vec;
};
void ProcServerThread::DealwithQueryRateTaskBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryRateTaskBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryRateTaskBonus* get = (SPCmd_QueryRateTaskBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryRateTaskBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->type = ntohs(get->type);
        get->task_id = ntohs(get->task_id);
    }

    //unsigned int main_hero_id = pack->main_hero_id;
    
    std::vector<__RateBonus> rate_vec;
    if(RateStarType_Task == get->type || RateStarType_Chapter == get->type){ //查询关卡评级奖励模板中的奖励内容
        char sql[1024];
        if(get->type == RateStarType_Task) {
            sprintf(sql, "select * from hellgate.rate_task_temp "
                " where task_id=%u order by star, item_type "
                , get->task_id);
        }
        else {
            sprintf(sql, "select * from hellgate.rate_chapter_temp "
                " where task_id=%u order by star, item_type "
                , get->task_id);
        }
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int star_id = atoi(Mysql_Thread_Conn->GetField("star"));

                if(get->type == RateStarType_Chapter && star_id>=2) {
                    //章节评级没有银星 2就表示是金星
                    star_id = RateStarLevel_Gold;
                }
                
                int pos = -1;
                for(int i=0; i<rate_vec.size(); ++i) {
                    if(rate_vec[i].star == star_id) {
                        pos = i;    //找到 退出
                        break;
                    }
                }

                if(pos == -1) {
                    __RateBonus tmp;
                    tmp.star = (RateStarLevel)star_id;
                    tmp.exp = atoi(Mysql_Thread_Conn->GetField("exp"));
                    
                    rate_vec.push_back(tmp);
                    pos = rate_vec.size() -1;
                }

                ItemInfo item;
                item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                
                if(item.count > 0){
                    rate_vec[pos].item_vec.push_back(item);
                }
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    int total_item_count = 0;
    for(int i=0; i<rate_vec.size(); ++i) {
        total_item_count += rate_vec[i].item_vec.size();
    }
        
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryRateTaskBonusRsp)
        + sizeof(RateBonus) *sizeof(rate_vec.size()) + sizeof(ItemInfo) *total_item_count;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryRateTaskBonusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryRateTaskBonusRsp* rspBody = (SPCmd_QueryRateTaskBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    
    rspBody->bonus_count = htons(rate_vec.size());

    RateBonus *bonus_p = rspBody->bonus_arr;
    //char *tmp_p = (char*)bonus_p;
    for(int i=0; i<rate_vec.size(); ++i) {
        bonus_p->star = htons(rate_vec[i].star);
        bonus_p->exp = htonl(rate_vec[i].exp);
        bonus_p->item_count = htons(rate_vec[i].item_vec.size());

        ItemInfo *p = (ItemInfo*)(&bonus_p->item_count +1);
        for(int j=0; j<rate_vec[i].item_vec.size(); ++j, ++p) {
            p->type = htonl(rate_vec[i].item_vec[j].type);
            p->count = htonl(rate_vec[i].item_vec[j].count);
        }

        //tmp_p += (sizeof(RateBonus) + sizeof(ItemInfo) *rate_vec[i].item_vec.size());
        bonus_p = (RateBonus*)p;
    }
   
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetRateTaskBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetRateTaskBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetRateTaskBonus* get = (SPCmd_GetRateTaskBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetRateTaskBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->type = ntohs(get->type);
        get->task_id = ntohs(get->task_id);
        get->star = ntohs(get->star);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    bool result_flag = get_ratetask_bonus(main_hero_id, get->type, get->task_id, get->star);
       
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + sizeof(SPCmd_GetRateTaskBonusRsp)];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getRateTaskBonusRsp;
    (rspHead)->data_len = sizeof(SPCmd_GetRateTaskBonusRsp);
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetRateTaskBonusRsp* rspBody = (SPCmd_GetRateTaskBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}


void ProcServerThread::DealwithQueryVipPrivilege(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryVipPrivilege", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryVipPrivilege* get = (SPCmd_QueryVipPrivilege*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryVipPrivilege))
    {
        return;
    }

    //将包体转换为本机字节序
    {
         get = get;
    }
    

    unsigned int main_hero_id = pack->main_hero_id;

    //刷新英雄特权信息
    refreshHeroVipInfo(main_hero_id);

    VIP_Info def_info, cur_info;
    
    {//查询当前vip信息
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.hero_vip_info where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                //v_info.total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                cur_info.level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                cur_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                cur_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                cur_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                cur_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                cur_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                cur_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                cur_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u] not exist"
                        , __FILE__, __LINE__, main_hero_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    {//查询默认vip信息
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.vip_template where level=%u"
            , cur_info.level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                //def_info.total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                //def_info.level = atoi(Mysql_Thread_Conn->GetField("level"));
                def_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                def_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                def_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                def_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                def_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                def_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                def_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u] vip level[%u] not exist"
                        , __FILE__, __LINE__, main_hero_id, cur_info.level);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + sizeof(SPCmd_QueryVipPrivilegeRsp)];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryVipPrivilegeRsp;
    (rspHead)->data_len = sizeof(SPCmd_QueryVipPrivilegeRsp);
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryVipPrivilegeRsp* rspBody = (SPCmd_QueryVipPrivilegeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    VipPrivilegeInfo *p = &(rspBody->deft_info);
    def_info.convert2VipInfoAndHton(p);

    p = &(rspBody->priv_info);
    cur_info.convert2VipInfoAndHton(p);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}


void ProcServerThread::DealwithUpgradeShenbing(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithUpgradeShenbing", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_UpgradeShenbing* get = (SPCmd_UpgradeShenbing*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_UpgradeShenbing))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->zb_id = Utl::htonll(get->zb_id);
        get->cailiao_zb_id = Utl::htonll(get->cailiao_zb_id);
    }
    

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<ItemInfo> cailiao_vec;
    if(!check_and_upgrade_shenbing(main_hero_id, get->zb_id, get->cailiao_zb_id
        , cailiao_vec))
    {
        //
        SPHead* rspHead;
        int rspDataLen = sizeof(SPCmd_UpgradeShenbingRsp);
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = upgradeShenbingRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_UpgradeShenbingRsp* rspBody = (SPCmd_UpgradeShenbingRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);
        
        
        return;
    }

    __ZhuangbeiDetail detail;
    unsigned int owner_id;
    getZhuangbeiDetail(get->zb_id, owner_id, detail);
    
    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    detail.convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)zhuangbei_detail_data, zhuangbei_detail_data_len);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_UpgradeShenbingRsp) +zhuangbei_detail_data_len;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = upgradeShenbingRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_UpgradeShenbingRsp* rspBody = (SPCmd_UpgradeShenbingRsp*)((rspHead)+1);
    bzero(rspBody, rspDataLen);
    rspBody->err_code = htonl(Success);
    
    ItemInfo *p = rspBody->item_arr;
    for(int i=0; i<cailiao_vec.size() && i<5; i++, p++){
        p->type = htonl(cailiao_vec[i].type);
        p->count = htonl(cailiao_vec[i].count);
    }

    memcpy(rspBody->detail, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

}


void ProcServerThread::DealwithUnlockAssistant(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithUnlockAssistant", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_UnlockAssistant* get = (SPCmd_UnlockAssistant*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_UnlockAssistant))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->assistant_id = ntohl(get->assistant_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    unsigned int honor_balance = 0;
    bool result_flag = check_and_unlock_assistant(main_hero_id, get->assistant_id, honor_balance);

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_UnlockAssistantRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = unlockAssistantRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_UnlockAssistantRsp* rspBody = (SPCmd_UnlockAssistantRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->honor = htonl(honor_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
        
}


void ProcServerThread::DealwithQueryGiftActivity(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryGiftActivity", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryGiftActivity* get = (SPCmd_QueryGiftActivity*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryGiftActivity))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<ActivityInfo> info_vec;
    bool result_flag = query_gift_activity(main_hero_id, info_vec);

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryGiftActivityRsp) + sizeof(ActivityInfo)*info_vec.size();
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryGiftActivityRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryGiftActivityRsp* rspBody = (SPCmd_QueryGiftActivityRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->count = htonl(info_vec.size());

    ActivityInfo *p = rspBody->act_arr;
    for(int i=0; i<info_vec.size(); i++, p++) {
        p->id = htonl(info_vec[i].id);
        p->is_get = info_vec[i].is_get;
        p->open_time = htonl(info_vec[i].open_time);
        p->close_time = htonl(info_vec[i].close_time);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
        
}


void ProcServerThread::DealwithGetGiftActivity(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetGiftActivity", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetGiftActivity* get = (SPCmd_GetGiftActivity*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetGiftActivity))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->id = ntohl(get->id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    bool result_flag = check_and_get_activity(main_hero_id, get->id);

    unsigned int vit_current = 0;
    {//查询现有体力
        char sql[1024];
        //
        sprintf(sql, "select vit_current "
            " from hellgate.hero_infor where hero_id=%u"
            , main_hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                vit_current = atoi(Mysql_Thread_Conn->GetField("vit_current"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetGiftActivityRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getGiftActivityRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetGiftActivityRsp* rspBody = (SPCmd_GetGiftActivityRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->vit_current = htonl(vit_current);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
        
}


void ProcServerThread::DealwithQueryKilledMonster(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryKilledMonster", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryKilledMonster* get = (SPCmd_QueryKilledMonster*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryKilledMonster))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    
    unsigned int common_count = 0;
    unsigned int elite_count = 0;
    bool is_not_exist = false;
    { //查询击杀怪物数量
        char sql[1024];
        sprintf(sql, "select common_monster_count, elite_monster_count "
            " from hellgate.hero_killed_monster where hero_id=%u "
            , main_hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                common_count = atoi(Mysql_Thread_Conn->GetField("common_monster_count"));
                elite_count = atoi(Mysql_Thread_Conn->GetField("elite_monster_count"));
            }
            else {
                is_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    if(is_not_exist){ //没有记录 插入新纪录
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_killed_monster set "
            " hero_id=%u, common_monster_count=0, elite_monster_count=0 "
            , main_hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryKilledMonsterRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryKilledMonsterRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryKilledMonsterRsp* rspBody = (SPCmd_QueryKilledMonsterRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->common_monster_count = htonl(common_count);
    rspBody->elite_monster_count = htonl(elite_count);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
        
}


void ProcServerThread::DealwithQueryKilledMonsterBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryKilledMonsterBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryKilledMonsterBonus* get = (SPCmd_QueryKilledMonsterBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryKilledMonsterBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    //unsigned int main_hero_id = pack->main_hero_id;

    std::vector<ItemInfo> common_vec;
    std::vector<ItemInfo> elite_vec;
    {//查询击杀小怪奖励
        char sql[1024];
        //
        sprintf(sql, "select type, item_type, item_count "
            " from hellgate.killed_monster_bonus_temp order by type ");
        try {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                ItemInfo info;
                int type = atoi(Mysql_Thread_Conn->GetField("type"));
                info.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                info.count = atoi(Mysql_Thread_Conn->GetField("item_count"));

                if(type == Accumulate_Common_Monster) {
                    if(info.count > 0) {
                        common_vec.push_back(info); 
                    }
                }
                else if(type == Accumulate_Elite_Monster) {
                    if(info.count > 0) {
                        elite_vec.push_back(info); 
                    }
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryKilledMonsterBonusRsp) + 
        sizeof(ItemInfo)*(common_vec.size() + elite_vec.size());
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryKilledMonsterBonusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryKilledMonsterBonusRsp* rspBody = (SPCmd_QueryKilledMonsterBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->common_bonus_count = htonl(common_vec.size());
    rspBody->elite_bonus_count = htonl(elite_vec.size());

    ItemInfo *p = rspBody->item_arr;

    for(int i=0; i<common_vec.size(); i++){
        p->type = htonl(common_vec[i].type);
        p->count = htonl(common_vec[i].count);
        p++;
    }
    for(int i=0; i<elite_vec.size(); i++){
        p->type = htonl(elite_vec[i].type);
        p->count = htonl(elite_vec[i].count);
        p++;
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
        
}


void ProcServerThread::DealwithGetKilledMonsterBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetKilledMonsterBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetKilledMonsterBonus* get = (SPCmd_GetKilledMonsterBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetKilledMonsterBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->type = ntohl(get->type);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    bool result_flag = check_and_get_killed_monster_bonus(main_hero_id, get->type);

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_GetKilledMonsterBonusRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getKilledMonsterBonusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetKilledMonsterBonusRsp* rspBody = (SPCmd_GetKilledMonsterBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
        
}


void ProcServerThread::DealwithCastSilver(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCastSilver", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CastSilver* cast = (SPCmd_CastSilver*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CastSilver))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        cast = cast;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int gold_balance;
    unsigned int silver_balance;
    bool result_flag = check_and_cast_silver(main_hero_id, gold_balance, silver_balance);
    
    //
    int rspDataLen = sizeof(SPCmd_CastSilverRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = castSilverRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CastSilverRsp* rspBody = (SPCmd_CastSilverRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->gold_balance = htonl(gold_balance);
    rspBody->silver_balance = htonl(silver_balance);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryLegendNote(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryLegendNote", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryLegendNote* query = (SPCmd_QueryLegendNote*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryLegendNote))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int last_refresh_time = 0;
    unsigned int times = 0;
    bool is_not_exist = false;
    { //查询剩余次数
        char sql[1024];
        sprintf(sql, "select refresh_timestamp, time_remainder from hellgate.hero_legend_note_info "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                last_refresh_time = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                times = atoi(Mysql_Thread_Conn->GetField("time_remainder"));
            } 
            else {
                is_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    if(is_not_exist) { //记录不存在 插入新纪录
        times = MAX_CHALLENGE_LEGEND_NOTE_TIMES;
        
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_legend_note_info set "
            " hero_id=%u, refresh_timestamp=%u, time_remainder=%u, drop_times=0, is_first=0 "
            , main_hero_id
            , (unsigned int)time(NULL)
            , times);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    else {
        //新的一天刷新 次数和掉落
        if(isNeedSystemDailyRefresh(last_refresh_time, SystemDailyTask_Hour)) { 
            times = MAX_CHALLENGE_LEGEND_NOTE_TIMES;
            
            char sql[1024];
            sprintf(sql, "update hellgate.hero_legend_note_info set "
                " refresh_timestamp=%u, time_remainder=%u, drop_times=0 "
                " where hero_id=%u "
                , (unsigned int)time(NULL)
                , times
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                exit(1);
            }
        }
    }
    
    //
    int rspDataLen = sizeof(SPCmd_QueryLegendNoteRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryLegendNoteRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryLegendNoteRsp* rspBody = (SPCmd_QueryLegendNoteRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->times = htonl(times);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithChallengeLegendNote(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChallengeLegendNote", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ChallengeLegendNote* chl = (SPCmd_ChallengeLegendNote*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ChallengeLegendNote))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        chl->group_id = ntohl(chl->group_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    int script_len = 0;
    char *fight_script = NULL;
    bool result_flag = check_and_challenge_legend_note(main_hero_id, chl->group_id, 
        &fight_script, script_len);

    //
    int rspDataLen = sizeof(SPCmd_ChallengeLegendNoteRsp) + script_len;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = challengeLegendNoteRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ChallengeLegendNoteRsp* rspBody = (SPCmd_ChallengeLegendNoteRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    memcpy(rspBody->fight_script, fight_script, script_len);
    delete fight_script;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQuerySelfChallengeInfo(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQuerySelfChallengeInfo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QuerySelfChallengeInfo* qry = (SPCmd_QuerySelfChallengeInfo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QuerySelfChallengeInfo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int last_refresh_time = 0;
    SelfChlgInfo info;
    bzero(&info, sizeof(SelfChlgInfo));

    bool is_not_exist = false;
    {//查询英雄自我挑战状态
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.self_challenge_hero "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                last_refresh_time = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                info.times = atoi(Mysql_Thread_Conn->GetField("time_remainder"));
                info.b_on_the_way = (bool)atoi(Mysql_Thread_Conn->GetField("b_on_the_way"));
                
                info.energy = atoi(Mysql_Thread_Conn->GetField("energy"));
                info.hp_gain = atoi(Mysql_Thread_Conn->GetField("hp_gain"));
                info.attack_gain = atoi(Mysql_Thread_Conn->GetField("attack_gain"));
                info.defense_gain = atoi(Mysql_Thread_Conn->GetField("defense_gain"));
                
                info.difficulty = atoi(Mysql_Thread_Conn->GetField("difficulty"));
                info.checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));
            }
            else {
                is_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    const int const_max_times = 3;
    if(is_not_exist) { //记录不存在 插入新纪录
        info.times = const_max_times;
        
        char sql[1024];
        sprintf(sql, "insert into hellgate.self_challenge_hero set "
            " hero_id=%u, "
            " refresh_timestamp=%u, time_remainder=%u, b_on_the_way=0, "
            " hp_gain=0, attack_gain=0, defense_gain=0, "
            " energy=0, difficulty=0, checkpoints=0, died_point=0 "
            , main_hero_id
            , (unsigned int)time(NULL)
            , info.times);
        try
        {
            Mysql_Thread_Conn->Query(sql);            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

    }
    else if(isNeedSystemDailyRefresh(last_refresh_time, SystemDailyTask_Hour)) {
        //新的一天 刷新
        bzero(&info, sizeof(SelfChlgInfo));
        info.times = const_max_times;
        {
            char sql[1024];
            sprintf(sql, "update hellgate.self_challenge_hero set "
                " refresh_timestamp=%u, time_remainder=%u, b_on_the_way=0, "
                " hp_gain=0, attack_gain=0, defense_gain=0, "
                " energy=0, difficulty=0, checkpoints=0, died_point=0 "
                " where hero_id=%u "
                , (unsigned int)time(NULL)
                , info.times
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);            
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    //
    int rspDataLen = sizeof(SPCmd_QuerySelfChallengeInfoRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = querySelfChallengeInfoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QuerySelfChallengeInfoRsp* rspBody = (SPCmd_QuerySelfChallengeInfoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    
    time_t t = time(NULL);
    tm *p_tm = localtime(&t);
    p_tm->tm_hour = SELF_CHALLENGE_OPEN_HOUR;
    p_tm->tm_min = 0;
    p_tm->tm_sec = 1;
    time_t open_time = mktime(p_tm);

    p_tm->tm_mday ++;
    p_tm->tm_hour = SELF_CHALLENGE_CLOSE_HOUR;
    p_tm->tm_min = 0;
    p_tm->tm_sec = 0;
    time_t close_time = mktime(p_tm);

    
    rspBody->open_time = htonl((unsigned int)open_time);
    rspBody->close_time = htonl((unsigned int)close_time);
    
    rspBody->info.b_on_the_way = info.b_on_the_way;
    rspBody->info.times = htonl(info.times);
    rspBody->info.energy = htonl(info.energy);
    rspBody->info.hp_gain = htonl(info.hp_gain);
    rspBody->info.attack_gain = htonl(info.attack_gain);
    rspBody->info.defense_gain = htonl(info.defense_gain);
    rspBody->info.difficulty = htonl(info.difficulty);
    rspBody->info.checkpoints = htonl(info.checkpoints);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQuerySelfChallengeOrder(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQuerySelfChallengeOrder", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QuerySelfChallengeOrder* qry = (SPCmd_QuerySelfChallengeOrder*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QuerySelfChallengeOrder))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry->difficulty = ntohl(qry->difficulty);
    }

    //unsigned int main_hero_id = pack->main_hero_id;

    std::vector<SelfChlgOrder> order_vec;
    unsigned int bonus_def_id = 0;
    char table_str[64];
    bool result_flag = false;
    if((qry->difficulty > SelfChlgDiffType_NULL) 
        && (qry->difficulty <= SelfChlgDiffType_Nightmare)) { //难度正确
        result_flag = true;
        
        if(qry->difficulty == SelfChlgDiffType_Common) {
            sprintf(table_str, "self_challenge_order_common");
            bonus_def_id = EmailID_SelfChlgOrderCommon_1;
        }
        else if(qry->difficulty == SelfChlgDiffType_Difficult) {
            sprintf(table_str, "self_challenge_order_difficult");
            bonus_def_id = EmailID_SelfChlgOrderDifficult_1;
        }
        else if(qry->difficulty == SelfChlgDiffType_Hell) {
            sprintf(table_str, "self_challenge_order_hell");
            bonus_def_id = EmailID_SelfChlgOrderHell_1;
        }
        else {
            sprintf(table_str, "self_challenge_order_nightmare");
            bonus_def_id = EmailID_SelfChlgOrderNightmare_1;
        }

        
        char sql[1024];
        sprintf(sql, "select * from hellgate.%s "
            " where hero_order<=10 order by hero_order "
            , table_str);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                SelfChlgOrder info;
                bzero(&info, sizeof(SelfChlgOrder));
                info.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                info.order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
                info.checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));

                order_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    for(int i=0; i<order_vec.size(); i++) { //填充英雄信息
        GetHeroBasicInfo(order_vec[i].hero_info.hero_id, order_vec[i].hero_info);

        //填充奖励信息
        unsigned int bonus_id = bonus_def_id;
        if(order_vec[i].order >= 4)
            bonus_id += 3;
        else if(order_vec[i].order == 3) 
            bonus_id += 2;
        else if(order_vec[i].order == 2) 
            bonus_id += 1;

        std::map<unsigned int, __EmailInfo>::iterator pos = m_email_internal_map.find(bonus_id);
        if(pos != m_email_internal_map.end()) {
            if(!pos->second.item_vec.empty()) {
                order_vec[i].item = pos->second.item_vec[0];
            }
        }
    }

    //
    int rspDataLen = sizeof(SPCmd_QuerySelfChallengeOrderRsp) 
        + sizeof(SelfChlgOrder)*order_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = querySelfChallengeOrderRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QuerySelfChallengeOrderRsp* rspBody = (SPCmd_QuerySelfChallengeOrderRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->count = htonl(order_vec.size());
    SelfChlgOrder *p = rspBody->order_arr;
    for(int i=0; i<order_vec.size(); i++, p++) { 
        hton_hero_info(order_vec[i].hero_info, p->hero_info);
        p->order = htonl(order_vec[i].order);
        p->checkpoints = htonl(order_vec[i].checkpoints);
        p->item.type = htonl(order_vec[i].item.type);
        p->item.count = htonl(order_vec[i].item.count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithSelfChallenge(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithSelfChallenge", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_SelfChallenge* chl = (SPCmd_SelfChallenge*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_SelfChallenge))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        chl->difficulty = ntohl(chl->difficulty);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int energy, checkpoints, silver;
    bool is_have_box = false;
    int script_len = 0;
    char *fight_script = NULL;
    GiftBag gift_bag;
    bool result_flag = check_and_self_challenge(main_hero_id, chl->difficulty, 
        energy, checkpoints, is_have_box, silver, gift_bag, &fight_script, script_len);

    //
    int rspDataLen = sizeof(SPCmd_SelfChallengeRsp) + script_len;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = selfChallengeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SelfChallengeRsp* rspBody = (SPCmd_SelfChallengeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->energy = htonl(energy);
    rspBody->checkpoints = htonl(checkpoints);
    rspBody->is_have_box = is_have_box;
    rspBody->silver = htonl(silver);
    
    rspBody->gift_bag.id = htonl(gift_bag.id);
    rspBody->gift_bag.count = htonl(gift_bag.count);
    
    memcpy(rspBody->fight_script, fight_script, script_len);
    delete fight_script;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithSelfChallengeGain(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithSelfChallengeGain", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_SelfChallengeGain* gn = (SPCmd_SelfChallengeGain*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_SelfChallengeGain))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        gn->type = ntohl(gn->type);
        gn->degree = ntohl(gn->degree);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int energy, hp_gain, attack_gain, defense_gain;
    bool result_flag = check_and_gain_self_challenge(main_hero_id, gn->type, gn->degree,
        energy, hp_gain, attack_gain, defense_gain);

    //
    int rspDataLen = sizeof(SPCmd_SelfChallengeGainRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = selfChallengeGainRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SelfChallengeGainRsp* rspBody = (SPCmd_SelfChallengeGainRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->energy = htonl(energy);
    rspBody->hp_gain = htonl(hp_gain);
    rspBody->attack_gain = htonl(attack_gain);
    rspBody->defense_gain = htonl(defense_gain);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetSelfChallengeBox(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetSelfChallengeBox", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetSelfChallengeBox* get = (SPCmd_GetSelfChallengeBox*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetSelfChallengeBox))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get = get;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    ItemInfo item;
    std::vector<ItemInfo> item_vec;
    bool result_flag = check_and_get_self_challenge_box(main_hero_id, item, item_vec);

    //
    int rspDataLen = sizeof(SPCmd_GetSelfChallengeBoxRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getSelfChallengeBoxRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetSelfChallengeBoxRsp* rspBody = (SPCmd_GetSelfChallengeBoxRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->item.type = htonl(item.type);
    rspBody->item.count = htonl(item.count);

    for(int i=0; i<item_vec.size()&&i<2; i++) {
        rspBody->item_arr[i].type = htonl(item_vec[i].type);
        rspBody->item_arr[i].count = htonl(item_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryProtectSpirit(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryProtectSpirit", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryProtectSpirit* qry = (SPCmd_QueryProtectSpirit*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryProtectSpirit))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry->chapter = ntohl(qry->chapter);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    HeroInfo first_spirit;
    ProtectSpiritInfo current_spirit;
    bool is_worship, is_loser;
    bool result_flag = query_protect_spirit(main_hero_id, qry->chapter,
        first_spirit, current_spirit, is_worship, is_loser);

    //
    int rspDataLen = sizeof(SPCmd_QueryProtectSpiritRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryProtectSpiritRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryProtectSpiritRsp* rspBody = (SPCmd_QueryProtectSpiritRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->is_loser = is_loser;
    rspBody->is_worship = is_worship;
    hton_hero_info(first_spirit, rspBody->first_spirit);
    ProtectSpiritInfo *p = &rspBody->current_spirit;

    p->spirit_id = htonl(current_spirit.spirit_id);
    p->profession_id = htonl(current_spirit.profession_id);
    p->defend_time = htonl(current_spirit.defend_time);
    p->level = htonl(current_spirit.level);
    memcpy(p->name, current_spirit.name, HeroNameMaxLen +1);
    p->is_get = current_spirit.is_get;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithChallengeProtectSpirit(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithChallengeProtectSpirit", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ChallengeProtectSpirit* chl = (SPCmd_ChallengeProtectSpirit*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ChallengeProtectSpirit))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        chl->chapter = ntohl(chl->chapter);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    int script_len = 0;
    char *fight_script = NULL;
    bool result_flag = challenge_protect_spirit(main_hero_id, chl->chapter, &fight_script, script_len);

    //
    int rspDataLen = sizeof(SPCmd_ChallengeProtectSpiritRsp) + script_len;
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = challengeProtectSpiritRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ChallengeProtectSpiritRsp* rspBody = (SPCmd_ChallengeProtectSpiritRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    memcpy(rspBody->fight_script, fight_script, script_len);
    delete fight_script;


    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetProtectSpiritBonus(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetProtectSpiritBonus", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetProtectSpiritBonus* get = (SPCmd_GetProtectSpiritBonus*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetProtectSpiritBonus))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->chapter = ntohl(get->chapter);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    std::vector<ItemInfo> item_vec;
    bool result_flag = check_and_get_protect_spirit_bonus(main_hero_id, get->chapter, item_vec);

    //
    int rspDataLen = sizeof(SPCmd_GetProtectSpiritBonusRsp) + sizeof(ItemInfo)*item_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getProtectSpiritBonusRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetProtectSpiritBonusRsp* rspBody = (SPCmd_GetProtectSpiritBonusRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->item_count = htons(item_vec.size());
    for(int i=0; i<item_vec.size(); ++i) {
        rspBody->item_arr[i].type = htonl(item_vec[i].type);
        rspBody->item_arr[i].count = htonl(item_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithWorshiProtectSpirit(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithWorshiProtectSpirit", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_WorshiProtectSpirit* wrp = (SPCmd_WorshiProtectSpirit*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_WorshiProtectSpirit))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        wrp->chapter = ntohl(wrp->chapter);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    GiftBag gift_bag;
    bool result_flag = check_and_worship_protect_spirit(main_hero_id, wrp->chapter, gift_bag);
    
    //
    int rspDataLen = sizeof(SPCmd_WorshiProtectSpiritRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = worshiProtectSpiritRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_WorshiProtectSpiritRsp* rspBody = (SPCmd_WorshiProtectSpiritRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->gift_bag.id = htonl(gift_bag.id);
    rspBody->gift_bag.count = htonl(gift_bag.count);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryDiscoverInfo(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryDiscoverInfo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryDiscoverInfo* qry = (SPCmd_QueryDiscoverInfo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryDiscoverInfo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;

	unsigned int remainder_times = 0;
	unsigned int discovered_times = 0;
    unsigned int destroy_seal = 0;
    bool b_not_exist = false;
    unsigned int last_modify_timestamp = 0;
    unsigned int refresh_timestamp = 0;
    unsigned int unlocked_seal = 0;
    { //查询探索信息
        char sql[1024];
        sprintf(sql, "select remainder_times, last_modify_timestamp, "
            " discovered_times, destroy_seal, refresh_timestamp, unlocked_seal "
            " from hellgate.discover_hero where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                remainder_times = atoi(Mysql_Thread_Conn->GetField("remainder_times"));
                discovered_times = atoi(Mysql_Thread_Conn->GetField("discovered_times"));
                destroy_seal = atoi(Mysql_Thread_Conn->GetField("destroy_seal"));
                last_modify_timestamp = atoi(Mysql_Thread_Conn->GetField("last_modify_timestamp"));
                refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                unlocked_seal = atoi(Mysql_Thread_Conn->GetField("unlocked_seal"));
            }
            else {
                b_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);
    unsigned int cur_time = (unsigned int)time(NULL);
    unsigned int limit_times = CS::getDiscoverLimitTimes(hero_info.vip_level);

    if(b_not_exist) { //记录不存在 插入新纪录
        remainder_times = limit_times;
        last_modify_timestamp = cur_time;
        
        char sql[1024];
        sprintf(sql, "insert into hellgate.discover_hero set "
            " hero_id=%u, remainder_times=%u, last_modify_timestamp=%u, "
            " discovered_times=0, is_destroyed=0, destroy_seal=0, refresh_timestamp=%u, "
            " unlocked_seal=0 "
            , main_hero_id
            , remainder_times
            , cur_time
            , cur_time);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else {
        bool b_added = false;
        if(remainder_times < limit_times) { //小于上限
            b_added = true;
            if(cur_time - last_modify_timestamp > Discover_Times_Update_Gap) {
                remainder_times += (cur_time -last_modify_timestamp)/Discover_Times_Update_Gap;
                if(remainder_times > limit_times) {
                    remainder_times = limit_times;
                }
            
                last_modify_timestamp = cur_time;
            }
        }

        bool b_refresh = isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour);
        if(b_refresh) { //需要刷新
            discovered_times = 0;
            last_modify_timestamp = cur_time;
            
            char sql[1024];
            sprintf(sql, "update hellgate.discover_hero set "
                " remainder_times=%u, last_modify_timestamp=%u, "
                " discovered_times=0, is_destroyed=0, refresh_timestamp=%u "
                " where hero_id=%u"
                , remainder_times
                , last_modify_timestamp
                , cur_time
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        else if(b_added) { //需要修改探索次数
            char sql[1024];
            sprintf(sql, "update hellgate.discover_hero set "
                " remainder_times=%u, last_modify_timestamp=%u "
                " where hero_id=%u"
                , remainder_times
                , last_modify_timestamp
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    //
    int rspDataLen = sizeof(SPCmd_QueryDiscoverInfoRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryDiscoverInfoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryDiscoverInfoRsp* rspBody = (SPCmd_QueryDiscoverInfoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->remainder_times = htonl(remainder_times);
    rspBody->discovered_times = htonl(discovered_times);
    rspBody->destroy_seal = htonl(destroy_seal);
    rspBody->unlocked_seal = htonl(unlocked_seal);
    rspBody->last_modify_timestamp = htonl(last_modify_timestamp);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithDiscover(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithDiscover", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Discover* dc = (SPCmd_Discover*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Discover))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        dc->akey_all = dc->akey_all;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    bool is_destroyed;
    unsigned int remainder_times, discovered_times, last_modify_timestamp;
    std::vector<ItemInfo> item_vec;
    bool result_flag = check_and_discover(main_hero_id, dc->akey_all, 
        is_destroyed, remainder_times, discovered_times, last_modify_timestamp, item_vec);

    //
    int rspDataLen = sizeof(SPCmd_DiscoverRsp) + sizeof(ItemInfo)*item_vec.size();
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = discoverRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_DiscoverRsp* rspBody = (SPCmd_DiscoverRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    rspBody->is_destroyed = is_destroyed;
    rspBody->remainder_times = htonl(remainder_times);
    rspBody->discovered_times = htonl(discovered_times);
    rspBody->count = htonl(item_vec.size());

    ItemInfo *p = rspBody->item_arr;
    for(int i=0; i<item_vec.size(); i++, p++) {
        p->type = htonl(item_vec[i].type);
        p->count = htonl(item_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithUnlockDiscoverSeal(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithUnlockDiscoverSeal", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_UnlockDiscoverSeal* ud = (SPCmd_UnlockDiscoverSeal*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_UnlockDiscoverSeal))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        ud->profession = ntohl(ud->profession);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int destroy_seal, unlocked_seal;
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    bool result_flag = check_and_unlock_discover_seal(main_hero_id, ud->profession
        , destroy_seal, unlocked_seal, zhuangbei_vec);

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_UnlockDiscoverSealRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = unlockDiscoverSealRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_UnlockDiscoverSealRsp* rspBody = (SPCmd_UnlockDiscoverSealRsp*)((rspHead)+1);

    if(result_flag) {
        rspBody->err_code = htonl(Success);
        rspBody->count = htonl(zhuangbei_vec.size());
        rspBody->destroy_seal = htonl(destroy_seal);
        rspBody->unlocked_seal = htonl(unlocked_seal);
        memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);
    }
    else {
        rspBody->err_code = htonl(Error);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::test_function(void)
{
    return ;
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::test_function begin", __FILE__, __LINE__);
#endif //_DEBUG

     //查询礼包池
    std::vector<__GiftBagInfo> gift_bag_vec;
    get_gift_bag(793, 1, gift_bag_vec);

	unsigned int actual_data_len = 0;
    char* tmp_data = NULL;

    if(!gift_bag_vec.empty()) {
        int max_total_length = gift_bag_vec[0].get_length();     //分配一个最大的内存

        tmp_data = new char[max_total_length];
    	char* p = tmp_data;
    	unsigned int len;
    	gift_bag_vec[0].convert2_gift_bag_info_hton((GiftBagInfo*)p, len);
    	actual_data_len += len;

        actual_data_len -= (sizeof(unsigned int) *2); //减去已经算了的vitality和item_count
    }
    
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::test_function end", __FILE__, __LINE__);
#endif //_DEBUG
    
}


void ProcServerThread::DealwithQueryEmail(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryEmail", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryEmail* qry = (SPCmd_QueryEmail*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryEmail))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
     //查询奖励池
    std::vector<__EmailInfo> email_vec;
    bool result_flag = query_email(main_hero_id, email_vec);
    
    int total_length = 0;      //统计邮件总共长度
    for(int i=0; i<email_vec.size(); ++i) {
        total_length += email_vec[i].get_length();
        /*
        total_duanzao_zb_count += email_vec[i].zb_vec.size();
        for(int j=0; j<email_vec[i].zb_vec.size(); j++) {
            for(int k=0; k<email_vec[i].zb_vec[j].attr_vec.size(); k++) {
                total_attr_length += email_vec[i].zb_vec[j].attr_vec[k].length() +1;
            }
            total_attr_length += email_vec[i].zb_vec[j].desc.length()+1;
        }
        */
    }

    SPHead* rspHead;
    //int rspDataLen = sizeof(SPCmd_QueryEmailRsp) + sizeof(EmailInfo)*email_vec.size()
    //     + sizeof(DuanzaoGroupZBInfo)*total_duanzao_zb_count + total_attr_length;
    int rspDataLen = sizeof(SPCmd_QueryEmailRsp) + total_length;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryEmailRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryEmailRsp* rspBody = (SPCmd_QueryEmailRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->count = htonl(email_vec.size());

    char * tmp_p = rspBody->email_arr;
    EmailInfo* p = (EmailInfo*)tmp_p;
    unsigned int email_out_len = 0;
    for(int i=0; i<email_vec.size(); ++i)
    {
        email_vec[i].convert2_email_info_hton(p, email_out_len);
        tmp_p += email_out_len;
        p = (EmailInfo*) (tmp_p);
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithReadEmail(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithReadEmail", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ReadEmail* rd = (SPCmd_ReadEmail*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ReadEmail))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        rd->id = ntohl(rd->id);
    }

    
    unsigned int main_hero_id = pack->main_hero_id;
    
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    bool result_flag = read_email(main_hero_id, rd->id, zhuangbei_vec);

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ReadEmailRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = readEmailRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ReadEmailRsp* rspBody = (SPCmd_ReadEmailRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->detail, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithWriteEmail(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithWriteEmail", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_WriteEmail* wrt = (SPCmd_WriteEmail*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_WriteEmail))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        wrt->receiver_id = ntohl(wrt->receiver_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    bool result_flag = write_email(main_hero_id, wrt->receiver_id, wrt->content);

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_WriteEmailRsp);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = writeEmailRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_WriteEmailRsp* rspBody = (SPCmd_WriteEmailRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithDeleteEmail(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithDeleteEmail", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_DeleteEmail* dlt = (SPCmd_DeleteEmail*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_DeleteEmail))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        dlt->id = ntohl(dlt->id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    bool result_flag = delete_email(main_hero_id, dlt->id);

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_DeleteEmailRsp);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = deleteEmailRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_DeleteEmailRsp* rspBody = (SPCmd_DeleteEmailRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryGiftBag(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryGiftBag", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryGiftBag* qry = (SPCmd_QueryGiftBag*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryGiftBag))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    
    std::vector<GiftBag> giftbag_vec;
    { //查询礼包池
        char sql[1024];
        sprintf(sql, "select gift_bag_id, gift_bag_count "
            " from hellgate.gift_bag_hero "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                GiftBag bag;
                bag.id = atoi(Mysql_Thread_Conn->GetField("gift_bag_id"));
                bag.count = atoi(Mysql_Thread_Conn->GetField("gift_bag_count"));

                if(bag.count > 0) {
                    giftbag_vec.push_back(bag);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryGiftBagRsp) + sizeof(GiftBag)*giftbag_vec.size();
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryGiftBagRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryGiftBagRsp* rspBody = (SPCmd_QueryGiftBagRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->count = htonl(giftbag_vec.size());

    GiftBag* p = (GiftBag*)rspBody->gift_bag_arr;
    for(int i=0; i<giftbag_vec.size(); ++i, ++p) {
        p->id = htonl(giftbag_vec[i].id);
        p->count = htonl(giftbag_vec[i].count);
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithGetGiftBag(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithGetGiftBag", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetGiftBag* get = (SPCmd_GetGiftBag*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetGiftBag))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        get->id = ntohl(get->id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    
    //查询礼包池
    std::vector<__GiftBagInfo> gift_bag_vec;
    bool result_flag = get_gift_bag(main_hero_id, get->id, gift_bag_vec);

	unsigned int actual_data_len = 0;
    char* tmp_data = NULL;

    if(!gift_bag_vec.empty()) {
        int max_total_length = gift_bag_vec[0].get_length();;      //分配一个最大的内存

        tmp_data = new char[max_total_length];
    	char* p = tmp_data;
    	unsigned int len;
    	gift_bag_vec[0].convert2_gift_bag_info_hton((GiftBagInfo*)p, len);
    	actual_data_len += len;
    }
    //
    SPHead* rspHead;
    int rspDataLen;
    if(actual_data_len > 0) {
        rspDataLen = sizeof(SPCmd_GetGiftBagRsp) 
            + (actual_data_len - (sizeof(unsigned int) *2)); //减去已经算了的vitality和item_count
    }
    else {
        rspDataLen = sizeof(SPCmd_GetGiftBagRsp);
    }
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getGiftBagRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetGiftBagRsp* rspBody = (SPCmd_GetGiftBagRsp*)((rspHead)+1);
    memset(rspBody, 0, sizeof(SPCmd_GetGiftBagRsp));
    rspBody->err_code = htonl(result_flag ? Success : Error);

    if(!gift_bag_vec.empty()) { 
	    memcpy(&(rspBody->info), tmp_data, actual_data_len);
        delete []tmp_data;
    }
   
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryAssessWeapon(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryAssessWeapon", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryAssessWeapon* qry = (SPCmd_QueryAssessWeapon*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryAssessWeapon))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry->group_id = ntohl(qry->group_id);
    }

    //unsigned int main_hero_id = pack->main_hero_id;
    
    std::vector<__DuanzaoGroupZBInfo> zb_vec;
    bool result_flag = check_and_query_assess_weapon(qry->group_id, zb_vec);

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryAssessWeaponRsp) 
            + sizeof(DuanzaoGroupZBInfo) *zb_vec.size();
    for(int i=0; i<zb_vec.size(); ++i)
    {
        for(int j=0; j<zb_vec[i].attr_vec.size(); ++j)
        {
            rspDataLen += zb_vec[i].attr_vec[j].length()+1;
        }

        rspDataLen += zb_vec[i].desc.length()+1;
    }
    
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryAssessWeaponRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryAssessWeaponRsp* rspBody = (SPCmd_QueryAssessWeaponRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);


    unsigned int zb_len;
    char *tmp_p = rspBody->material_zb;
    DuanzaoGroupZBInfo* p = (DuanzaoGroupZBInfo*)tmp_p;

    for(int i=0; i<zb_vec.size(); ++i)
    {
        zb_vec[i].convert2ZBInfoAndHton(p, zb_len);
        tmp_p += zb_len;
        p = (DuanzaoGroupZBInfo*)(tmp_p);
    }
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
    
    
    return;
}


void ProcServerThread::DealwithAssessWeapon(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithAssessWeapon", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_AssessWeapon* app = (SPCmd_AssessWeapon*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_AssessWeapon))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        app->zb_id = Utl::htonll(app->zb_id);
        app->material_id = Utl::htonll(app->material_id);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    //
    std::vector<ItemInfo> cailiao_vec;
    bool result_flag = check_and_assess_weapon(main_hero_id, app->zb_id, 
        app->material_id, cailiao_vec);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_AssessWeaponRsp) +sizeof(ItemInfo)*cailiao_vec.size();
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = assessWeaponRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_AssessWeaponRsp* rspBody = (SPCmd_AssessWeaponRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->count = htonl(cailiao_vec.size());
    
    ItemInfo *p = rspBody->item_arr;
    for(int i=0; i<cailiao_vec.size() && i<5; ++i, ++p){
        p->type = htonl(cailiao_vec[i].type);
        p->count = htonl(cailiao_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryPurify(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryPurify", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryPurify* qry = (SPCmd_QueryPurify*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryPurify))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int purify_free_times = 0, purified_times = 0, refresh_timestamp = 0;
    bool is_not_exsit = false;
    { // 查询洗炼信息
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.purify_weapon_hero "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                purify_free_times = atoi(Mysql_Thread_Conn->GetField("purify_free_times"));
                purified_times = atoi(Mysql_Thread_Conn->GetField("purified_times"));
                refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
            }
            else {
                is_not_exsit = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(is_not_exsit) { // 记录不存在
        purify_free_times = PURIFY_DEFAULT_TIMES;
        purified_times = 0;

        char sql[1024];
        sprintf(sql, "insert into hellgate.purify_weapon_hero set "
            " hero_id=%u, purify_free_times=%u, purified_times=%u, refresh_timestamp=%u "
            , main_hero_id, purify_free_times, purified_times, (unsigned int)time(NULL));
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else if(isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour)) { //需要刷新
        purify_free_times = PURIFY_DEFAULT_TIMES;
        purified_times = 0;

        char sql[1024];
        sprintf(sql, "update hellgate.purify_weapon_hero set "
            " purify_free_times=%u, purified_times=%u, refresh_timestamp=%u "
            " where hero_id=%u "
            , purify_free_times, purified_times, (unsigned int)time(NULL)
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryPurifyRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryPurifyRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryPurifyRsp* rspBody = (SPCmd_QueryPurifyRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->purify_free_times = htonl(purify_free_times);
    rspBody->purified_times = htonl(purified_times);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithPurify(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithPurify", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_Purify* pr = (SPCmd_Purify*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_Purify))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        pr->id = Utl::ntohll(pr->id);
        pr->hole = ntohl(pr->hole);
    }

    unsigned int main_hero_id = pack->main_hero_id;

    unsigned int purify_hole; 
    std::vector<ZBAttr> attr_vec;
    bool result_flag = check_and_purify_weapon(main_hero_id, pr->id, pr->hole,
        purify_hole, attr_vec);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_PurifyRsp) + sizeof(ZBAttr) *purify_hole;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = purifyRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_PurifyRsp* rspBody = (SPCmd_PurifyRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    rspBody->purify_hole = htonl(purify_hole);

    ZBAttr *p = rspBody->attr_arr;
    for(int i=0; i<purify_hole; ++i, ++p) {
        p->attr_type = htonl(attr_vec[i].attr_type);
        p->attr_value = htonl(attr_vec[i].attr_value);
        p->cuiqu_suc_ratio = htonl(attr_vec[i].cuiqu_suc_ratio);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithConfirmPurify(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithConfirmPurify", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_ConfirmPurify* cp = (SPCmd_ConfirmPurify*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_ConfirmPurify))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        cp->id = Utl::ntohll(cp->id);
    }

    unsigned int main_hero_id = pack->main_hero_id;
    bool result_flag = check_and_confirm_purify(main_hero_id, cp->id, cp->is_confirm);
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_ConfirmPurifyRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = confirmPurifyRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ConfirmPurifyRsp* rspBody = (SPCmd_ConfirmPurifyRsp*)((rspHead)+1);
    rspBody->err_code = htonl(result_flag ? Success : Error);
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryOrigin(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryOrigin", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryOrigin* qry = (SPCmd_QueryOrigin*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryOrigin))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    //unsigned int main_hero_id = pack->main_hero_id;
    std::vector<OriginInfo> origin_vec;
    { //查询origin信息
        char sql[1024];
        sprintf(sql, "select * from hellgate.origin_info order by group_id ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                OriginInfo info;
                info.group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                info.task_id = atoi(Mysql_Thread_Conn->GetField("task_id"));

                if(info.group_id > 0) {
                    origin_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryOriginRsp) + sizeof(OriginInfo)*origin_vec.size();
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryOriginRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryOriginRsp* rspBody = (SPCmd_QueryOriginRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->count = htonl(origin_vec.size());

    OriginInfo *p = rspBody->origin_arr;
    for(int i=0; i<origin_vec.size(); ++i, ++p) {
        p->group_id = htonl(origin_vec[i].group_id);
        p->task_id = htonl(origin_vec[i].task_id);
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryHeroOtherInfo(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryHeroOtherInfo", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryHeroOtherInfo* qry = (SPCmd_QueryHeroOtherInfo*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryHeroOtherInfo))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    unsigned int top_list_order = 0;
    { //查询英雄榜信息
        char sql[1024];
        sprintf(sql, "select hero_order from hellgate.top_hero_list "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                top_list_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryHeroOtherInfoRsp);
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryHeroOtherInfoRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryHeroOtherInfoRsp* rspBody = (SPCmd_QueryHeroOtherInfoRsp*)((rspHead)+1);
    rspBody->err_code = htonl(top_list_order>0 ? Success : Error);
    rspBody->toplist_order = htonl(top_list_order);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryNotice(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryNotice", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryNotice* qry = (SPCmd_QueryNotice*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryNotice))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    //unsigned int main_hero_id = pack->main_hero_id;
     
    int total_length = m_notice.get_length();      //统计公告总长度
    

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryNoticeRsp) + total_length;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryNoticeRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryNoticeRsp* rspBody = (SPCmd_QueryNoticeRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    unsigned int notice_out_len = 0;
    m_notice.convert2_notice_info_hton(&rspBody->info, notice_out_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithQueryInstruction(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithQueryInstruction", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QueryInstruction* qry = (SPCmd_QueryInstruction*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QueryInstruction))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        qry = qry;
    }

    unsigned int main_hero_id = pack->main_hero_id;
     
    bool is_exist = false;
    unsigned long long progress = 0;
    { //查询教学进度
        char sql[1024];
        sprintf(sql, "select progress "
            " from hellgate.instruction_info where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                is_exist = true;
                progress = atoll(Mysql_Thread_Conn->GetField("progress"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(!is_exist) { //记录不存在 插入新纪录
        char sql[1024];
        sprintf(sql, "insert into hellgate.instruction_info "
            " set hero_id=%u, progress=0 "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_QueryInstructionRsp);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = queryInstructionRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QueryInstructionRsp* rspBody = (SPCmd_QueryInstructionRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->progress = Utl::htonll(progress);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::DealwithCompleteInstruction(Packet * pack)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::DealwithCompleteInstruction", __FILE__, __LINE__);
#endif //_DEBUG

    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_CompleteInstruction* ci = (SPCmd_CompleteInstruction*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_CompleteInstruction))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        ci->progress = Utl::ntohll(ci->progress);
    }

    unsigned int main_hero_id = pack->main_hero_id;
     
    bool is_exist = false;
    { //查询记录是否存在
        char sql[1024];
        sprintf(sql, "select progress "
            " from hellgate.instruction_info where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                is_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(is_exist) { //更新记录
        char sql[1024];
        sprintf(sql, "update hellgate.instruction_info "
            " set progress=%llu where hero_id=%u "
            , ci->progress, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_CompleteInstructionRsp);
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = completeInstructionRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CompleteInstructionRsp* rspBody = (SPCmd_CompleteInstructionRsp*)((rspHead)+1);
    rspBody->err_code = htonl(is_exist ? Success : Error);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::getAndRefreshHellTaskHeroInfo(unsigned int hero_id
        ,unsigned int& battle_time_remainder,unsigned int& last_active_task_id)
{
    battle_time_remainder = 0;
    last_active_task_id = 0;
    
    bool has_hero_record = false;
    unsigned int last_refresh_timestamp = 0;
    
    
    
    //先查询
    {
        char sql[1024];
        sprintf(sql, "select refresh_timestamp, battle_time_remainder, last_active_task_id "
            " from hellgate.hell_task_hero_info where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_hero_record = true;
                
                last_refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                battle_time_remainder = atoi(Mysql_Thread_Conn->GetField("battle_time_remainder"));
                last_active_task_id = atoi(Mysql_Thread_Conn->GetField("last_active_task_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);

    //如果记录还不存在则初始化
    if(!has_hero_record)
    {

        //填写初始值
        battle_time_remainder = HellTaskBattle_MaxTime;
        last_active_task_id = HellTaskId_Min;
        last_refresh_timestamp = time(0);
        
        {
            char sql[1024];
            sprintf(sql, "insert into hellgate.hell_task_hero_info set "
                " hero_id=%u, refresh_timestamp=%u, "
                " battle_time_remainder=%u, last_active_task_id=%u "
                , hero_id, last_refresh_timestamp
                , battle_time_remainder, last_active_task_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        return;
    }
    else
    {
        //如果上次刷新已经是今日统一刷新时间戳之前，则重新初始化
        bool need_refresh = isNeedSystemDailyRefresh(last_refresh_timestamp,SystemDailyTask_Hour);
        
        if(need_refresh)
        {
            //刷新
            battle_time_remainder = HellTaskBattle_MaxTime;
            last_refresh_timestamp = time(0);
            
            char sql[1024];
            sprintf(sql, "update hellgate.hell_task_hero_info set "
                " refresh_timestamp=%u, "
                " battle_time_remainder=%u, "
                " drop_times=0 "
                " where hero_id=%u"
                , last_refresh_timestamp
                , battle_time_remainder
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

        }
    }

    

    return;
}

void ProcServerThread::getAndRefreshHeroArenaBasicInfo(unsigned int hero_id,ArenaTeamBasicInfo & team_info)
{
    bool has_hero_record = false;
    unsigned int last_refresh_timestamp = 0;
    
    //先查询
    {
        char sql[1024];
        sprintf(sql, "select last_refresh_timestamp, jifen, free_fight_remainder_time, "
            " challenge_remainder_time "
            " from hellgate.arena_hero_info where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_hero_record = true;
                
                last_refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("last_refresh_timestamp"));
                team_info.jifen = atoi(Mysql_Thread_Conn->GetField("jifen"));
                team_info.free_fight_remainder_time = atoi(Mysql_Thread_Conn->GetField("free_fight_remainder_time"));
                team_info.challenge_remainder_time = atoi(Mysql_Thread_Conn->GetField("challenge_remainder_time"));
                //team_info.buy_challenge_remainder_time = atoi(Mysql_Thread_Conn->GetField("buy_challenge_remainder_time"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        team_info.buy_challenge_remainder_time = getHeroVipInfo(hero_id, VIP_FIELD_TYPE_ARENA);
    }

    //
    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);

    //如果记录还不存在则初始化
    if(!has_hero_record)
    {

        //填写初始值
        team_info.free_fight_remainder_time = ArenaFreeJingji_Oneday_max_time;
        team_info.challenge_remainder_time = ArenaChallenge_Oneday_init_time;
        team_info.jifen = 0;
        team_info.buy_challenge_remainder_time = 0;
        //team_info.buy_challenge_remainder_time = CS::getVIPArenaChallengeMaxBuyTime(hero_info.vip_level);
        {//查询当前vip等级最大竞技次数
            char sql[1024];
            sprintf(sql, "select buy_arena_num from hellgate.vip_template where "
                " level=%u "
                , hero_info.vip_level);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    team_info.buy_challenge_remainder_time = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                }
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        {
            char sql[1024];
            sprintf(sql, "insert into hellgate.arena_hero_info set "
                " hero_id=%u, last_refresh_timestamp=%u, "
                " jifen=%u, free_fight_remainder_time=%u, "
                " challenge_remainder_time=%u "
                , hero_id, (unsigned int)time(0)
                , team_info.jifen, team_info.free_fight_remainder_time
                , team_info.challenge_remainder_time);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        return;
    }

    //如果上次刷新已经是今日统一刷新时间戳之前，则重新初始化
    bool need_refresh = isNeedSystemDailyRefresh(last_refresh_timestamp, SystemDailyTask_Hour);
    
    if(need_refresh)
    {
    
        char sql[1024];
        sprintf(sql, "update hellgate.arena_hero_info set "
            " last_refresh_timestamp=%u, "
            " free_fight_remainder_time=%u, "
            " challenge_remainder_time=%u"
            " where hero_id=%u"
            , (unsigned int)time(0)
            , ArenaFreeJingji_Oneday_max_time
            , ArenaChallenge_Oneday_init_time
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        team_info.free_fight_remainder_time = ArenaFreeJingji_Oneday_max_time;
        team_info.challenge_remainder_time = ArenaChallenge_Oneday_init_time;
        
        team_info.buy_challenge_remainder_time = 0;
        //team_info.buy_challenge_remainder_time = CS::getVIPArenaChallengeMaxBuyTime(hero_info.vip_level);
        {//查询当前vip等级最大竞技次数
            char sql[1024];
            sprintf(sql, "select buy_arena_num from hellgate.vip_template where "
                " level=%u "
                , hero_info.vip_level);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    team_info.buy_challenge_remainder_time = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                }
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

    }

    return;
}

void ProcServerThread::loadCityGuardData()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::loadCityGuardData", __FILE__, __LINE__);
#endif //_DEBUG

    unsigned int boss_hp_total = 0;
    unsigned int boss_hp_remainder = 0;
    unsigned int open_time = 0;
    {
        char sql[1024];
        sprintf(sql, "select hp, boss_hp_remainder, open_time "
            " from hellgate.cityguard_boss_template, hellgate.cityguard_info "
            " where hellgate.cityguard_info.boss_level=hellgate.cityguard_boss_template.boss_level "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                boss_hp_total = atoi(Mysql_Thread_Conn->GetField("hp"));
                boss_hp_remainder = atoi(Mysql_Thread_Conn->GetField("boss_hp_remainder"));
                open_time = atoi(Mysql_Thread_Conn->GetField("open_time"));
            }
            else
            {
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //获取锁
    if(pthread_mutex_lock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_lock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    }

    time_t cur_time = time(NULL);
    
    m_cityguard.boss_total_hp = boss_hp_total;
    m_cityguard.opening_timestamp = open_time;
    m_cityguard.is_opening = false;

    if(cur_time >= open_time){
        if(boss_hp_remainder != boss_hp_total) {
            m_cityguard.is_opening = true;
        }
        else { //以前的数据 删除伤害表数据
            cityGuardStatInfo stat;
            stat.is_opening = true;
            openCityGuard(stat);
        }
    }

    //
    m_cityguard.next_index_to_send_notify = 0;

    //释放锁
    if(pthread_mutex_unlock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_unlock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    }
}

//每日守城
void ProcServerThread::cityGuardTimer()
{
    
    time_t current_time = time(0);

    //
    std::list<CityGuardHero> need_send_notify_hero_list;
    CityGuardProcessNotifyData notify_data;

    //获取锁
    if(pthread_mutex_lock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_lock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    }

    if(!m_cityguard.is_opening)
    {
        //检查是否有还未发送boss已死通知的玩家
        for(int i=0; i<CityGuardHeroNotifyPeriodSec; ++i)
        {
            if(m_cityguard.hero_wait_for_boss_dead_notify_table[i].size() == 0)
            {
                continue;
            }

            
            need_send_notify_hero_list = m_cityguard.hero_wait_for_boss_dead_notify_table[i];
            m_cityguard.hero_wait_for_boss_dead_notify_table[i].clear();

            //一次只发一个list
            break;
        }

        notify_data.play_time = 0;
        notify_data.boss_hp_start = 0;
        notify_data.boss_hp_end = 0;
        notify_data.another_hero_shanghai.clear();
    }
    else
    {
        unsigned int period = current_time - m_cityguard.opening_timestamp;
        if(period > CityGuardHeroNotifyPeriodSec)
        {
            period = CityGuardHeroNotifyPeriodSec;
        }
        packCityGuardProcessNotifyData(period, notify_data);

        //要发送的hero_id
        need_send_notify_hero_list = m_cityguard.hero_notify_table[m_cityguard.next_index_to_send_notify];

        //调整index
        m_cityguard.next_index_to_send_notify++;
        if(m_cityguard.next_index_to_send_notify == CityGuardHeroNotifyPeriodSec)
        {
            m_cityguard.next_index_to_send_notify = 0;
        }
    }

    //释放锁
    if(pthread_mutex_unlock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_unlock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    }

    //发送
    std::list<CityGuardHero>::iterator pos = need_send_notify_hero_list.begin();
    for(; pos!=need_send_notify_hero_list.end(); ++pos)
    {
        sendCityGuardProcessNotify(pos->hero_id, notify_data);
    }
}

//进入守城界面，查询当前守城活动的状态信息
void ProcServerThread::DealWithGetCityGuardCurrentStat(Packet* pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealWithGetCityGuardCurrentStat", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_getCityGuardCurrentStat* query = (SPCmd_getCityGuardCurrentStat*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_getCityGuardCurrentStat))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    cityGuardStatInfo stat_info;
    bool have_reward = false;
    ItemInfo reward;
    bool need_send_process_notify = false;
    CityGuardProcessNotifyData notify_data;
    
    //获取锁
    if(pthread_mutex_lock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_lock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    };
    //进入数据结构
    {

        //获取当前守城活动基本信息
        getCityGuardCurrentStatInfo(stat_info);
        
        //同时更新服务器标志位
        //其实服务器开启守城活动是由第一个在规定时间进入活动的玩家触发的
        openCityGuard(stat_info);

        //获取玩家奖励信息
        have_reward = heroHasCityGuardReward(main_hero_id, reward);

        //如果是活动进行期间，将玩家插入到需要发送队列的表中
        if(stat_info.is_opening)
        {
            //先计算下标
            unsigned int index 
                = bob_hash(&main_hero_id,sizeof(main_hero_id)) % CityGuardHeroNotifyPeriodSec;

            //查找是否已经在表里了
            std::list<CityGuardHero>::iterator pos = m_cityguard.hero_notify_table[index].begin();
            for(; pos!=m_cityguard.hero_notify_table[index].end(); ++pos)
            {
                if(pos->hero_id == main_hero_id)
                {
                    break;
                }
            }
            if(pos == m_cityguard.hero_notify_table[index].end())
            {
                //第一次进守城
                

                //入表
                CityGuardHero hero;
                hero.hero_id = main_hero_id;
                m_cityguard.hero_notify_table[index].push_back(hero);

                //组装需要发送的通知数据
                {
                    //计算需要发送多长时间段的数据
                    unsigned int process_period = 0;
                    if(m_cityguard.next_index_to_send_notify == index)
                    {
                        //下一秒就要发了，现在就不发了
                        need_send_process_notify = false;
                        process_period= 0;
                    }
                    else if(m_cityguard.next_index_to_send_notify < index)
                    {
                        need_send_process_notify = true;
                        
                        process_period = index - m_cityguard.next_index_to_send_notify +1;
                    }
                    else
                    {
                        need_send_process_notify = true;
                        
                        process_period = 
                            CityGuardHeroNotifyPeriodSec 
                            - (m_cityguard.next_index_to_send_notify-index)+1;
                    }

                    if(need_send_process_notify)
                    {
                        packCityGuardProcessNotifyData(process_period, notify_data);
                    }
                }
            }
        }
        
    }
    //释放锁
    if(pthread_mutex_unlock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_unlock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    };

    //
    int rspDataLen = sizeof(SPCmd_getCityGuardCurrentStatRsp);
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getCityGuardCurrentStatRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_getCityGuardCurrentStatRsp* rspBody = (SPCmd_getCityGuardCurrentStatRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->stat.is_opening = stat_info.is_opening;
    rspBody->stat.boss_blood_total = htonl(stat_info.boss_blood_total);
    rspBody->stat.time_before_open = htonl(stat_info.time_before_open);

    rspBody->have_reward = have_reward;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    //再发送notify
    if(need_send_process_notify)
    {
        sendCityGuardProcessNotify(main_hero_id, notify_data);
    }
    

    return;
}

void ProcServerThread::openCityGuard(cityGuardStatInfo stat)
{
    if(!m_cityguard.is_opening && stat.is_opening) {
        m_cityguard.is_opening = true;
    
        { //清除伤害表
            char sql[1024];
            sprintf(sql, "delete from hellgate.cityguard_hero_info "
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
}

void ProcServerThread::processCityGuardBossBeKilled(unsigned int hero_kill_boss)
{

    //将所有玩家放入队列，等待统一发送boss已死的通知
    for(int i=0; i<CityGuardHeroNotifyPeriodSec; ++i)
    {
        m_cityguard.hero_wait_for_boss_dead_notify_table[i] = m_cityguard.hero_notify_table[i];
    }
    
    //清除所有本次战斗记录
    m_cityguard.battle_record_map.clear();
    for(int i=0; i<CityGuardHeroNotifyPeriodSec; ++i)
    {
        m_cityguard.hero_notify_table[i].clear();
    }
    m_cityguard.next_index_to_send_notify = 0;

    //计算排名并颁奖
    {
        cityGuardGenReportAndCalcReward(hero_kill_boss);
    }

    //清除本次战斗数据
    {
        char sql[1024];
        sprintf(sql, "delete from hellgate.last_cityguard_hero_info "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        sprintf(sql, "insert into hellgate.last_cityguard_hero_info "
            " select * from hellgate.last_cityguard_hero_info "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        /* 2014.4.15 修改奖励排名
        sprintf(sql, "delete from hellgate.cityguard_hero_info "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        */
    }

    //重置下次守城数据
    time_t cur_time = time(NULL);
    unsigned int next_boss_total_hp, next_open_time;
    setNextCityGuardInfo(cur_time - m_cityguard.opening_timestamp
        , next_boss_total_hp, next_open_time);

    //
    m_cityguard.is_opening = false;
    m_cityguard.boss_total_hp = next_boss_total_hp;
    m_cityguard.opening_timestamp = next_open_time;
}

void ProcServerThread::packCityGuardProcessNotifyData(unsigned int process_period
    ,CityGuardProcessNotifyData & notify_data)
{
    notify_data.play_time = process_period;
    notify_data.boss_hp_start = m_cityguard.boss_total_hp;
    notify_data.boss_hp_end = m_cityguard.boss_total_hp;
    notify_data.another_hero_shanghai.clear();
    
    time_t cur_time = (unsigned int)time(0);
    
    for(int i=process_period; i>0; --i)
    {
        std::map<time_t, CityGuardBattleRecord>::iterator map_pos 
            = m_cityguard.battle_record_map.find(cur_time-i);
        if(map_pos != m_cityguard.battle_record_map.end())
        {
            //初始化血量
            if(notify_data.boss_hp_start == m_cityguard.boss_total_hp)
            {
                notify_data.boss_hp_start = map_pos->second.boss_hp;
                notify_data.boss_hp_end = notify_data.boss_hp_start;
                
            }

            //
            std::list<CityGuardShanghai>::iterator list_pos = map_pos->second.shanghai_list.begin();
            for(; list_pos!=map_pos->second.shanghai_list.end(); ++list_pos)
            {
                if(notify_data.another_hero_shanghai.size() 
                    < process_period*CityGuardHeroNotifyShowShanghaiPerSec)
                {
                    CityGuardAnotherHeroShanghai shanghai;
                    shanghai.profession_id = list_pos->profession;
                    strncpy(shanghai.name, list_pos->hero_name.c_str(), HeroNameMaxLen);
                    shanghai.name[HeroNameMaxLen] = 0;
                    shanghai.shanghai = list_pos->shanghai;
                    
                    notify_data.another_hero_shanghai.push_back(shanghai);
                }
                
                notify_data.boss_hp_end -= list_pos->shanghai;
            }
        }
    }

    if(notify_data.another_hero_shanghai.size() == 0)
    {
        unsigned int boss_hp_remainder = 0;
        {
            char sql[1024];
            sprintf(sql, "select boss_hp_remainder "
                " from hellgate.cityguard_info "
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    
                    boss_hp_remainder = atoi(Mysql_Thread_Conn->GetField("boss_hp_remainder"));
                }
                else
                {
                    assert(false);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        notify_data.boss_hp_start = boss_hp_remainder;
        notify_data.boss_hp_end = boss_hp_remainder;
    }
}

void ProcServerThread::sendCityGuardProcessNotify(unsigned int hero_id
    , CityGuardProcessNotifyData notify_data)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::sendCityGuardProcessNotify", __FILE__, __LINE__);
#endif //_DEBUG

    int rspDataLen = sizeof(SPCmd_CityGuardProcessNotify) 
        + notify_data.another_hero_shanghai.size()*sizeof(CityGuardAnotherHeroShanghai);
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = cityGuardProcessNotify;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_CityGuardProcessNotify* rspBody = (SPCmd_CityGuardProcessNotify*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->play_time = htonl(notify_data.play_time);
    rspBody->boss_hp_start = htonl(notify_data.boss_hp_start);
    rspBody->boss_hp_end = htonl(notify_data.boss_hp_end);

    rspBody->hero_count = htonl(notify_data.another_hero_shanghai.size());
    for(int i=0; i<notify_data.another_hero_shanghai.size(); ++i)
    {
        rspBody->another_hero[i].profession_id = htonl(notify_data.another_hero_shanghai[i].profession_id);
        rspBody->another_hero[i].shanghai= htonl(notify_data.another_hero_shanghai[i].shanghai);
        strcpy(rspBody->another_hero[i].name, notify_data.another_hero_shanghai[i].name);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::getCityGuardCurrentStatInfo(cityGuardStatInfo& stat_info)
{
    stat_info.boss_blood_total = 0xffffffff;
    stat_info.is_opening = false;
    stat_info.time_before_open = 0xffffffff;
    
    //
    unsigned int open_time = 0xffffffff;
    {
        char sql[1024];
        sprintf(sql, "select hp, open_time "
            " from hellgate.cityguard_boss_template, hellgate.cityguard_info "
            " where hellgate.cityguard_info.boss_level=hellgate.cityguard_boss_template.boss_level "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                stat_info.boss_blood_total = atoi(Mysql_Thread_Conn->GetField("hp"));
                open_time = atoi(Mysql_Thread_Conn->GetField("open_time"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    time_t current_time = time(0);
    if(current_time > open_time)
    {
        stat_info.is_opening = true;
        stat_info.time_before_open= 0;
    }
    else
    {
        stat_info.is_opening = false;
        stat_info.time_before_open = open_time-current_time;
    }

    return;
}

bool ProcServerThread::heroHasCityGuardReward(unsigned int hero_id, ItemInfo& reward)
{
    bzero(&reward, sizeof(ItemInfo));
    bool has_reward = false;

    { //击杀 伤害排名 或者幸运奖
        char sql[1024];
        sprintf(sql, "select reward_item_type, reward_item_count "
            " from hellgate.cityguard_reward "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_reward = true;
                
                reward.type = atoi(Mysql_Thread_Conn->GetField("reward_item_type"));
                reward.count = atoi(Mysql_Thread_Conn->GetField("reward_item_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(!has_reward) { // 参与奖 
        char sql[1024];
        sprintf(sql, "select is_join_get "
            " from hellgate.cityguard_hero_info "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            { //已经领取过 就没奖
                has_reward = !(bool)atoi(Mysql_Thread_Conn->GetField("is_join_get"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return has_reward;
}

bool ProcServerThread::getAndDelHeroCityGuardReward(unsigned int hero_id, std::vector<ItemInfo> &reward_vec)
{
    reward_vec.clear();
    bool has_reward = false;
    bool is_join_get = false;
    
    { //查询参与没有
        char sql[1024];
        sprintf(sql, "select is_join_get "
            " from hellgate.cityguard_hero_info "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                is_join_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_join_get"));
            }
            else {
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    {
        char sql[1024];
        sprintf(sql, "select reward_item_type, reward_item_count "
            " from hellgate.cityguard_reward "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_reward = true;
                ItemInfo item;
                
                item.type = atoi(Mysql_Thread_Conn->GetField("reward_item_type"));
                item.count = atoi(Mysql_Thread_Conn->GetField("reward_item_count"));

                if(item.count > 0) {
                    reward_vec.push_back(item);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(!has_reward)
    {
        return false;
    }

    if(!is_join_get) {
        ItemInfo join_reward;
        CS::getCityGuardJoinReward(join_reward);
        
        reward_vec.push_back(join_reward);
    }

    for(int i=0; i<reward_vec.size(); i++) { //先入库
        ObtainItem(hero_id, reward_vec[i].type, reward_vec[i].count);
    }

    
    { //删除记录
        char sql[1024];
        sprintf(sql, "delete from hellgate.cityguard_reward "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    if(!is_join_get) { //更新参与奖领取状态
        char sql[1024];
        sprintf(sql, "update hellgate.cityguard_hero_info set "
            " is_join_get=1 "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    return true;
}

//计算排名并颁奖
void ProcServerThread::cityGuardGenReportAndCalcReward(unsigned int hero_kill_boss)
{
    //先计算总战斗时间
    time_t cur_time = time(NULL);
    unsigned int cityguard_total_time = cur_time - m_cityguard.opening_timestamp;
    {
        tm* cur_tm = localtime(&cur_time);
        cityguard_total_time = cur_time%3600;

        if(cur_tm->tm_hour < CITYGUARD_OPEN_HOUR_1) { //当天12点之前 算昨晚开启的时间
            cityguard_total_time += (cur_tm->tm_hour + (24-CITYGUARD_OPEN_HOUR_2))*3600;
        }
        else if(cur_tm->tm_hour < CITYGUARD_OPEN_HOUR_2) { //当天20点之前 算中午12点的
            cityguard_total_time += (cur_tm->tm_hour - CITYGUARD_OPEN_HOUR_1)*3600;
        }
        else { //当天20点之后 算20点
            cityguard_total_time += (cur_tm->tm_hour - CITYGUARD_OPEN_HOUR_2)*3600;
        }
    }
    
    //击杀奖
    ItemInfo reward_kill_boss;
    CS::getCityGuardKillBossReward(reward_kill_boss);
    
    //先查询出所有玩家的伤害数据
    std::list<CityGuardShanghai> shanghai_list;
    {
        char sql[1024];
        sprintf(sql, "select hero_id, total_shanghai from hellgate.cityguard_hero_info "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                CityGuardShanghai shanghai;
                shanghai.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                shanghai.shanghai = atoi(Mysql_Thread_Conn->GetField("total_shanghai"));
                
                shanghai_list.push_back(shanghai);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //输出排名奖
    std::vector<CityGuardShanghai> hero_shanghai_order_vec;
    std::vector<ItemInfo> hero_shanghai_order_reward_vec;
    {
        for(int count=0; count<CITYGUARD_HERO_ORDER_COUNT; ++count)
        {
            std::list<CityGuardShanghai>::iterator max_shanghai_pos = shanghai_list.begin();
            std::list<CityGuardShanghai>::iterator pos = shanghai_list.begin();
            for(; pos!=shanghai_list.end(); ++pos)
            {
                if(pos->shanghai > max_shanghai_pos->shanghai)
                {
                    max_shanghai_pos = pos;
                }
            }

            //
            if(max_shanghai_pos == shanghai_list.end())
            {
                LogMsg("%s, line %d, city guard hero not enought", __FILE__, __LINE__);
                break;
            }

            //
            hero_shanghai_order_vec.push_back(*max_shanghai_pos);

            //
            shanghai_list.erase(max_shanghai_pos);
        }
    }
    {
        ItemInfo reward_order_1, reward_order_2, reward_order_3, reward_order_4_10, reward_order_11_20;
        CS::getCityGuardHeroShanghaiOrderReward(reward_order_1,reward_order_2
            ,reward_order_3,reward_order_4_10,reward_order_11_20);
        hero_shanghai_order_reward_vec.push_back(reward_order_1);
        hero_shanghai_order_reward_vec.push_back(reward_order_2);
        hero_shanghai_order_reward_vec.push_back(reward_order_3);
        for(int i=4; i<=10; ++i)
        {
            hero_shanghai_order_reward_vec.push_back(reward_order_4_10);
        }
        for(int i=11; i<=20; ++i)
        {
            hero_shanghai_order_reward_vec.push_back(reward_order_11_20);
        }
    }

    //幸运奖
    std::vector<CityGuardShanghai> hero_lucky_vec;
    ItemInfo reward_lucky;
    CS::getCityGuardLuckyReward(reward_lucky);
    {
        
        unsigned int total_hero_count = shanghai_list.size();
        std::vector<unsigned int> tmp_lucky_index_vec;
        for(int i=0; i<CITYGUARD_LUCKY_COUNT&&i<total_hero_count; ++i)
        {
            unsigned int lucky_index = Utl::auto_random()%total_hero_count;
            
            //判断是否重复
            bool is_duplicate = false;
            for(int index=0; index<tmp_lucky_index_vec.size(); ++index)
            {
                if(lucky_index == tmp_lucky_index_vec[index])
                {
                    is_duplicate = true;
                    
                    break;
                }
            }

            if(is_duplicate)
            {
                --i;
                continue;
            }
            else
            {
                tmp_lucky_index_vec.push_back(lucky_index);
            }
        }
        sort(tmp_lucky_index_vec.begin(), tmp_lucky_index_vec.end());
        std::list<CityGuardShanghai>::iterator pos = shanghai_list.begin();
        int index_shanghai_list = 0;
        int index_tmp_lucky = 0;
        for(; pos!=shanghai_list.end() && index_tmp_lucky<tmp_lucky_index_vec.size(); ++pos, ++index_shanghai_list)
        {
            if(index_shanghai_list == tmp_lucky_index_vec[index_tmp_lucky])
            {
                //
                hero_lucky_vec.push_back(*pos);
                ++index_tmp_lucky;
            }
        }
        if(index_tmp_lucky != tmp_lucky_index_vec.size())
        {
            assert(false);
        }
    }

    //战报入库
    {
        //先清空上次的
        {
            char sql[1024];
            sprintf(sql, "delete from hellgate.cityguard_last_report "
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

            
        }

        //再填入本次的
        {
            std::string hero_order_str;
            for(int i=0; i<CITYGUARD_HERO_ORDER_COUNT; ++i)
            {
                unsigned int hero_id;
                if(i<hero_shanghai_order_vec.size())
                {
                    hero_id = hero_shanghai_order_vec[i].hero_id;
                }
                else
                {
                    hero_id = 0;
                }
                
                char str[64];
                sprintf(str, " , hero_id_shanghai_order_%d=%d ", i+1, hero_id);

                hero_order_str = hero_order_str + str;
            }

            std::string hero_lucky_str;
            for(int i=0; i<CITYGUARD_LUCKY_COUNT; ++i)
            {
                unsigned int hero_id;
                if(i<hero_lucky_vec.size())
                {
                    hero_id = hero_lucky_vec[i].hero_id;
                }
                else
                {
                    hero_id = 0;
                }
                
                char str[64];
                sprintf(str, " , hero_id_shanghai_lucky_%d=%d ", i+1, hero_id);

                hero_lucky_str = hero_lucky_str + str;
            }

            
            char sql[2048];
            
            sprintf(sql, "insert into hellgate.cityguard_last_report "
                " set last_cityguard_total_time=%u, "
                " hero_id_kill_boss=%u "
                " %s "
                " %s"
                , cityguard_total_time
                , hero_kill_boss
                , hero_order_str.c_str()
                , hero_lucky_str.c_str());
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        
    }

    //奖励入库
    {
        //先清空上次的
        {
            char sql[1024];
            sprintf(sql, "delete from hellgate.cityguard_reward "
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

            
        }

        //再填入本次的
        {
            char sql[1024];
            
            sprintf(sql, "insert into hellgate.cityguard_reward "
                " set hero_id=%u, reward_item_type=%u, reward_item_count=%u"
                , hero_kill_boss
                , reward_kill_boss.type
                , reward_kill_boss.count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        for(int i=0; i<hero_shanghai_order_vec.size(); ++i)
        {
            char sql[1024];
            
            sprintf(sql, "insert into hellgate.cityguard_reward "
                " set hero_id=%u, reward_item_type=%u, reward_item_count=%u"
                , hero_shanghai_order_vec[i].hero_id
                , hero_shanghai_order_reward_vec[i].type
                , hero_shanghai_order_reward_vec[i].count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        for(int i=0; i<hero_lucky_vec.size(); ++i)
        {
            char sql[1024];
            
            sprintf(sql, "insert into hellgate.cityguard_reward "
                " set hero_id=%u, reward_item_type=%u, reward_item_count=%u"
                , hero_lucky_vec[i].hero_id
                , reward_lucky.type
                , reward_lucky.count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        
    }
    
}

//设置下次守城的信息
void ProcServerThread::setNextCityGuardInfo(unsigned int cityguard_time_period
    , unsigned int& next_boss_total_hp, unsigned int& next_open_time)
{
    //查询下次boss的血量
    next_boss_total_hp = 0xffffffff;
    {
        char sql[1024];
        sprintf(sql, "select hp from hellgate.cityguard_boss_template, hellgate.cityguard_info "
            " where hellgate.cityguard_boss_template.boss_level=hellgate.cityguard_info.boss_level"
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                next_boss_total_hp = atoi(Mysql_Thread_Conn->GetField("hp"));
            }
            else
            {
                LogMsg("%s, line %d, cityguard_info boss_level invalide"
                        , __FILE__, __LINE__);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //计算下次时间
    time_t cur_time = time(NULL);
    tm* cur_tm = localtime(&cur_time);
    tm* p_tm;

    if(cur_tm->tm_hour < CITYGUARD_OPEN_HOUR_1) { //当天12点之前
        p_tm = localtime(&cur_time);
        p_tm->tm_hour = CITYGUARD_OPEN_HOUR_1;
    }
    else if(cur_tm->tm_hour < CITYGUARD_OPEN_HOUR_2) { //当天20点之前
        p_tm = localtime(&cur_time);
        p_tm->tm_hour = CITYGUARD_OPEN_HOUR_2;
    }
    else { //当天20点之后 计算明天12点
        time_t tmp_time = cur_time + 86400;
        p_tm = localtime(&tmp_time);
        p_tm->tm_hour = CITYGUARD_OPEN_HOUR_1;
    }
    
    p_tm->tm_min = 0;
    p_tm->tm_sec = 1;
    next_open_time = mktime(p_tm);

    //入库
    {
        char sql[1024];
        sprintf(sql, "update hellgate.cityguard_info "
            " set boss_hp_remainder=%u, open_time=%u"
            , next_boss_total_hp, next_open_time);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::DealWithCityGuardBattle(Packet* pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealWithCityGuardBattle", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_cityGuardBattle* battle = (SPCmd_cityGuardBattle*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_cityGuardBattle))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        battle = battle;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;
    
    //
    cityGuardBattleProc(pack, main_hero_id, battle->is_skil_cd);

    return;
}


void ProcServerThread::DealwithQuitCityGuard(Packet* pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealwithQuitCityGuard", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_QuitCityGuard* quit = (SPCmd_QuitCityGuard*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_QuitCityGuard))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        quit = quit;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    cityGuardStatInfo stat_info;

    //获取锁
    if(pthread_mutex_lock(&m_cityguard.mutex) != 0) {
        LogMsg("%s, line %d, pthread_mutex_lock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    };
    
    {//进入数据结构
        //获取当前守城活动基本信息
        getCityGuardCurrentStatInfo(stat_info);

        if(stat_info.is_opening) {
            //先计算下标
            unsigned int index 
                = bob_hash(&main_hero_id,sizeof(main_hero_id)) % CityGuardHeroNotifyPeriodSec;

            //查找是否已经在表里了
            std::list<CityGuardHero>::iterator pos = m_cityguard.hero_notify_table[index].begin();
            for(; pos!=m_cityguard.hero_notify_table[index].end(); pos++) {
                if(pos->hero_id == main_hero_id) { //找到 删除
                    m_cityguard.hero_notify_table[index].erase(pos);
                    break;
                }
            }
        }
    }
    //释放锁
    if(pthread_mutex_unlock(&m_cityguard.mutex) != 0) {
        LogMsg("%s, line %d, pthread_mutex_unlock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    };

   
    int rspDataLen = sizeof(SPCmd_QuitCityGuardRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = quitCityGuardRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_QuitCityGuardRsp* rspBody = (SPCmd_QuitCityGuardRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::cityGuardBattleProc(Packet* pack, unsigned int main_hero_id, bool is_skip_cd)
{
    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);
    

    //判断task和grid是否当前可进入
    if(hero_info.level < Level_limit_cityguard)
    {
        //
        int rspDataLen = sizeof(SPCmd_cityGuardBattleRsp);
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = cityGuardBattleRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_cityGuardBattleRsp* rspBody = (SPCmd_cityGuardBattleRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }
    
    cityGuardStatInfo stat_info;
    bool need_send_process_notify = false;
    CityGuardProcessNotifyData notify_data;
    bool battle_win = false;
    char* battle_script = 0;
    int battle_script_len = 0;
    unsigned int hero_cityguard_total_shanghai = 0;
    unsigned int harm_order = 100;
    unsigned int gold_balance = getItemCountInTeam(main_hero_id,ItemsType_Gold);
    //获取锁
    if(pthread_mutex_lock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_lock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    };
    //进入数据结构
    {
        time_t current_time = time(0);

        //获取当前守城活动基本信息
        getCityGuardCurrentStatInfo(stat_info);

        //如果当前不在战斗时间返回boss已被击杀
        if(!stat_info.is_opening)
        {
            //释放锁
            if(pthread_mutex_unlock(&m_cityguard.mutex) != 0)
            {
                //
                LogMsg("%s, line %d, pthread_mutex_unlock failed.%s"
                    , __FILE__, __LINE__, strerror(errno));
            };
            
            //
            int rspDataLen = sizeof(SPCmd_cityGuardBattleRsp);
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = cityGuardBattleRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_cityGuardBattleRsp* rspBody = (SPCmd_cityGuardBattleRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Success);

            rspBody->gold_balance = htonl(gold_balance);

            rspBody->battle_data.is_boss_dead = true;

            Packet* rsppack = new Packet;
            rsppack->fd_account = pack->fd_account;
            rsppack->client_id = pack->client_id;
            rsppack->main_hero_id = pack->main_hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            return;
        }

        //同时更新服务器标志位
        //其实服务器开启守城活动是由第一个在规定时间进入活动的玩家触发的
        openCityGuard(stat_info);

        //判断如果是花钱跳过cd时间的情况则需要扣钱
        if(is_skip_cd)
        {
            
            unsigned int gold_need = CS::getCityGuardBattleSkipCDNeedGold();
            if(gold_balance < gold_need)
            {
                //释放锁
                if(pthread_mutex_lock(&m_cityguard.mutex) != 0)
                {
                    //
                    LogMsg("%s, line %d, pthread_mutex_lock failed.%s"
                        , __FILE__, __LINE__, strerror(errno));
                };

                //
                int rspDataLen = sizeof(SPCmd_cityGuardBattleRsp);
                SPHead* rspHead;
                (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
                (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
                (rspHead)->protocol_ver = 1;
                (rspHead)->cmd = cityGuardBattleRsp;
                (rspHead)->data_len = rspDataLen;
                //将包头转换为网络字节序
                hton_SPHead((rspHead));
                
                SPCmd_cityGuardBattleRsp* rspBody = (SPCmd_cityGuardBattleRsp*)((rspHead)+1);
                rspBody->err_code = htonl(Error);

                Packet* rsppack = new Packet;
                rsppack->fd_account = pack->fd_account;
                rsppack->client_id = pack->client_id;
                rsppack->main_hero_id = pack->main_hero_id;
                rsppack->packdata = (char*)rspHead;

                m_outport_q->push(rsppack);

                return;
            }

            //扣钱
            gold_balance -= gold_need;
            {
                char sql[1024];
                sprintf(sql, "update hellgate.items_in_team "
                    " set item_count=%u where hero_id=%u and item_type=%u"
                    , gold_balance, main_hero_id, ItemsType_Gold);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
        
        //先计算下标
        unsigned int index 
            = bob_hash(&main_hero_id,sizeof(main_hero_id)) % CityGuardHeroNotifyPeriodSec;

        //查找是否已经在表里了
        std::list<CityGuardHero>::iterator pos = m_cityguard.hero_notify_table[index].begin();
        for(; pos!=m_cityguard.hero_notify_table[index].end(); ++pos)
        {
            if(pos->hero_id == main_hero_id)
            {
                break;
            }
        }
        if(pos == m_cityguard.hero_notify_table[index].end())
        {
            //第一次进守城
            

            //入表
            CityGuardHero hero;
            hero.hero_id = main_hero_id;
            m_cityguard.hero_notify_table[index].push_back(hero);

            //组装需要发送的通知数据
            {
                //计算需要发送多长时间段的数据
                unsigned int process_period = 0;
                if(m_cityguard.next_index_to_send_notify == index)
                {
                    //下一秒就要发了，现在就不发了
                    need_send_process_notify = false;
                    process_period= 0;
                }
                else if(m_cityguard.next_index_to_send_notify < index)
                {
                    need_send_process_notify = true;
                    
                    process_period = index - m_cityguard.next_index_to_send_notify +1;
                }
                else
                {
                    need_send_process_notify = true;
                    
                    process_period = 
                        CityGuardHeroNotifyPeriodSec 
                        - (m_cityguard.next_index_to_send_notify-index)+1;
                }

                if(need_send_process_notify)
                {
                    packCityGuardProcessNotifyData(process_period, notify_data);
                }
            }
        }
        

        //查询我方上阵阵型
        unsigned int team_pos_vec[4] = {0, 0, 0, 0};
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //查询boss剩余血量
        unsigned int boss_hp_befor_battle = 0;
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select boss_hp_remainder from hellgate.cityguard_info "
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    boss_hp_befor_battle = atoi(Mysql_Thread_Conn->GetField("boss_hp_remainder"));
                    
                }
                else
                {
                    LogMsg("%s, line %d, cityguard_info table has no record"
                            , __FILE__, __LINE__);
                    exit(0);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //查询守城boss。守城boss的id随便填，是个不起作用的值。
        //真实的boss数据在战斗脚本获取怪物数据时直接填入
        //必须放在1号位
        unsigned int monster_pos_vec_1[4] = {1, 0, 0, 0};
        
        //生成战斗脚本
        unsigned int boss_hp_after_battle = 0;
        
        {
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_CityGuard;
            f_sud.battle_kind = is_skip_cd?1:0;
            
            HeroState teamHp;
            f_sud.heroId = main_hero_id;
            f_sud.taskId = 1;
            f_sud.gridId = 1;
            FightScriptBuilder scriptBuild;
            std::vector<FightScript> team_script_vec;

            unsigned int fight_index = 1;

            {
                //SpecialControl SControl = SC_NONE;
                FightScript team_script;
                FightScript monster_script;
                f_sud.fightIndex = fight_index;

                //初始化boss的剩余血量
                teamHp.currentHp_B[0] = boss_hp_befor_battle;
                f_sud.heroHpAfterLastFight = teamHp;
                
                teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                    , team_script, monster_script
                    , this
                    , userData, FBB_BoardA
                    , BATTLE_ROUND_LIMIT);
                team_script_vec.push_back(team_script);

                battle_win = (team_script.endResult.myResult == Result_Win);
                boss_hp_after_battle = teamHp.currentHp_B[0];
            }
            

            battle_script = scriptBuild.FightScriptVec_2_CharArr(team_script_vec, battle_script_len);
        }

        //将本次战斗的伤害入表进行记录
        {
            //现在找到本秒的记录点
            std::map<time_t, CityGuardBattleRecord>::iterator pos = m_cityguard.battle_record_map.find(current_time);
            if(pos == m_cityguard.battle_record_map.end())
            {
                CityGuardBattleRecord record;
                record.boss_hp = boss_hp_befor_battle;
                
                m_cityguard.battle_record_map.insert(make_pair(current_time, record));
                pos = m_cityguard.battle_record_map.find(current_time);
            }

            CityGuardShanghai shanghai;
            shanghai.hero_id = main_hero_id;
            shanghai.profession = hero_info.profession_id;
            shanghai.shanghai = boss_hp_befor_battle - boss_hp_after_battle;
            shanghai.hero_name = hero_info.name;
            pos->second.shanghai_list.push_back(shanghai);

            //更新数据库中boss的剩余血量
            {
                char sql[1024];
                sprintf(sql, "update  hellgate.cityguard_info "
                    " set boss_hp_remainder=%u"
                    , boss_hp_after_battle);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            //更新数据库中本英雄的伤害累计
            {
                
                unsigned int tmp_total_shanghai = 0xffffffff;
                
                char sql[1024];
                sprintf(sql, "select total_shanghai from hellgate.cityguard_hero_info "
                    " where hero_id=%u"
                    , main_hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        tmp_total_shanghai = atoi(Mysql_Thread_Conn->GetField("total_shanghai"));
                        
                    }
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }

                if(tmp_total_shanghai == 0xffffffff)
                {
                    //
                    hero_cityguard_total_shanghai = 0;
                    
                    char sql[1024];
                    sprintf(sql, "insert into hellgate.cityguard_hero_info "
                        " set hero_id=%u, total_shanghai=%u"
                        , main_hero_id, boss_hp_befor_battle-boss_hp_after_battle);
                    try
                    {
                        Mysql_Thread_Conn->Query(sql);
                        
                    }
                    catch(CMysqlException& e)
                    {
                        LogMsg("%s, line %d, mysql exception. [%s]"
                                    , __FILE__, __LINE__, e.GetErrMsg());
                        //
                        exit(1);
                    }
                }
                else
                {
                    //
                    hero_cityguard_total_shanghai = tmp_total_shanghai;
                    
                    char sql[1024];
                    sprintf(sql, "update hellgate.cityguard_hero_info "
                        " set total_shanghai=total_shanghai+%u where hero_id=%u"
                        , boss_hp_befor_battle-boss_hp_after_battle, main_hero_id);
                    try
                    {
                        Mysql_Thread_Conn->Query(sql);
                        
                    }
                    catch(CMysqlException& e)
                    {
                        LogMsg("%s, line %d, mysql exception. [%s]"
                                    , __FILE__, __LINE__, e.GetErrMsg());
                        //
                        exit(1);
                    }
                }

                //英雄累计伤害
                hero_cityguard_total_shanghai += boss_hp_befor_battle-boss_hp_after_battle;

                { //查询伤害排名
                    char sql[1024];
                    sprintf(sql, "select count(hero_id) as n_count from hellgate.cityguard_hero_info "
                        " where total_shanghai>%u "
                        , hero_cityguard_total_shanghai);
                    try
                    {
                        Mysql_Thread_Conn->Query(sql);
                        if(Mysql_Thread_Conn->FetchRow() != NULL)
                        {
                            harm_order = 1 + atoi(Mysql_Thread_Conn->GetField("n_count"));
                        }
                        
                    }
                    catch(CMysqlException& e)
                    {
                        LogMsg("%s, line %d, mysql exception. [%s]"
                                    , __FILE__, __LINE__, e.GetErrMsg());
                        //
                        exit(1);
                    }
                }
            }
        }

        //如果boss在本次战斗中被击杀
        if(battle_win)
        {
            processCityGuardBossBeKilled(main_hero_id);

            need_send_process_notify = false;
        }
    }
    //释放锁
    if(pthread_mutex_unlock(&m_cityguard.mutex) != 0)
    {
        //
        LogMsg("%s, line %d, pthread_mutex_unlock failed.%s"
            , __FILE__, __LINE__, strerror(errno));
    };

    //
    int rspDataLen = sizeof(SPCmd_cityGuardBattleRsp) + battle_script_len;
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = cityGuardBattleRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_cityGuardBattleRsp* rspBody = (SPCmd_cityGuardBattleRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->gold_balance = htonl(gold_balance);

    //spBody->battle_data.is_boss_dead = battle_win; 
    //无论输赢都是传没死 客户端判断赢了以后 自己置成true
    rspBody->battle_data.is_boss_dead = false;  
    rspBody->battle_data.total_shanghai = htonl(hero_cityguard_total_shanghai);
    //stub
    rspBody->battle_data.shanghai_order = htonl(harm_order);

    memcpy(rspBody->battle_data.fightScript, battle_script, battle_script_len);
    delete battle_script;

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    //再发送notify
    if(need_send_process_notify)
    {
        sendCityGuardProcessNotify(main_hero_id, notify_data);
    }
    

    return;
}


//获取昨日战报
void ProcServerThread::DealWithGetCityGuardLastDayReport(Packet* pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealWithGetCityGuardLastDayReport", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_getCityGuardLastDayReport* query = (SPCmd_getCityGuardLastDayReport*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_getCityGuardLastDayReport))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    bool have_reward = false;
    ItemInfo reward;

    //获取玩家奖励信息
    have_reward = heroHasCityGuardReward(main_hero_id, reward);

    //获取昨日战报
    CityGuardReport report;
    getLastCityGuardReport(report);

    //
    int rspDataLen = sizeof(SPCmd_getCityGuardLastDayReportRsp);
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getCityGuardLastDayReportRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_getCityGuardLastDayReportRsp* rspBody = (SPCmd_getCityGuardLastDayReportRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->have_reward = have_reward;

    rspBody->lastday_report.cityguard_total_time = htonl(report.cityguard_total_time);
    
    hton_hero_info(report.hero_kill_boss, rspBody->lastday_report.hero_kill_boss);
    rspBody->lastday_report.hero_kill_reward.type = htonl(report.hero_kill_reward.type);
    rspBody->lastday_report.hero_kill_reward.count = htonl(report.hero_kill_reward.count);

    for(int i=0; i<CITYGUARD_HERO_ORDER_COUNT; ++i)
    {
        hton_hero_info(report.hero_order[i], rspBody->lastday_report.hero_order[i]);
        rspBody->lastday_report.hero_order_reward[i].type = htonl(report.hero_order_reward[i].type);
        rspBody->lastday_report.hero_order_reward[i].count = htonl(report.hero_order_reward[i].count);
    }
    for(int i=0; i<CITYGUARD_LUCKY_COUNT; ++i)
    {
        hton_hero_info(report.hero_lucky[i], rspBody->lastday_report.hero_lucky[i]);
        rspBody->lastday_report.hero_lucky_reward.type = htonl(report.hero_lucky_reward.type);
        rspBody->lastday_report.hero_lucky_reward.count = htonl(report.hero_lucky_reward.count);
    }

    ItemInfo join_reward;
    CS::getCityGuardJoinReward(join_reward);

    rspBody->lastday_report.join_reward.type = htonl(join_reward.type);
    rspBody->lastday_report.join_reward.count = htonl(join_reward.count);

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}

void ProcServerThread::getLastCityGuardReport(CityGuardReport& report)
{
    memset(&report, 0, sizeof(report));
    
    //
    {
        char sql[2048];
        sprintf(sql, "select last_cityguard_total_time, "
            " hero_id_kill_boss, "
            " hero_id_shanghai_order_1, "
            " hero_id_shanghai_order_2, "
            " hero_id_shanghai_order_3, "
            " hero_id_shanghai_order_4, "
            " hero_id_shanghai_order_5, "
            " hero_id_shanghai_order_6, "
            " hero_id_shanghai_order_7, "
            " hero_id_shanghai_order_8, "
            " hero_id_shanghai_order_9, "
            " hero_id_shanghai_order_10, "
            " hero_id_shanghai_order_11, "
            " hero_id_shanghai_order_12, "
            " hero_id_shanghai_order_13, "
            " hero_id_shanghai_order_14, "
            " hero_id_shanghai_order_15, "
            " hero_id_shanghai_order_16, "
            " hero_id_shanghai_order_17, "
            " hero_id_shanghai_order_18, "
            " hero_id_shanghai_order_19, "
            " hero_id_shanghai_order_20, "
            " hero_id_shanghai_lucky_1 , "
            " hero_id_shanghai_lucky_2 , "
            " hero_id_shanghai_lucky_3 , "
            " hero_id_shanghai_lucky_4 , "
            " hero_id_shanghai_lucky_5 , "
            " hero_id_shanghai_lucky_6 , "
            " hero_id_shanghai_lucky_7 , "
            " hero_id_shanghai_lucky_8 , "
            " hero_id_shanghai_lucky_9 , "
            " hero_id_shanghai_lucky_10 "
            " from hellgate.cityguard_last_report "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                report.cityguard_total_time = atoi(Mysql_Thread_Conn->GetField("last_cityguard_total_time"));
                
                report.hero_kill_boss.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id_kill_boss"));

                //
                for(int i=0; i<CITYGUARD_HERO_ORDER_COUNT; ++i)
                {
                    char field_str[64];
                    sprintf(field_str, "hero_id_shanghai_order_%d", i+1);

                    report.hero_order[i].hero_id = atoi(Mysql_Thread_Conn->GetField(field_str));
                }
                //
                for(int i=0; i<CITYGUARD_LUCKY_COUNT; ++i)
                {
                    char field_str[64];
                    sprintf(field_str, "hero_id_shanghai_lucky_%d", i+1);

                    report.hero_lucky[i].hero_id = atoi(Mysql_Thread_Conn->GetField(field_str));
                }
                
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //获得玩家信息
    GetHeroBasicInfo(report.hero_kill_boss.hero_id, report.hero_kill_boss);
    for(int i=0; i<CITYGUARD_HERO_ORDER_COUNT; ++i)
    {
        if(report.hero_order[i].hero_id != 0)
        {
            GetHeroBasicInfo(report.hero_order[i].hero_id, report.hero_order[i]);
        }
        else
        {
            report.hero_order[i].name[0]= 0;
        }
    }
    for(int i=0; i<CITYGUARD_LUCKY_COUNT; ++i)
    {
        if(report.hero_lucky[i].hero_id != 0)
        {
            GetHeroBasicInfo(report.hero_lucky[i].hero_id, report.hero_lucky[i]);
        }
        else
        {
            report.hero_lucky[i].name[0]= 0;
        }
    }

    //获得奖品信息
    CS::getCityGuardKillBossReward(report.hero_kill_reward);
    CS::getCityGuardLuckyReward(report.hero_lucky_reward);
    ItemInfo reward_order_1, reward_order_2, reward_order_3, reward_order_4_10, reward_order_11_20;
    CS::getCityGuardHeroShanghaiOrderReward(reward_order_1,reward_order_2,reward_order_3
        ,reward_order_4_10,reward_order_11_20);
    report.hero_order_reward[0] = reward_order_1;
    report.hero_order_reward[1] = reward_order_2;
    report.hero_order_reward[2] = reward_order_3;
    for(int i=3; i<10; ++i)
    {
        report.hero_order_reward[i] = reward_order_4_10;
    }
    for(int i=10; i<20; ++i)
    {
        report.hero_order_reward[i] = reward_order_11_20;
    }
    
}

//领取自己的奖品
void ProcServerThread::DealWithGetMyCityGuardReward(Packet* pack)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::DealWithGetMyCityGuardReward", __FILE__, __LINE__);
#endif //_DEBUG
    
    char* packdata = pack->packdata;
    SPHead* head = (SPHead*)(packdata);
    SPCmd_GetMyCityGuardReward* query = (SPCmd_GetMyCityGuardReward*)(head+1);
    
    //将head装换为本机字节序
    ntoh_SPHead(head);
    if(head->data_len < sizeof(SPCmd_GetMyCityGuardReward))
    {
        return;
    }

    //将包体转换为本机字节序
    {
        query = query;
    }

    unsigned int main_hero_id = pack->main_hero_id;
    main_hero_id = main_hero_id;

    //
    std::vector<ItemInfo> reward_vec;

    //获取玩家奖励信息
    if(!getAndDelHeroCityGuardReward(main_hero_id, reward_vec))
    {
        //
        int rspDataLen = sizeof(SPCmd_GetMyCityGuardRewardRsp);
        
        SPHead* rspHead;
        (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
        (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
        (rspHead)->protocol_ver = 1;
        (rspHead)->cmd = getMyCityGuardRewardRsp;
        (rspHead)->data_len = rspDataLen;
        //将包头转换为网络字节序
        hton_SPHead((rspHead));
        
        SPCmd_GetMyCityGuardRewardRsp* rspBody = (SPCmd_GetMyCityGuardRewardRsp*)((rspHead)+1);
        rspBody->err_code = htonl(Error);

        Packet* rsppack = new Packet;
        rsppack->fd_account = pack->fd_account;
        rsppack->client_id = pack->client_id;
        rsppack->main_hero_id = pack->main_hero_id;
        rsppack->packdata = (char*)rspHead;

        m_outport_q->push(rsppack);

        return;
    }

    //
    //
    int rspDataLen = sizeof(SPCmd_GetMyCityGuardRewardRsp) + sizeof(ItemInfo)*reward_vec.size();
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = getMyCityGuardRewardRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_GetMyCityGuardRewardRsp* rspBody = (SPCmd_GetMyCityGuardRewardRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->count = htonl(reward_vec.size());
    ItemInfo *p = rspBody->item_arr;
    for(int i=0; i<reward_vec.size(); i++, p++) {
        p->type = htonl(reward_vec[i].type);
        p->count = htonl(reward_vec[i].count);
    }

    Packet* rsppack = new Packet;
    rsppack->fd_account = pack->fd_account;
    rsppack->client_id = pack->client_id;
    rsppack->main_hero_id = pack->main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return;
}


int ProcServerThread::ZBGroupIsShenbing(unsigned int zb_group_id)
{
    for(int i=0; i<m_shenbing_vec.size(); ++i) {
        if(m_shenbing_vec[i].zb_group_id == zb_group_id)
            return i;
    }

    return -1;
}


void ProcServerThread::kickoutFdAcount( std::string fd_account)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::kickoutFdAcount", __FILE__, __LINE__);
#endif //_DEBUG
    unsigned int rspDataLen= sizeof(SPCmd_BeKickOutRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = beKickOutRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_BeKickOutRsp* rspBody = (SPCmd_BeKickOutRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);


    Packet* rsppack = new Packet;
    rsppack->fd_account = fd_account;
    rsppack->client_id = 0;
    rsppack->new_client_id = true;
    rsppack->main_hero_id = 0;
    rsppack->new_main_hero_id = true;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::addAssistAtSpecialTaskGrid(
    unsigned int hero_id,unsigned int task_id,unsigned int grid_id
    , unsigned int& assist_id)
{
    assist_id = 0;
    
    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);
    
    //首先判断是否为特殊关卡，标记需要新增的助手职业
    unsigned int new_assist_prof = 0;
    if(task_id == 2 && isBOSS(task_id,grid_id))
    {
        if(hero_info.profession_id == Profession_Yemanren)
        {
            new_assist_prof = Profession_YouXia;
        }
        else if(hero_info.profession_id == Profession_Chike)
        {
            new_assist_prof = Profession_MiShu;
        }
        else
        {
            new_assist_prof = Profession_Qishi;
        }
    }
    else if(task_id == 3 && isBOSS(task_id,grid_id))
    {
        if(hero_info.profession_id == Profession_Yemanren)
        {
            new_assist_prof = Profession_LieShou;
        }
        else if(hero_info.profession_id == Profession_Chike)
        {
            new_assist_prof = Profession_Qishi;
        }
        else
        {
            
            new_assist_prof = Profession_LieShou;
        }
    }

    if(new_assist_prof == 0)
    {
        return;
    }
    
    //先查询目前团队的所有助手与阵型信息
    bool positions[4] = {false, false, false, false};
    std::vector<unsigned int> prof_vec;
    {
        char sql[1024];
        sprintf(sql, "select position, profession_id "
            " from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and is_yuanshen=0"
            , hero_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                unsigned int position = atoi(Mysql_Thread_Conn->GetField("position"));
                if(position > 0)
                {
                    positions[position-1] = true;
                }

                unsigned int prof = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                prof_vec.push_back(prof);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查看现在队伍中是否已经有此助手
    for(int i=0; i<prof_vec.size(); ++i)
    {
        if(prof_vec[i] == new_assist_prof)
        {
            return;
        }
    }

    //确定占位
    unsigned int new_position = 0;
    if(new_assist_prof == Profession_YouXia
        || new_assist_prof == Profession_Qishi)
    {
        if(positions[0] == false)
        {
            new_position = 1;
        }
        else if(positions[1] == false)
        {
            new_position = 2;
        }
        else if(positions[2] == false)
        {
            new_position = 3;
        }
        else if(positions[3] == false)
        {
            new_position = 4;
        }
        else
        {
            LogMsg("%s, line %d, shit hero_id=[%u]"
                        , __FILE__, __LINE__, hero_id);
            assert(false);
            return;
        }
    }
    else
    {
        if(positions[2] == false)
        {
            new_position = 3;
        }
        else if(positions[3] == false)
        {
            new_position = 4;
        }
        else if(positions[0] == false)
        {
            new_position = 1;
        }
        else if(positions[1] == false)
        {
            new_position = 2;
        }
        else
        {
            LogMsg("%s, line %d, shit hero_id=[%u]"
                        , __FILE__, __LINE__, hero_id);
            assert(false);
            return;
        }
    }
    if(new_position == 0)
    {
        LogMsg("%s, line %d, shit hero_id=[%u]"
                        , __FILE__, __LINE__, hero_id);
        assert(false);
        return;
    }

    assist_id = createAssitant(hero_id,new_assist_prof);
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set position=%u "
                    "where hero_id=%u"
                    , new_position, assist_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }



    return ;
}

void ProcServerThread::sendNewAssistJoinRsp(unsigned int main_hero_id,unsigned int assist_id)
{
    //获取hero detail
    HeroDetail hero_detail;
    GetHeroDetail(assist_id, hero_detail);

    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_id"
            " from hellgate.zhuangbei_list"
            " where zhuangbei_hero_id=%u"
            , assist_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
    }
    
    //skill
    //
    SkillInfo skill;
    //查询
    {
        char sql[1024];
        sprintf(sql, "select own_hero_id, skill_id, skill_type, skill_level, is_equiped "
            " from hellgate.skill_in_team where own_hero_id=%u"
            , assist_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                skill.owner_hero_id = atoi(Mysql_Thread_Conn->GetField("own_hero_id"));
                skill.skill_id = atoi(Mysql_Thread_Conn->GetField("skill_id"));
                skill.skill_type = atoi(Mysql_Thread_Conn->GetField("skill_type"));
                skill.skill_level = atoi(Mysql_Thread_Conn->GetField("skill_level"));
                skill.is_equiped = (bool)atoi(Mysql_Thread_Conn->GetField("is_equiped"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_NewAssistantJoinRsp) + zhuangbei_detail_data_len;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = newAssistantJoinRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_NewAssistantJoinRsp* rspBody = (SPCmd_NewAssistantJoinRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    //
    hton_hero_detail(hero_detail,rspBody->hero_detail);

    //skill
    rspBody->skill.skill_id = htonl(skill.skill_id);
    rspBody->skill.skill_type = htonl(skill.skill_type);
    rspBody->skill.skill_level = htonl(skill.skill_level);
    rspBody->skill.owner_hero_id = htonl(skill.owner_hero_id);
    rspBody->skill.is_equiped = (skill.is_equiped);

    //
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);
    

    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = main_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    
    return;
}

void ProcServerThread::heroOperatioWhenLevelUpgrade(unsigned int hero_id, unsigned int new_level)
{
    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);

    if(new_level == 5) //5级奖励
    {
        send_system_bonus_notify(hero_id, BonusType_Level, LevelBonusID_5);
        //insert_and_send_email(hero_id, 0, EmailType_Bonus, EmailID_Present_Weapon);
    }
    else if(new_level == 6)//开放新助手
    {
        if(hero_info.profession_id == Profession_Yemanren)
        {
            unsigned int assist_id = createAssitant(hero_id, Profession_Qishi, false, false);
            sendNewAssistJoinRsp(hero_id, assist_id);
            
            assist_id = createAssitant(hero_id, Profession_ShenJianShou, false, false);
            sendNewAssistJoinRsp(hero_id, assist_id);
        }
        else if(hero_info.profession_id == Profession_Chike)
        {
            unsigned int assist_id = createAssitant(hero_id, Profession_ShenJianShou, false, false);
            sendNewAssistJoinRsp(hero_id, assist_id);
            
            assist_id = createAssitant(hero_id, Profession_YouXia, false, false);
            sendNewAssistJoinRsp(hero_id, assist_id);
        }
        else
        {
            unsigned int assist_id = createAssitant(hero_id, Profession_MiShu, false, false);
            sendNewAssistJoinRsp(hero_id, assist_id);
            
            assist_id = createAssitant(hero_id, Profession_ShenJianShou, false, false);
            sendNewAssistJoinRsp(hero_id, assist_id);
        }
        
        unsigned int assist_id = createAssitant(hero_id, Profession_WuShi, false, false);
        sendNewAssistJoinRsp(hero_id, assist_id);
        
        assist_id = createAssitant(hero_id, Profession_WuSeng, false, false);
        sendNewAssistJoinRsp(hero_id, assist_id);
    }
    else if(new_level == 10) //10级奖励
    {
        send_system_bonus_notify(hero_id, BonusType_Level, LevelBonusID_10);
    }
    else if(new_level == 15) //15级奖励
    { 
        send_system_bonus_notify(hero_id, BonusType_Level, LevelBonusID_15);
    }
    else if(new_level == 20) //20级奖励
    {
        send_system_bonus_notify(hero_id, BonusType_Level, LevelBonusID_20);
    }
    else if(new_level == 25) //25级奖励
    {
        send_system_bonus_notify(hero_id, BonusType_Level, LevelBonusID_25);
    }
    else if(new_level == 30) //30级奖励
    {
        send_system_bonus_notify(hero_id, BonusType_Level, LevelBonusID_30);
    }

    if(new_level == CS::getUnlockAbleHeroLevel()){
        if(hero_info.profession_id == Profession_Yemanren) {
            make_assitant_unlock_able(hero_id, Profession_Qishi);
            make_assitant_unlock_able(hero_id, Profession_ShenJianShou);
        }
        else if(hero_info.profession_id == Profession_Chike) {
            make_assitant_unlock_able(hero_id, Profession_ShenJianShou);
            make_assitant_unlock_able(hero_id, Profession_YouXia);
        }
        else {
            make_assitant_unlock_able(hero_id, Profession_MiShu);
            make_assitant_unlock_able(hero_id, Profession_ShenJianShou);
        }
        
        make_assitant_unlock_able(hero_id, Profession_WuShi);
        make_assitant_unlock_able(hero_id, Profession_WuSeng);
    }

    return;
}


void ProcServerThread::getGroupTypeAndName(unsigned int group_id
    ,unsigned int & zb_type, std::string & zb_name)
{
    if(group_id != 0)
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_type, zhuangbei_name"
            " from hellgate.zhuangbei_name_list_copy "
            " where group_id=%u limit 1 "
            , group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                _SuitInfoDB info;
                
                zb_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zb_name = Mysql_Thread_Conn->GetField("zhuangbei_name");
                
            }
            else
            {
                LogMsg("%s, line %d, group_id[%u] illegal."
                        , __FILE__, __LINE__, group_id);
                assert(false);
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

void ProcServerThread::suitDBAttr2CommonAttr( std::string str_attr_vec[],ZBAttr attr_arr[][2])
{
    for(int attr_index=0; attr_index<5; ++attr_index)
    {
        attr_arr[attr_index][0].attr_type = 0;
        attr_arr[attr_index][1].attr_type = 0; 

        if(str_attr_vec[attr_index].length() == 0)
        {
            return;
        }

        
        //取出所有键值对
        std::list<std::string> key_list;
        std::list<std::string> value_list;
        Str2KeyValueList(str_attr_vec[attr_index], key_list, value_list);

        //
        if(key_list.size()>5 || key_list.size()==0)
        {
            LogMsg("%s, line %d, str_attr[%s] error."
                    , __FILE__, __LINE__, str_attr_vec[attr_index].c_str());
            return;
        }
        

        //填写属性值
        std::list<std::string>::iterator pos_key = key_list.begin();
        std::list<std::string>::iterator pos_value = value_list.begin();
        for(int i=0; pos_key!=key_list.end(); ++pos_key, ++pos_value)
        {
            
            attr_arr[attr_index][i].attr_value = atoi(pos_value->c_str());

            if(*pos_key == ZB_Key_gailv || *pos_key == ZB_Key_count)
            {
                //忽略
                continue;
            }

            if(*pos_key == ZB_Key_liliang)
            {
                attr_arr[attr_index][i].attr_type = AttrType_liliang;
            }
            else if(*pos_key == ZB_Key_mingjie)
            {
                attr_arr[attr_index][i].attr_type = AttrType_mingjie;
            }
            else if(*pos_key == ZB_Key_zhili)
            {
                attr_arr[attr_index][i].attr_type = AttrType_zhili;
            }
            else if(*pos_key == ZB_Key_tineng)
            {
                attr_arr[attr_index][i].attr_type = AttrType_tineng;
            }
            else if(*pos_key == ZB_Key_kangxing)
            {
                attr_arr[attr_index][i].attr_type = AttrType_kangxing;
            }
            else if(*pos_key == ZB_Key_baoji)
            {
                attr_arr[attr_index][i].attr_type = AttrType_baoji;
            }
            else if(*pos_key == ZB_Key_baoshang)
            {
                attr_arr[attr_index][i].attr_type = AttrType_baoshang;
            }
            else if(*pos_key == ZB_Key_hp_ration)
            {
                attr_arr[attr_index][i].attr_type = AttrType_hp_percent;
            }
            else if(*pos_key == ZB_Key_gedanglv)
            {
                attr_arr[attr_index][i].attr_type = AttrType_gedanglv;
            }
            else if(*pos_key == ZB_Key_gedangzhi)
            {
                attr_arr[attr_index][i].attr_type = AttrType_gedangzhi;
            }
            else if(*pos_key == ZB_Key_gongji_min_add)
            {
                attr_arr[attr_index][i].attr_type = AttrType_gongji_min;
            }
            else if(*pos_key == ZB_Key_gongji_max_add)
            {
                attr_arr[attr_index][i].attr_type = AttrType_gongji_max;
            }
            else if(*pos_key == ZB_Key_hujia_add)
            {
                attr_arr[attr_index][i].attr_type = AttrType_hujia_add;
            }
            else if(*pos_key == ZB_Key_skill_zhouqi)
            {
                attr_arr[attr_index][i].attr_type = AttrType_skillzhouqi;
            }
            else if(*pos_key == ZB_Key_skill_turn)
            {
                attr_arr[attr_index][i].attr_type = AttrType_skillturn;
            }
            else if(*pos_key == ZB_Key_skill_result)
            {
                attr_arr[attr_index][i].attr_type = AttrType_skillresult;
            }
            else if(*pos_key == ZB_Key_actor_gongji_add_ratio)
            {
                attr_arr[attr_index][i].attr_type = AttrType_actor_gongji_addratio;
            }
            else if(*pos_key == ZB_Key_actor_hp_add_ratio)
            {
                attr_arr[attr_index][i].attr_type = AttrType_actor_hp_addratio;
            }
            else
            {
                LogMsg("%s, line %d, str_attr[%s] error."
                    , __FILE__, __LINE__, str_attr_vec[attr_index].c_str());
                return;
            }

            //
            ++i;
        }
    }
}

void ProcServerThread::loadSuit()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::loadSuit", __FILE__, __LINE__);
#endif //_DEBUG

    std::vector<_SuitInfoDB> suit_db_vector;
    {
        char sql[1024];
        sprintf(sql, "select suit_id, suit_name, "
            " group_id_1, group_id_2, group_id_3, group_id_4, group_id_5, group_id_6, "
            " attr_1, attr_2, attr_3, attr_4, attr_5"
            " from hellgate.suit_name_list "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                _SuitInfoDB info;
                
                info.suit_id = atoi(Mysql_Thread_Conn->GetField("suit_id"));
                info.name = Mysql_Thread_Conn->GetField("suit_name");
                info.group_id[0] = atoi(Mysql_Thread_Conn->GetField("group_id_1"));
                info.group_id[1] = atoi(Mysql_Thread_Conn->GetField("group_id_2"));
                info.group_id[2] = atoi(Mysql_Thread_Conn->GetField("group_id_3"));
                info.group_id[3] = atoi(Mysql_Thread_Conn->GetField("group_id_4"));
                info.group_id[4] = atoi(Mysql_Thread_Conn->GetField("group_id_5"));
                info.group_id[5] = atoi(Mysql_Thread_Conn->GetField("group_id_6"));
                info.attr[0] = Mysql_Thread_Conn->GetField("attr_1");
                info.attr[1] = Mysql_Thread_Conn->GetField("attr_2");
                info.attr[2] = Mysql_Thread_Conn->GetField("attr_3");
                info.attr[3] = Mysql_Thread_Conn->GetField("attr_4");
                info.attr[4] = Mysql_Thread_Conn->GetField("attr_5");
                
                suit_db_vector.insert(suit_db_vector.end(), info);
                //

            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<suit_db_vector.size(); ++i)
    {
        SuitNameInfo suit;
        
        suit.suit_id = suit_db_vector[i].suit_id;
        strncpy(suit.suit_name, suit_db_vector[i].name.c_str(), ZhuangbeiNameMaxLen);
        suit.suit_name[ZhuangbeiNameMaxLen] = 0;

        // 1
        {
            unsigned int group_id = suit_db_vector[i].group_id[0];
            unsigned int zb_type = 0;
            std::string zb_name;
            if(group_id != 0)
            {
                getGroupTypeAndName(group_id, zb_type, zb_name);
            }

            suit.group_id_1 = group_id;
            suit.zhuangbei_type_1 = zb_type;
            strncpy(suit.zhuangbei_name_1, zb_name.c_str(), ZhuangbeiNameMaxLen);
            suit.zhuangbei_name_1[ZhuangbeiNameMaxLen] = 0;
        }

        // 2
        {
            unsigned int group_id = suit_db_vector[i].group_id[1];
            unsigned int zb_type = 0;
            std::string zb_name;
            if(group_id != 0)
            {
                getGroupTypeAndName(group_id, zb_type, zb_name);
            }

            suit.group_id_2 = group_id;
            suit.zhuangbei_type_2 = zb_type;
            strncpy(suit.zhuangbei_name_2, zb_name.c_str(), ZhuangbeiNameMaxLen);
            suit.zhuangbei_name_2[ZhuangbeiNameMaxLen] = 0;
        }

        // 3
        {
            unsigned int group_id = suit_db_vector[i].group_id[2];
            unsigned int zb_type = 0;
            std::string zb_name;
            if(group_id != 0)
            {
                getGroupTypeAndName(group_id, zb_type, zb_name);
            }

            suit.group_id_3 = group_id;
            suit.zhuangbei_type_3 = zb_type;
            strncpy(suit.zhuangbei_name_3, zb_name.c_str(), ZhuangbeiNameMaxLen);
            suit.zhuangbei_name_3[ZhuangbeiNameMaxLen] = 0;
        }

        // 4
        {
            unsigned int group_id = suit_db_vector[i].group_id[3];
            unsigned int zb_type = 0;
            std::string zb_name;
            if(group_id != 0)
            {
                getGroupTypeAndName(group_id, zb_type, zb_name);
            }

            suit.group_id_4 = group_id;
            suit.zhuangbei_type_4 = zb_type;
            strncpy(suit.zhuangbei_name_4, zb_name.c_str(), ZhuangbeiNameMaxLen);
            suit.zhuangbei_name_4[ZhuangbeiNameMaxLen] = 0;
        }

        // 5
        {
            unsigned int group_id = suit_db_vector[i].group_id[4];
            unsigned int zb_type = 0;
            std::string zb_name;
            if(group_id != 0)
            {
                getGroupTypeAndName(group_id, zb_type, zb_name);
            }

            suit.group_id_5 = group_id;
            suit.zhuangbei_type_5 = zb_type;
            strncpy(suit.zhuangbei_name_5, zb_name.c_str(), ZhuangbeiNameMaxLen);
            suit.zhuangbei_name_5[ZhuangbeiNameMaxLen] = 0;
        }

        // 6
        {
            unsigned int group_id = suit_db_vector[i].group_id[5];
            unsigned int zb_type = 0;
            std::string zb_name;
            if(group_id != 0)
            {
                getGroupTypeAndName(group_id, zb_type, zb_name);
            }

            suit.group_id_6 = group_id;
            suit.zhuangbei_type_6 = zb_type;
            strncpy(suit.zhuangbei_name_6, zb_name.c_str(), ZhuangbeiNameMaxLen);
            suit.zhuangbei_name_6[ZhuangbeiNameMaxLen] = 0;
        }

        //
        suitDBAttr2CommonAttr(suit_db_vector[i].attr,suit.suit_attr);


        //
        m_suit_vec.push_back(suit);
    }

    //初始化战斗计算
    {
        std::vector<OneSuitInfo> suit_vec;
        for(int i=0; i<m_suit_vec.size(); ++i)
        {
            OneSuitInfo info;

            info.suit_id = m_suit_vec[i].suit_id;
            info.suit_name = m_suit_vec[i].suit_name;

            //
            if(m_suit_vec[i].group_id_1 != 0) {
                SuitPart part;
                part.group_ids.push_back(m_suit_vec[i].group_id_1);
                part.zhuanbei_type = (ZhuangbeiType)m_suit_vec[i].zhuangbei_type_1;
                part.zhuangbei_name = m_suit_vec[i].zhuangbei_name_1;
                info.parts_of_suit.push_back(part);
            }
            if(m_suit_vec[i].group_id_2 != 0) {
                SuitPart part;
                part.group_ids.push_back(m_suit_vec[i].group_id_2);
                part.zhuanbei_type = (ZhuangbeiType)m_suit_vec[i].zhuangbei_type_2;
                part.zhuangbei_name = m_suit_vec[i].zhuangbei_name_2;
                info.parts_of_suit.push_back(part);
            }
            if(m_suit_vec[i].group_id_3 != 0) {
                SuitPart part;
                part.group_ids.push_back(m_suit_vec[i].group_id_3);
                part.zhuanbei_type = (ZhuangbeiType)m_suit_vec[i].zhuangbei_type_3;
                part.zhuangbei_name = m_suit_vec[i].zhuangbei_name_3;
                info.parts_of_suit.push_back(part);
            }
            if(m_suit_vec[i].group_id_4 != 0) {
                SuitPart part;
                part.group_ids.push_back(m_suit_vec[i].group_id_4);
                part.zhuanbei_type = (ZhuangbeiType)m_suit_vec[i].zhuangbei_type_4;
                part.zhuangbei_name = m_suit_vec[i].zhuangbei_name_4;
                info.parts_of_suit.push_back(part);
            }
            if(m_suit_vec[i].group_id_5 != 0) {
                SuitPart part;
                part.group_ids.push_back(m_suit_vec[i].group_id_5);
                part.zhuanbei_type = (ZhuangbeiType)m_suit_vec[i].zhuangbei_type_5;
                part.zhuangbei_name = m_suit_vec[i].zhuangbei_name_5;
                info.parts_of_suit.push_back(part);
            }
            if(m_suit_vec[i].group_id_6 != 0) {
                SuitPart part;
                part.group_ids.push_back(m_suit_vec[i].group_id_6);
                part.zhuanbei_type = (ZhuangbeiType)m_suit_vec[i].zhuangbei_type_6;
                part.zhuangbei_name = m_suit_vec[i].zhuangbei_name_6;
                info.parts_of_suit.push_back(part);
            }

            info.suit_attr[0][0] = m_suit_vec[i].suit_attr[0][0];
            info.suit_attr[0][1] = m_suit_vec[i].suit_attr[0][1];
            info.suit_attr[1][0] = m_suit_vec[i].suit_attr[1][0];
            info.suit_attr[1][1] = m_suit_vec[i].suit_attr[1][1];
            info.suit_attr[2][0] = m_suit_vec[i].suit_attr[2][0];
            info.suit_attr[2][1] = m_suit_vec[i].suit_attr[2][1];
            info.suit_attr[3][0] = m_suit_vec[i].suit_attr[3][0];
            info.suit_attr[3][1] = m_suit_vec[i].suit_attr[3][1];
            info.suit_attr[4][0] = m_suit_vec[i].suit_attr[4][0];
            info.suit_attr[4][1] = m_suit_vec[i].suit_attr[4][1];

            //
            suit_vec.push_back(info);
        }

        //初始化套装 现在只有5级套装
        SuitPool::getPool()->initSuit(suit_vec);

        //串联套装各个配件
        for(int i=0; i<suit_vec.size(); i++) { //一套套装
            std::vector<SuitPart> parts_of_suit = suit_vec[i].parts_of_suit;
            
            for(int j=0; j<parts_of_suit.size(); j++) {//一种配件
                std::vector<unsigned int> tmp_group_ids;
                unsigned int group_id = parts_of_suit[j].group_ids[0];
                tmp_group_ids.push_back(group_id);

                while(group_id != 0){
                    int index = ZBGroupIsShenbing(group_id); //获取在神兵库的位置
                    if(index == -1) //在神兵库没有找到
                        break;
                    
                    if(m_shenbing_vec[index].next_group_id != 0) {
                        group_id = m_shenbing_vec[index].next_group_id;
                        tmp_group_ids.push_back(group_id);
                    }
                    else 
                        break;
                }

                SuitPool::getPool()->combineGroupIdsIntoSuitPart(tmp_group_ids, suit_vec[i].suit_id);
            }
        }
        
    }
    
}


struct __ShenBing_List{
    unsigned int group_id;
    unsigned int next_group_id; // 升级下一个等级的装备ID
    unsigned int level;         // 当前等级
    unsigned int need_expend_group_id; //吞噬传奇装备的groupid
};

void ProcServerThread::loadShenbing()
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::loadShenbing", __FILE__, __LINE__);
#endif //_DEBUG

    //
    std::vector<__ShenBing_List> group_id_vec;
    {
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.shenbing_id_list "
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ShenBing_List sb_list;
                sb_list.group_id = atoi(Mysql_Thread_Conn->GetField("zb_group_id"));
                sb_list.next_group_id = atoi(Mysql_Thread_Conn->GetField("next_level_group_id"));
                sb_list.level = atoi(Mysql_Thread_Conn->GetField("zb_level"));
                sb_list.need_expend_group_id = atoi(Mysql_Thread_Conn->GetField("next_level_need_id"));
                
                group_id_vec.push_back(sb_list);
                //

            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //加载group信息
    for(int i=0; i<group_id_vec.size(); ++i)
    {
        __DuanzaoGroupZBInfo info;
        if(query_duanzao_group_zb_info(group_id_vec[i].group_id, info)) {
            info.next_group_id = group_id_vec[i].next_group_id;
            info.need_expend_group_id = group_id_vec[i].need_expend_group_id;
            m_shenbing_vec.push_back(info);
        }
    }

}

#define SystemDailyTask_ID_Richang 1
#define SystemDailyTask_ID_ShouchengJiesuan 2
struct _SystemDailyTaskInfo
{
    unsigned int task_id;
    unsigned int last_finish_time;
};

//每日全系统刷新定时处理
void ProcServerThread::SystemRefreshTimer()
{
    time_t cur_time = time(0);
    tm* p_tm = localtime(&cur_time);
    //int wek_day = p_tm->tm_wday;
    //int hour = p_tm->tm_hour;
    //int minutes = p_tm->tm_min;
    int sec = p_tm->tm_sec;


    //每分钟检查一次
    if(sec != 1)
    {
        return;
    }

    //
    std::vector<_SystemDailyTaskInfo> task_vec;
    {
        char sql[1024];
        sprintf(sql, "select task_id, last_finish_time "
            " from hellgate.system_daily_refresh_task ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                _SystemDailyTaskInfo info;
                
                info.task_id = atoi(Mysql_Thread_Conn->GetField("task_id"));
                info.last_finish_time = atoi(Mysql_Thread_Conn->GetField("last_finish_time"));

                task_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //检查今日是否还有未完成的任务
    for(int i=0; i<task_vec.size(); ++i)
    {
        bool should_do = isNeedSystemDailyRefresh(task_vec[i].last_finish_time,SystemDailyTask_Hour);
        

        if(!should_do)
        {
            continue;
        }

        if(task_vec[i].task_id == SystemDailyTask_ID_Richang)
        {
            refreshSubtask_Richang();

            char sql[1024];
            sprintf(sql, "update hellgate.system_daily_refresh_task "
                " set last_finish_time=%u where task_id=%u"
                , (unsigned int)cur_time, SystemDailyTask_ID_Richang);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
    }
}

void ProcServerThread::refreshSubtask_Richang()
{
    LogMsg("%s, line %d, refreshSubtask_Richang"
                        , __FILE__, __LINE__);
    
    //先删除所有日常任务
    {
        char sql[1024];
        sprintf(sql, "delete from hellgate.hero_subtask where task_id in "
            " (select task_id from hellgate.subtask_list where task_type=%u) "
            , SubTaskType_Richang);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //在给所有满足条件的玩家刷新
    std::vector<unsigned int> hero_vec;
    {
        char sql[1024];
        sprintf(sql, "select hero_id "
            " from hellgate.hero_infor where parent_hero_id=0 and level>5 ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                hero_vec.push_back(hero_id);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<hero_vec.size(); ++i)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_subtask "
            " set hero_id=%u, task_id=%u, task_status=%u; "
            , hero_vec[i], SubtaskId_Richang_jingjichang_duanzaocailiao, TaskStatus_Got);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }


        sprintf(sql, "insert into hellgate.hero_subtask "
            " set hero_id=%u, task_id=%u, task_status=%u; "
            , hero_vec[i], SubtaskId_Richang_teamboss_duanzaocailiao, TaskStatus_Got);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
}

void ProcServerThread::topArenaTimer()
{
    time_t cur_time = time(NULL);
    tm* p_tm = localtime(&cur_time);
    int wek_day = p_tm->tm_wday;
    int hour = p_tm->tm_hour;

    int diy_wek_day = 0;

    //已凌晨4点为每日刷新时间
    switch(wek_day){ 
        case 3:     //星期三
            if(hour >= SystemDailyTask_Hour){
                diy_wek_day = 3;
            } 
            break;
        case 4:     //星期四
            if(hour >= SystemDailyTask_Hour){
                diy_wek_day = 4;
            } else {
                diy_wek_day = 3;
            }
            break;
        case 5:     //星期五
            if(hour >= SystemDailyTask_Hour){
                diy_wek_day = 5;
            } else {
                diy_wek_day = 4;
            }
            break;
        case 6:     //星期六
            if(hour >= SystemDailyTask_Hour){
                diy_wek_day = 6;
            }
            else{
                diy_wek_day = 5;

            }
        case 0:     //星期日
            if(hour < SystemDailyTask_Hour){
                diy_wek_day = 6;
            }
            break;
    }

    //diy_wek_day = 4;

    //处理
    CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);
    if(m_toparena.round == TopArenaRoundType_NUL){
        if(m_toparena.next_top_arena_time == 0) {
            time_t next_time;
            tm* next_tm;
            if(wek_day < 3) { //没有超过周3 直接加至这周3
                next_time = cur_time + (3-wek_day)*86400;
                next_tm = localtime(&cur_time);
            }
            else { //超过周3 加至下周3
                next_time = cur_time + (7- (wek_day -3))*86400;
                next_tm = localtime(&cur_time);
            }
            next_tm->tm_hour = CITYGUARD_OPEN_HOUR_1;
            next_tm->tm_min = 0;   
            next_tm->tm_sec = 0;
            m_toparena.next_top_arena_time = mktime(next_tm);
        }
    }
    else {
        if(m_toparena.next_top_arena_time != 0) {
            m_toparena.next_top_arena_time = 0;
        }
    }
    
    switch(diy_wek_day){
        case 3:     //星期三
            if(m_toparena.round != TopArenaRoundType_8_4){
                m_toparena.round = TopArenaRoundType_8_4;
                //准备top8选手
                topArenaReadyPlayer();
            }
            break;
        case 4:     //星期四
            if(m_toparena.round != TopArenaRoundType_4_2){
                m_toparena.round = TopArenaRoundType_4_2;
                //8-4 fight
                topArenaFight_8_4();
                //发放竞猜结果
                //topArenaAwardGuess(TopArenaRoundType_8_4);
            }
            break;
        case 5:     //星期五
            if(m_toparena.round != TopArenaRoundType_2_1){
                m_toparena.round = TopArenaRoundType_2_1;
                //4-2 fight
                topArenaFight_4_2();
                //清除8-4竞猜结果并发到系统奖励池
                //topArenaAwardtoSystem(TopArenaRoundType_8_4);
                //发放4-2竞猜结果
                //topArenaAwardGuess(TopArenaRoundType_4_2);
            }
            break;
        case 6:     //星期六
            if(m_toparena.round != TopArenaRoundType_NUL){
                m_toparena.round = TopArenaRoundType_NUL;
                //2-1 fight
                topArenaFight_2_1();
                
                //8强已经产生 开始颁奖
                topArenaAwardTop8();
                //清除4-2竞猜结果并发到系统奖励池
                //topArenaAwardtoSystem(TopArenaRoundType_4_2);
                //发放2-1竞猜结果
                //topArenaAwardGuess(TopArenaRoundType_2_1);
                //m_toparena.last_guess_clear = true;
            }
            break;
        //case 0:     //星期日
            //if(m_toparena.last_guess_clear){
                //清除2-1竞猜结果并发到系统奖励池
              //  topArenaAwardtoSystem(TopArenaRoundType_2_1);
               // m_toparena.last_guess_clear = false;
            //}
            //break;
        default:
            m_toparena.round = TopArenaRoundType_NUL;
            break;
    }
}

void ProcServerThread::loadTopArenaData_8_4()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::loadTopArenaData_8_4", __FILE__, __LINE__);
#endif //_DEBUG

    const int count = 4;
    bool b_is_record = false;
    TopArenaStat stat;

    TopArenaInfo info_arr[count];           //参赛选手信息
    TopArenaHeroValue value_arr[count];     //身价
    TopArenaScriptInfo script_arr[count];   //战斗脚本

    //加载数据
    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.top_arena_game_8_4 ");
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                b_is_record = true;
                char hero_field[16];
                char result_field[16];
                char script_field[16];
                
                stat = (TopArenaStat)atoi(Mysql_Thread_Conn->GetField("game_stat"));

                for(int i=0; i<count; i++) {
                    sprintf(hero_field, "hero_team_%d_a", i+1);
                    info_arr[i].hero_a.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(hero_field, "hero_team_%d_b", i+1);
                    info_arr[i].hero_b.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(result_field, "result_%d", i+1);
                    info_arr[i].winer = !(bool)atoi(Mysql_Thread_Conn->GetField(result_field));

                    sprintf(hero_field, "value_%d_a", i+1);
                    value_arr[i].value_a = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(hero_field, "value_%d_b", i+1);
                    value_arr[i].value_b = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    
                    for(int j=0; j<3; j++){
                        sprintf(script_field, "script_team_%d_%d", i+1, j+1);
                        int script_len = 0;
                        char* script = Mysql_Thread_Conn->GetFieldBinary(script_field, script_len);
                        if(script != NULL) {
                            script_arr[i].script[j] = new char[script_len];
                            memcpy(script_arr[i].script[j], script, script_len);
                            script_arr[i].len[j] = script_len;
                        }
                    }
                    
                }

                
            }
            else {
            } 
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(b_is_record)
    {
        //填充选手信息
        for(int i=0; i<count; i++) {
            GetHeroBasicInfo(info_arr[i].hero_a.hero_id, info_arr[i].hero_a);
            GetHeroBasicInfo(info_arr[i].hero_b.hero_id, info_arr[i].hero_b);
        }

        //获取锁
        CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);

        //m_toparena.round_info_record[0] = true;
        m_toparena.stat[0] = stat;

        if(stat == TopArenaStat_Invalide)
            m_toparena.round = TopArenaRoundType_NUL;
        else if(stat == TopArenaStat_GuessOpen)
            m_toparena.round = TopArenaRoundType_8_4;
        else if(stat == TopArenaStat_Finished)
            m_toparena.round = TopArenaRoundType_4_2;
        
        for(int i=0; i<count; i++) {
            //m_toparena.player_arr_8_4[i].round = TopArenaRoundType_8_4;
            //m_toparena.player_arr_8_4[i].hero_a= hero_info_arr[i*2];
            //m_toparena.player_arr_8_4[i].hero_b= hero_info_arr[i*2 +1];
            //m_toparena.player_arr_8_4[i].winer = game_reault_arr[i];

            memcpy(&m_toparena.player_arr_8_4[i], &info_arr[i], sizeof(TopArenaInfo));
            memcpy(&m_toparena.value_arr_8_4[i], &value_arr[i], sizeof(TopArenaHeroValue));
        }

        for(int i=0; i<count; i++) {
            
            for(int j=0; j<3; j++) {
                m_toparena.script_arr_8_4[i].len[j] = script_arr[i].len[j];
                m_toparena.script_arr_8_4[i].script[j] = new char[script_arr[i].len[j]];
                memcpy(m_toparena.script_arr_8_4[i].script[j], script_arr[i].script[j], script_arr[i].len[j]);
            }
        }
    }
    
}

void ProcServerThread::loadTopArenaData_4_2()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::loadTopArenaData_4_2", __FILE__, __LINE__);
#endif //_DEBUG

    const int count = 2;
    bool b_is_record = false;
    TopArenaStat stat;

    TopArenaInfo info_arr[count];           //参赛选手信息
    TopArenaHeroValue value_arr[count];     //身价
    TopArenaScriptInfo script_arr[count];   //战斗脚本

    //加载数据
    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.top_arena_game_4_2 ");
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                b_is_record = true;
                char hero_field[16];
                char result_field[16];
                char script_field[16];
                
                stat = (TopArenaStat)atoi(Mysql_Thread_Conn->GetField("game_stat"));

                for(int i=0; i<count; i++) {
                    sprintf(hero_field, "hero_team_%d_a", i+1);
                    info_arr[i].hero_a.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(hero_field, "hero_team_%d_b", i+1);
                    info_arr[i].hero_b.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(result_field, "result_%d", i+1);
                    info_arr[i].winer = !(bool)atoi(Mysql_Thread_Conn->GetField(result_field));

                    sprintf(hero_field, "value_%d_a", i+1);
                    value_arr[i].value_a = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(hero_field, "value_%d_b", i+1);
                    value_arr[i].value_b = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    
                    for(int j=0; j<3; j++){
                        sprintf(script_field, "script_team_%d_%d", i+1, j+1);
                        int script_len = 0;
                        char* script = Mysql_Thread_Conn->GetFieldBinary(script_field, script_len);
                        if(script != NULL) {
                            script_arr[i].script[j] = new char[script_len];
                            memcpy(script_arr[i].script[j], script, script_len);
                            script_arr[i].len[j] = script_len;
                        }
                    }
                }

                
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(b_is_record)
    {
        //填充选手信息
        for(int i=0; i<count; i++) {
            GetHeroBasicInfo(info_arr[i].hero_a.hero_id, info_arr[i].hero_a);
            GetHeroBasicInfo(info_arr[i].hero_b.hero_id, info_arr[i].hero_b);
        }

        //获取锁
        CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);

        //m_toparena.round_info_record[1] = true;
        m_toparena.stat[1] = stat;
        if(stat == TopArenaStat_GuessOpen)
            m_toparena.round = TopArenaRoundType_4_2;
        else if(stat == TopArenaStat_Finished)
            m_toparena.round = TopArenaRoundType_2_1;
        
        
        for(int i=0; i<count; i++) {
            memcpy(&m_toparena.player_arr_4_2[i], &info_arr[i], sizeof(TopArenaInfo));
            memcpy(&m_toparena.value_arr_4_2[i], &value_arr[i], sizeof(TopArenaHeroValue));
        }

        for(int i=0; i<count; i++) {
            for(int j=0; j<3; j++) {
                m_toparena.script_arr_4_2[i].len[j] = script_arr[i].len[j];
                m_toparena.script_arr_4_2[i].script[j] = new char[script_arr[i].len[j]];
                memcpy(m_toparena.script_arr_4_2[i].script[j], script_arr[i].script[j], script_arr[i].len[j]);
            }
        }
    }
    
}

void ProcServerThread::loadTopArenaData_2_1()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::loadTopArenaData_2_1", __FILE__, __LINE__);
#endif //_DEBUG

    const int count = 1;
    bool b_is_record = false;
    TopArenaStat stat;

    TopArenaInfo info_arr[count];           //参赛选手信息
    TopArenaHeroValue value_arr[count];     //身价
    TopArenaScriptInfo script_arr[count];   //战斗脚本

    //加载数据
    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.top_arena_game_2_1 ");
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                b_is_record = true;
                char hero_field[16];
                char result_field[16];
                char script_field[16];
                
                stat = (TopArenaStat)atoi(Mysql_Thread_Conn->GetField("game_stat"));

                for(int i=0; i<count; i++) {
                    sprintf(hero_field, "hero_team_%d_a", i+1);
                    info_arr[i].hero_a.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(hero_field, "hero_team_%d_b", i+1);
                    info_arr[i].hero_b.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(result_field, "result_%d", i+1);
                    info_arr[i].winer = !(bool)atoi(Mysql_Thread_Conn->GetField(result_field));

                    sprintf(hero_field, "value_%d_a", i+1);
                    value_arr[i].value_a = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    sprintf(hero_field, "value_%d_b", i+1);
                    value_arr[i].value_b = atoi(Mysql_Thread_Conn->GetField(hero_field));
                    
                    for(int j=0; j<3; j++){
                        sprintf(script_field, "script_team_%d_%d", i+1, j+1);
                        int script_len = 0;
                        char* script = Mysql_Thread_Conn->GetFieldBinary(script_field, script_len);
                        if(script != NULL) {
                            script_arr[i].script[j] = new char[script_len];
                            memcpy(script_arr[i].script[j], script, script_len);
                            script_arr[i].len[j] = script_len;
                        }
                    }
                }

                
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(b_is_record)
    {
        //填充选手信息
        for(int i=0; i<count; i++) {
            GetHeroBasicInfo(info_arr[i].hero_a.hero_id, info_arr[i].hero_a);
            GetHeroBasicInfo(info_arr[i].hero_b.hero_id, info_arr[i].hero_b);
        }

        //获取锁
        CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);

        //m_toparena.round_info_record[2] = true;
        m_toparena.stat[2] = stat;
        if(stat == TopArenaStat_GuessOpen)
            m_toparena.round = TopArenaRoundType_2_1;
        else if(stat == TopArenaStat_Finished)
            m_toparena.round = TopArenaRoundType_NUL;
        
        for(int i=0; i<count; i++) {
            memcpy(&m_toparena.player_arr_2_1[i], &info_arr[i], sizeof(TopArenaInfo));
            memcpy(&m_toparena.value_arr_2_1[i], &value_arr[i], sizeof(TopArenaHeroValue));
        }

        for(int i=0; i<count; i++) {
            for(int j=0; j<3; j++) {
                m_toparena.script_arr_2_1[i].len[j] = script_arr[i].len[j];
                m_toparena.script_arr_2_1[i].script[j] = new char[script_arr[i].len[j]];
                memcpy(m_toparena.script_arr_2_1[i].script[j], script_arr[i].script[j], script_arr[i].len[j]);
            }
        }
    }
    
}

void ProcServerThread::topArenaReadyPlayer()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaReadyPlayer", __FILE__, __LINE__);
#endif //_DEBUG
    
    HeroInfo hero_info_arr[8];

    //CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);
    if(m_toparena.stat[0] == TopArenaStat_GuessOpen)
    {
        //已经有选手信息，且准备好了
        return;
    }

    //准备8强选手的hero_id
    {   
        char sql[1024];
        sprintf(sql, "select hero_id from hellgate.top_hero_list where hero_order<=8 order by hero_order");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            int i=0;
            while(Mysql_Thread_Conn->FetchRow() != NULL && i<8) {   
                hero_info_arr[i++].hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
            }
            
            if(i < 8) {
                LogMsg("%s, line %d, not found top 8 player, only %u.", __FILE__, __LINE__, i);
                return ;
            }
        }      
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<8; i++) {//填充选手信息
        GetHeroBasicInfo(hero_info_arr[i].hero_id, hero_info_arr[i]);
    }

    for(int i=0; i<3; i++){
        m_toparena.stat[i] = TopArenaStat_Invalide;
    }

    //重新更新缓存信息
    {
        m_toparena.clearAllInfo();
        int count[4];
        drawbyLot(count, 4);

        m_toparena.stat[0] = TopArenaStat_GuessOpen;
        m_toparena.round = TopArenaRoundType_8_4;
        //m_toparena.round_info_record[0] = true; 
        
        for(int i=0; i<4; i++) {
            m_toparena.player_arr_8_4[i].hero_a = hero_info_arr[i];
            m_toparena.player_arr_8_4[i].hero_b = hero_info_arr[count[i] +4];
        }
    }
    
    //删除8-4竞猜数据表
    char sql[1024];
    {
        sprintf(sql, "delete from hellgate.top_arena_guess_8_4");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除4-2竞猜数据表
    {
        sprintf(sql, "delete from hellgate.top_arena_guess_4_2");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除2-1竞猜数据表
    {
        sprintf(sql, "delete from hellgate.top_arena_guess_2_1");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除8-4数据表
    {
        sprintf(sql, "delete from hellgate.top_arena_game_8_4");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除4-2数据表
    {
        sprintf(sql, "delete from hellgate.top_arena_game_4_2");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除2-1数据表
    {
        sprintf(sql, "delete from hellgate.top_arena_game_2_1");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //插入8-4数据表
    {
        sprintf(sql, "insert into hellgate.top_arena_game_8_4 set game_stat=%u "
            ", hero_team_1_a=%u, hero_team_1_b=%u, hero_team_2_a=%u, hero_team_2_b=%u "
            ", hero_team_3_a=%u, hero_team_3_b=%u, hero_team_4_a=%u, hero_team_4_b=%u "
            ", value_1_a=%u, value_1_b=%u, value_2_a=%u, value_2_b=%u "
            ", value_3_a=%u, value_3_b=%u, value_4_a=%u, value_4_b=%u "
            ", script_team_1_1='', script_team_1_2='', script_team_1_3=''"
            ", script_team_2_1='', script_team_2_2='', script_team_2_3=''"
            ", script_team_3_1='', script_team_3_2='', script_team_3_3=''"
            ", script_team_4_1='', script_team_4_2='', script_team_4_3=''"
            , TopArenaStat_GuessOpen
            , m_toparena.player_arr_8_4[0].hero_a.hero_id
            , m_toparena.player_arr_8_4[0].hero_b.hero_id
            , m_toparena.player_arr_8_4[1].hero_a.hero_id
            , m_toparena.player_arr_8_4[1].hero_b.hero_id
            , m_toparena.player_arr_8_4[2].hero_a.hero_id
            , m_toparena.player_arr_8_4[2].hero_b.hero_id
            , m_toparena.player_arr_8_4[3].hero_a.hero_id
            , m_toparena.player_arr_8_4[3].hero_b.hero_id
            , m_toparena.value_arr_8_4[0].value_a, m_toparena.value_arr_8_4[0].value_b
            , m_toparena.value_arr_8_4[1].value_a, m_toparena.value_arr_8_4[1].value_b
            , m_toparena.value_arr_8_4[2].value_a, m_toparena.value_arr_8_4[2].value_b
            , m_toparena.value_arr_8_4[3].value_a, m_toparena.value_arr_8_4[3].value_b);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


}

void ProcServerThread::topArenaFight_8_4()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaFight_8_4", __FILE__, __LINE__);
#endif //_DEBUG

    //战斗脚本
    FightScriptBuilder scriptBuild; //战斗脚本
    std::vector<FightScript> script_vec;
    TopArenaScriptInfo script_arr[4];
    
    //CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);

    if(m_toparena.stat[0] == TopArenaStat_Invalide) { //没有top8选手信息
        topArenaReadyPlayer();
    }

    if(m_toparena.stat[0] == TopArenaStat_GuessOpen) { //fight
        for(int i=0; i<4; i++){
            unsigned int b_win_arr[3] = {0, 0, 0};
            
            FirstBloodBoard fb1 = FBB_Random;
            FirstBloodBoard fb2 = FBB_Random;
            {//查询双方排名 轮流先手
                unsigned int order_a =0;
                unsigned int order_b =0;
                
                query_both_two_order(m_toparena.player_arr_8_4[i].hero_a.hero_id, 
                    m_toparena.player_arr_8_4[i].hero_b.hero_id, order_a, order_b);

                if(order_a < order_b) {
                    fb1 = FBB_BoardA;
                    fb2 = FBB_BoardB;
                }
                else if(order_a > order_b) {
                    fb1 = FBB_BoardB;
                    fb2 = FBB_BoardA;
                }
            }
            
            for(int j=0; j<3; j++){
                FightScript script_a, script_b;
                
                PvP(BattleType_TopArena, (j%2==0)?fb1:fb2
                    , m_toparena.player_arr_8_4[i].hero_a.hero_id, m_toparena.player_arr_8_4[i].hero_b.hero_id
                    , script_a, script_b);
                if(script_a.endResult.myResult == Result_Win)
                {
                    b_win_arr[j] = 1;
                }
                
                //a
                script_vec.clear();
                script_vec.push_back(script_a);
                script_arr[i].script[j]= scriptBuild.FightScriptVec_2_CharArr(script_vec, script_arr[i].len[j]);
                
            }

            if((b_win_arr[0] + b_win_arr[1] + b_win_arr[2]) >=2 ){
                m_toparena.player_arr_8_4[i].winer = true;
            }
            else {
                m_toparena.player_arr_8_4[i].winer = false;
            }
        }
        

        { //入缓存
            for(int i=0; i<4; i++) {
                for(int j=0; j<3; j++) {
                    m_toparena.script_arr_8_4[i].len[j] = script_arr[i].len[j];
                    m_toparena.script_arr_8_4[i].script[j] = new char[script_arr[i].len[j]];
                    memcpy(m_toparena.script_arr_8_4[i].script[j], script_arr[i].script[j], script_arr[i].len[j]);
                }
            }
        }
        
        //写入8进4数据库
        {
            int total_script_len = 0;
            std::string script_esc_arr[4*3];
            for(int i=0; i<4; ++i)
            {
                for(int j=0; j<3; j++)
                {
                    Mysql_Thread_Conn->Escape(script_esc_arr[i*3 +j], script_arr[i].script[j], script_arr[i].len[j]);

                    total_script_len += script_esc_arr[i*3 +j].length();
                }
            }
            
            char* sql = new char[1024 +total_script_len];
            CMemGuard guard(sql);
            sprintf(sql, "update hellgate.top_arena_game_8_4 set game_stat=%u "
                ", value_1_a=%u, value_1_b=%u, value_2_a=%u, value_2_b=%u "
                ", value_3_a=%u, value_3_b=%u, value_4_a=%u, value_4_b=%u "
                ", result_1=%u, result_2=%u, result_3=%u, result_4=%u "
                ", script_team_1_1='%s', script_team_1_2='%s', script_team_1_3='%s'"
                ", script_team_2_1='%s', script_team_2_2='%s', script_team_2_3='%s'"
                ", script_team_3_1='%s', script_team_3_2='%s', script_team_3_3='%s'"
                ", script_team_4_1='%s', script_team_4_2='%s', script_team_4_3='%s'"
                " where hero_team_1_a=%d"
                , TopArenaStat_Finished
                , m_toparena.value_arr_8_4[0].value_a, m_toparena.value_arr_8_4[0].value_b
                , m_toparena.value_arr_8_4[1].value_a, m_toparena.value_arr_8_4[1].value_b
                , m_toparena.value_arr_8_4[2].value_a, m_toparena.value_arr_8_4[2].value_b
                , m_toparena.value_arr_8_4[3].value_a, m_toparena.value_arr_8_4[3].value_b
                , m_toparena.player_arr_8_4[0].winer?0:1 
                , m_toparena.player_arr_8_4[1].winer?0:1 
                , m_toparena.player_arr_8_4[2].winer?0:1 
                , m_toparena.player_arr_8_4[3].winer?0:1 
                , script_esc_arr[0].c_str(), script_esc_arr[1].c_str(), script_esc_arr[2].c_str()
                , script_esc_arr[3].c_str(), script_esc_arr[4].c_str(), script_esc_arr[5].c_str()
                , script_esc_arr[6].c_str(), script_esc_arr[7].c_str(), script_esc_arr[8].c_str()
                , script_esc_arr[9].c_str(), script_esc_arr[10].c_str(), script_esc_arr[11].c_str()
                , m_toparena.player_arr_8_4[0].hero_a.hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    //入缓存
    {
        m_toparena.stat[0] = TopArenaStat_Finished;
        m_toparena.stat[1] = TopArenaStat_GuessOpen;
        m_toparena.round = TopArenaRoundType_4_2;
        
        //写入4进2选手信息
        {
            //8进4第一组胜利者
            if(m_toparena.player_arr_8_4[0].winer)
                m_toparena.player_arr_4_2[0].hero_a = m_toparena.player_arr_8_4[0].hero_a;
            else
                m_toparena.player_arr_4_2[0].hero_a = m_toparena.player_arr_8_4[0].hero_b;
                    
            //8进4第二组胜利者
            if(m_toparena.player_arr_8_4[1].winer)
                m_toparena.player_arr_4_2[0].hero_b = m_toparena.player_arr_8_4[1].hero_a;
            else
                m_toparena.player_arr_4_2[0].hero_b = m_toparena.player_arr_8_4[1].hero_b;
            
            //8进4第三组胜利者
            if(m_toparena.player_arr_8_4[2].winer)
                m_toparena.player_arr_4_2[1].hero_a = m_toparena.player_arr_8_4[2].hero_a;
            else
                m_toparena.player_arr_4_2[1].hero_a = m_toparena.player_arr_8_4[2].hero_b;
            
            //8进4第四组胜利者
            if(m_toparena.player_arr_8_4[3].winer)
                m_toparena.player_arr_4_2[1].hero_b = m_toparena.player_arr_8_4[3].hero_a;
            else
                m_toparena.player_arr_4_2[1].hero_b = m_toparena.player_arr_8_4[3].hero_b;
        }

        {
            m_toparena.value_arr_4_2[0].initValue();
            m_toparena.value_arr_4_2[1].initValue();
        }
    }
    
    { //巅峰对决4强选手插入到跑马灯消息队列中
        insert_marquee_message(MarqueeType_TopArena, m_toparena.player_arr_4_2[0].hero_a.hero_id, 0);
        insert_marquee_message(MarqueeType_TopArena, m_toparena.player_arr_4_2[0].hero_b.hero_id, 0);
        insert_marquee_message(MarqueeType_TopArena, m_toparena.player_arr_4_2[1].hero_a.hero_id, 0);
        insert_marquee_message(MarqueeType_TopArena, m_toparena.player_arr_4_2[1].hero_b.hero_id, 0);
    }

    
    //先删除4-2数据表
    {
        char sql[1024];
        sprintf(sql, "delete from hellgate.top_arena_game_4_2");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //再插入4-2数据库
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.top_arena_game_4_2 set game_stat=%u "
            ", hero_team_1_a=%u, hero_team_1_b=%u, hero_team_2_a=%u, hero_team_2_b=%u "
            ", value_1_a=%u, value_1_b=%u, value_2_a=%u, value_2_b=%u "
            ", script_team_1_1='', script_team_1_2='', script_team_1_3=''"
            ", script_team_2_1='', script_team_2_2='', script_team_2_3=''"
            , TopArenaStat_GuessOpen
            , m_toparena.player_arr_4_2[0].hero_a.hero_id
            , m_toparena.player_arr_4_2[0].hero_b.hero_id
            , m_toparena.player_arr_4_2[1].hero_a.hero_id
            , m_toparena.player_arr_4_2[1].hero_b.hero_id
            , m_toparena.value_arr_4_2[0].value_a, m_toparena.value_arr_4_2[0].value_b
            , m_toparena.value_arr_4_2[1].value_a, m_toparena.value_arr_4_2[1].value_b);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


}

void ProcServerThread::topArenaFight_4_2()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaFight_4_2", __FILE__, __LINE__);
#endif //_DEBUG

    //CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);

    if(m_toparena.stat[1] == TopArenaStat_Invalide) { //没有top4选手信息
        topArenaFight_8_4();
    }
    
    if(m_toparena.stat[1] == TopArenaStat_GuessOpen) {//fight
    
        //战斗脚本
        FightScriptBuilder scriptBuild; //战斗脚本
        std::vector<FightScript> script_vec;
        TopArenaScriptInfo script_arr[2];
    
        for(int i=0; i<2; i++){
            unsigned int b_win_arr[3] = {0, 0, 0};
            
            FirstBloodBoard fb1 = FBB_Random;
            FirstBloodBoard fb2 = FBB_Random;
            {//查询双方排名
                unsigned int order_a =0;
                unsigned int order_b =0;
                
                query_both_two_order(m_toparena.player_arr_4_2[i].hero_a.hero_id, 
                    m_toparena.player_arr_4_2[i].hero_b.hero_id, order_a, order_b);

                if(order_a < order_b) {
                    fb1 = FBB_BoardA;
                    fb2 = FBB_BoardB;
                }
                else if(order_a > order_b) {
                    fb1 = FBB_BoardB;
                    fb2 = FBB_BoardA;
                }
            }
            
            for(int j=0; j<3; j++){
                FightScript script_a, script_b;
                
                PvP(BattleType_TopArena, (j%2==0)?fb1:fb2
                    , m_toparena.player_arr_4_2[i].hero_a.hero_id, m_toparena.player_arr_4_2[i].hero_b.hero_id
                    , script_a, script_b);
                if(script_a.endResult.myResult == Result_Win)
                {
                    b_win_arr[j] = 1;
                }
                
                //a
                script_vec.clear();
                script_vec.push_back(script_a);
                script_arr[i].script[j]= scriptBuild.FightScriptVec_2_CharArr(script_vec, script_arr[i].len[j]);
            }

            if((b_win_arr[0] + b_win_arr[1] + b_win_arr[2]) >=2 ){
                m_toparena.player_arr_4_2[i].winer = true;
            }
            else {
                m_toparena.player_arr_4_2[i].winer = false;
            }
        }

        
        
        { //入缓存
            for(int i=0; i<2; i++) {
                for(int j=0; j<3; j++) {
                    m_toparena.script_arr_4_2[i].len[j] = script_arr[i].len[j];
                    m_toparena.script_arr_4_2[i].script[j] = new char[script_arr[i].len[j]];
                    memcpy(m_toparena.script_arr_4_2[i].script[j], script_arr[i].script[j], script_arr[i].len[j]);
                }
            }
        }
        
        { //写入4进2数据库
            int total_script_len = 0;
            std::string script_esc_arr[2*3];
            for(int i=0; i<2; ++i)
            {
                for(int j=0; j<3; j++)
                {
                    Mysql_Thread_Conn->Escape(script_esc_arr[i*3 +j],script_arr[i].script[j], script_arr[i].len[j]);

                    total_script_len += script_esc_arr[i*3 +j].length();

                }
            }
            
            char* sql = new char[1024 +total_script_len];
            CMemGuard guard(sql);
            sprintf(sql, "update hellgate.top_arena_game_4_2 set game_stat=%u "
                ", value_1_a=%u, value_1_b=%u, value_2_a=%u, value_2_b=%u "
                ", result_1=%u, result_2=%u "
                ", script_team_1_1='%s', script_team_1_2='%s', script_team_1_3='%s'"
                ", script_team_2_1='%s', script_team_2_2='%s', script_team_2_3='%s'"
                " where hero_team_1_a=%d"
                , TopArenaStat_Finished
                , m_toparena.value_arr_4_2[0].value_a, m_toparena.value_arr_4_2[0].value_b
                , m_toparena.value_arr_4_2[1].value_a, m_toparena.value_arr_4_2[1].value_b
                , m_toparena.player_arr_4_2[0].winer?0:1 
                , m_toparena.player_arr_4_2[1].winer?0:1 
                , script_esc_arr[0].c_str(), script_esc_arr[1].c_str(), script_esc_arr[2].c_str()
                , script_esc_arr[3].c_str(), script_esc_arr[4].c_str(), script_esc_arr[5].c_str()
                , m_toparena.player_arr_4_2[0].hero_a.hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

    }

    

    //入缓存
    {
        m_toparena.stat[1] = TopArenaStat_Finished;
        m_toparena.stat[2] = TopArenaStat_GuessOpen;
        m_toparena.round = TopArenaRoundType_2_1;
        
        //写入2进1选手信息
        {
            //4进2第一组胜利者
            if(m_toparena.player_arr_4_2[0].winer)
                m_toparena.player_arr_2_1[0].hero_a = m_toparena.player_arr_4_2[0].hero_a;
            else
                m_toparena.player_arr_2_1[0].hero_a = m_toparena.player_arr_4_2[0].hero_b;
            
            //4进2第二组胜利者
            if(m_toparena.player_arr_4_2[1].winer)
                m_toparena.player_arr_2_1[0].hero_b = m_toparena.player_arr_4_2[1].hero_a;
            else
                m_toparena.player_arr_2_1[0].hero_b = m_toparena.player_arr_4_2[1].hero_b;
        }
        
        {
            m_toparena.value_arr_2_1[0].initValue();
        }
    }
    
    { //巅峰对决2强选手插入到跑马灯消息队列中
        insert_marquee_message(MarqueeType_TopArena, m_toparena.player_arr_2_1[0].hero_a.hero_id, 1);
        insert_marquee_message(MarqueeType_TopArena, m_toparena.player_arr_2_1[0].hero_b.hero_id, 1);
    }
    
    //先删除2-1数据表
    {
        char sql[1024];
        sprintf(sql, "delete from hellgate.top_arena_game_2_1");
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //再插入2-1数据库
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.top_arena_game_2_1 set game_stat=%u "
            ", hero_team_1_a=%u, hero_team_1_b=%u "
            ", value_1_a=%u, value_1_b=%u "
            ", script_team_1_1='', script_team_1_2='', script_team_1_3=''"
            , TopArenaStat_GuessOpen
            , m_toparena.player_arr_2_1[0].hero_a.hero_id
            , m_toparena.player_arr_2_1[0].hero_b.hero_id
            , m_toparena.value_arr_2_1[0].value_a, m_toparena.value_arr_2_1[0].value_b);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

}

void ProcServerThread::topArenaFight_2_1()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaFight_2_1", __FILE__, __LINE__);
#endif //_DEBUG

    
    //CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);

    if(m_toparena.stat[2] == TopArenaStat_Invalide)
    {//没有top2选手信息
        topArenaFight_4_2();
    }

    if(m_toparena.stat[2] == TopArenaStat_GuessOpen) { //fight
    
        //战斗脚本
        FightScriptBuilder scriptBuild; //战斗脚本
        std::vector<FightScript> script_vec;
        TopArenaScriptInfo script_arr[1];
        
        for(int i=0; i<1; i++){
            unsigned int b_win_arr[3] = {0, 0, 0};
            
            FirstBloodBoard fb1 = FBB_Random;
            FirstBloodBoard fb2 = FBB_Random;
            {//查询双方排名
                unsigned int order_a =0;
                unsigned int order_b =0;
                
                query_both_two_order(m_toparena.player_arr_2_1[i].hero_a.hero_id, 
                    m_toparena.player_arr_2_1[i].hero_b.hero_id, order_a, order_b);

                if(order_a < order_b) {
                    fb1 = FBB_BoardA;
                    fb2 = FBB_BoardB;
                }
                else if(order_a > order_b) {
                    fb1 = FBB_BoardB;
                    fb2 = FBB_BoardA;
                }
            }
            
            for(int j=0; j<3; j++){
                FightScript script_a, script_b;
                
                PvP(BattleType_TopArena, (j%2==0)?fb1:fb2
                    , m_toparena.player_arr_2_1[i].hero_a.hero_id, m_toparena.player_arr_2_1[i].hero_b.hero_id
                    , script_a, script_b);
                if(script_a.endResult.myResult == Result_Win)
                {
                    b_win_arr[j] = 1;
                }
                
                //a
                script_vec.clear();
                script_vec.push_back(script_a);
                script_arr[i].script[j] = scriptBuild.FightScriptVec_2_CharArr(script_vec, script_arr[i].len[j]);
            }

            if((b_win_arr[0] + b_win_arr[1] + b_win_arr[2]) >=2 ){
                m_toparena.player_arr_2_1[i].winer = true;
            }
            else {
                m_toparena.player_arr_2_1[i].winer = false;
            }
        }

        { //入缓存
            m_toparena.stat[2] = TopArenaStat_Finished;
            m_toparena.round = TopArenaRoundType_NUL;
            
            for(int i=0; i<1; i++) {
                for(int j=0; j<3; j++) {
                    m_toparena.script_arr_2_1[i].len[j] = script_arr[i].len[j];
                    m_toparena.script_arr_2_1[i].script[j] = new char[script_arr[i].len[j]];
                    memcpy(m_toparena.script_arr_2_1[i].script[j], script_arr[i].script[j], script_arr[i].len[j]);
                }
            }
        }
        
        
        { //巅峰对决冠军插入到跑马灯消息队列中
            insert_marquee_message(MarqueeType_TopArena, 
                m_toparena.player_arr_2_1[0].winer ? m_toparena.player_arr_2_1[0].hero_a.hero_id : m_toparena.player_arr_2_1[0].hero_b.hero_id, 
                2);
        }

        { //写入2进1数据库
            int total_script_len = 0;
            std::string script_esc_arr[3];
            for(int j=0; j<3; j++)
            {
                Mysql_Thread_Conn->Escape(script_esc_arr[j],script_arr[0].script[j], script_arr[0].len[j]);
                
                total_script_len += script_esc_arr[j].length();
            }
            
            char* sql = new char[1024 +total_script_len];
            CMemGuard guard(sql);
            sprintf(sql, "update hellgate.top_arena_game_2_1 set game_stat=%u "
                ", value_1_a=%u, value_1_b=%u "
                ", result_1=%u "
                ", script_team_1_1='%s', script_team_1_2='%s', script_team_1_3='%s'"
                " where hero_team_1_a=%d"
                , TopArenaStat_Finished
                , m_toparena.value_arr_2_1[0].value_a, m_toparena.value_arr_2_1[0].value_b
                , m_toparena.player_arr_2_1[0].winer?0:1 
                , script_esc_arr[0].c_str(), script_esc_arr[1].c_str(), script_esc_arr[2].c_str()
                , m_toparena.player_arr_2_1[0].hero_a.hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

    }

}

#if 0
struct _HeroGuess
{
    unsigned int hero_id;
    bool game_1_guess;
    bool game_2_guess;
    bool game_3_guess;
    bool game_4_guess;
    bool game_5_guess;
};
#endif

struct _HeroGuess_Status
{
    unsigned int hero_id;
    SPCmd_TopArenaGuess info;
};
struct _HeroGuess_Gold
{
    unsigned int hero_id;
    unsigned int gold_count;
};

#define GUESS_RIGHT_GAIN 2

void ProcServerThread::topArenaAwardGuess(TopArenaRoundType type)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaAwardGuess", __FILE__, __LINE__);
#endif //_DEBUG
    
    char sql[1024];
    std::vector<_HeroGuess_Status> guess_stat_vec;
    
    if(type == TopArenaRoundType_8_4) {
        sprintf(sql, "select * from hellgate.top_arena_guess_8_4 ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                _HeroGuess_Status tmp_sta;
                tmp_sta.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                tmp_sta.info.group = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                tmp_sta.info.guess_winer = !((bool)atoi(Mysql_Thread_Conn->GetField("guess_result")));
                tmp_sta.info.wager = atoi(Mysql_Thread_Conn->GetField("wager"));
                guess_stat_vec.insert(guess_stat_vec.end(), tmp_sta);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
  
        CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);
        //把竞猜正确的奖金插入到竞猜结果表中去
        for(int i=0; i<guess_stat_vec.size(); i++){
            if(m_toparena.player_arr_8_4[guess_stat_vec[i].info.group -1].winer
                != guess_stat_vec[i].info.guess_winer)
                continue;
            
            unsigned int gold_count = guess_stat_vec[i].info.wager *GUESS_RIGHT_GAIN;
            
            sprintf(sql, "insert into hellgate.top_arena_guess_gift set "
                " hero_id=%u, gold_count=%u"
                , guess_stat_vec[i].hero_id, gold_count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    } 
    else if (type == TopArenaRoundType_4_2) {
        sprintf(sql, "select * from hellgate.top_arena_guess_4_2 ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                _HeroGuess_Status tmp_sta;
                tmp_sta.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                tmp_sta.info.group = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                tmp_sta.info.guess_winer = !((bool)atoi(Mysql_Thread_Conn->GetField("guess_result")));
                tmp_sta.info.wager = atoi(Mysql_Thread_Conn->GetField("wager"));
                guess_stat_vec.insert(guess_stat_vec.end(), tmp_sta);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
        CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);
        //把竞猜正确的奖金插入到竞猜结果表中去
        for(int i=0; i<guess_stat_vec.size(); i++){
            if(m_toparena.player_arr_4_2[guess_stat_vec[i].info.group -1].winer
                != guess_stat_vec[i].info.guess_winer)
                continue;
            
            unsigned int gold_count = guess_stat_vec[i].info.wager *GUESS_RIGHT_GAIN;
            
            sprintf(sql, "insert into hellgate.top_arena_guess_gift set "
                " hero_id=%u, gold_count=%u"
                , guess_stat_vec[i].hero_id, gold_count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    } 
    else if (type == TopArenaRoundType_2_1) { 
        sprintf(sql, "select * from hellgate.top_arena_guess_2_1 ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                _HeroGuess_Status tmp_sta;
                tmp_sta.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                tmp_sta.info.group = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                tmp_sta.info.guess_winer = !((bool)atoi(Mysql_Thread_Conn->GetField("guess_result")));
                tmp_sta.info.wager = atoi(Mysql_Thread_Conn->GetField("wager"));
                guess_stat_vec.insert(guess_stat_vec.end(), tmp_sta);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
        CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);
        //把竞猜正确的奖金插入到竞猜结果表中去
        for(int i=0; i<guess_stat_vec.size(); i++){
            if(m_toparena.player_arr_2_1[0].winer != guess_stat_vec[i].info.guess_winer)
                continue;
            
            unsigned int gold_count = guess_stat_vec[i].info.wager *GUESS_RIGHT_GAIN;
            
            sprintf(sql, "insert into hellgate.top_arena_guess_gift set "
                " hero_id=%u, gold_count=%u"
                , guess_stat_vec[i].hero_id, gold_count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    } 
}


void ProcServerThread::topArenaAwardtoSystem(unsigned int hero_id)
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaAwardtoSystem", __FILE__, __LINE__);
#endif //_DEBUG

    TopArenaInfo player_arr_8_4[4];     //8进4选手
    TopArenaInfo player_arr_4_2[2];     //4进2选手
    TopArenaInfo player_arr_2_1[1];     //2进1选手
    TopArenaStat stat[3];
    
    pthread_mutex_lock(&m_toparena.mutex);
    {
        for(int i=0; i<3; i++) {
            stat[i] = m_toparena.stat[i];
        }

        for(int i=0; i<4; i++) {
            player_arr_8_4[i] = m_toparena.player_arr_8_4[i];
        }

        for(int i=0; i<2; i++) {
            player_arr_4_2[i] = m_toparena.player_arr_4_2[i];
        }

        for(int i=0; i<1; ++i)
        {
            player_arr_2_1[i] = m_toparena.player_arr_2_1[i];
        }
    }
    pthread_mutex_unlock(&m_toparena.mutex);

    bool is_award[3] = {true, true, true};
    unsigned int system_bonus_id[3] = {0, 0, 0};

    //查询玩家竞猜情况
    if(stat[0] == TopArenaStat_Finished){//查询8-4玩家竞猜情况
        char sql[1024];
        sprintf(sql, "select guess_game, guess_result, wager, is_award "
            " from hellgate.top_arena_guess_8_4 "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                int guess_game = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                bool a_win = !(bool)atoi(Mysql_Thread_Conn->GetField("guess_result"));
                int wager = atoi(Mysql_Thread_Conn->GetField("wager"));

                is_award[0] = bool(atoi(Mysql_Thread_Conn->GetField("is_award")));
                
                if(!is_award[0]) {
                    int type = 0;
                    if(wager == CS::getTopArenaWager(TopArenaWagerType_High)) {
                        type = TopArenaWagerType_High;
                    }
                    
                    if(player_arr_8_4[guess_game-1].winer == a_win) {
                        system_bonus_id[0] = 
                            (type==TopArenaWagerType_High) ? EmailID_GuessRight_High_8_4 : EmailID_GuessRight_Low_8_4;
                    }
                    else {
                        system_bonus_id[0] = 
                            (type==TopArenaWagerType_High) ? EmailID_GuessWrong_High_8_4 : EmailID_GuessWrong_Low_8_4;
                    }
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(stat[1] == TopArenaStat_Finished){//查询4-2玩家竞猜情况
        char sql[1024];
        sprintf(sql, "select guess_game, guess_result, wager, is_award "
            " from hellgate.top_arena_guess_4_2 "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            TopArenaGuessInfo info;
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                int guess_game = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                bool a_win = !(bool)atoi(Mysql_Thread_Conn->GetField("guess_result"));
                int wager = atoi(Mysql_Thread_Conn->GetField("wager"));

                is_award[1] = bool(atoi(Mysql_Thread_Conn->GetField("is_award")));
                
                if(!is_award[1]) {
                    int type = 1;
                    if(wager == CS::getTopArenaWager(TopArenaWagerType_High)) {
                        type = TopArenaWagerType_High;
                    }
                    
                    if(player_arr_4_2[guess_game-1].winer == a_win) {
                        system_bonus_id[1] = 
                            (type==TopArenaWagerType_High) ? EmailID_GuessRight_High_4_2 : EmailID_GuessRight_Low_4_2;
                    }
                    else {
                        system_bonus_id[1] = 
                            (type==TopArenaWagerType_High) ? EmailID_GuessWrong_High_4_2 : EmailID_GuessWrong_Low_4_2;
                    }
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(stat[2] == TopArenaStat_Finished){//查询2-1玩家竞猜情况
        char sql[1024];
        sprintf(sql, "select guess_game, guess_result, wager, is_award "
            " from hellgate.top_arena_guess_2_1 "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            TopArenaGuessInfo info;
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                int guess_game = atoi(Mysql_Thread_Conn->GetField("guess_game"));
                bool a_win = !(bool)atoi(Mysql_Thread_Conn->GetField("guess_result"));
                int wager = atoi(Mysql_Thread_Conn->GetField("wager"));

                is_award[2] = bool(atoi(Mysql_Thread_Conn->GetField("is_award")));
                
                if(!is_award[2]) {
                    int type = 1;
                    if(wager == CS::getTopArenaWager(TopArenaWagerType_High)) {
                        type = TopArenaWagerType_High;
                    }
                    
                    if(player_arr_2_1[guess_game-1].winer == a_win) {
                        system_bonus_id[2] = 
                            (type==TopArenaWagerType_High) ? EmailID_GuessRight_High_2_1 : EmailID_GuessRight_Low_2_1;
                    }
                    else {
                        system_bonus_id[2] = 
                            (type==TopArenaWagerType_High) ? EmailID_GuessWrong_High_2_1 : EmailID_GuessWrong_Low_2_1;
                    }
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    
    const char *table_str[3] = {"top_arena_guess_8_4", "top_arena_guess_4_2", "top_arena_guess_2_1"};

    for(int i=0; i<3; i++) {
        if(!is_award[i]){ 
            //先插入竞猜id的邮件状态
            insert_into_email(hero_id, 0, EmailType_Bonus, system_bonus_id[i]);
            
            //再更新竞猜表的is_award字段
            char sql[1024];
            sprintf(sql, "update hellgate.%s set "
                " is_award=1 where hero_id=%u"
                , table_str[i], hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
}

void ProcServerThread::topArenaAwardTop8()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::topArenaAwardTop8", __FILE__, __LINE__);
#endif //_DEBUG
    unsigned int hero_id;
    std::vector<_HeroGuess_Gold> guess_gold_vec;
    
    //CPthreadMutexAutoLockAutoUnlock auto_lock(&m_toparena.mutex);
    {
        //冠军
        if(m_toparena.player_arr_2_1[0].winer) //取胜者
            hero_id = m_toparena.player_arr_2_1[0].hero_a.hero_id;
        else
            hero_id = m_toparena.player_arr_2_1[0].hero_b.hero_id;
            
        //先插入巅峰对决结果的邮件状态
        insert_into_email(hero_id, 0, EmailType_Bonus, EmailID_TopArena_Top1);
        
        //亚军
        if(m_toparena.player_arr_2_1[0].winer) //取败者
            hero_id = m_toparena.player_arr_2_1[0].hero_b.hero_id;
        else
            hero_id = m_toparena.player_arr_2_1[0].hero_a.hero_id;
            
        //先插入巅峰对决结果的邮件状态
        insert_into_email(hero_id, 0, EmailType_Bonus, EmailID_TopArena_Top2);
        
        //TOP4
        for(int i=0; i<2; i++) {
            if(m_toparena.player_arr_4_2[i].winer) //取败者
                hero_id = m_toparena.player_arr_4_2[i].hero_b.hero_id;
            else
                hero_id = m_toparena.player_arr_2_1[i].hero_a.hero_id;
            
            //先插入巅峰对决结果的邮件状态
            insert_into_email(hero_id, 0, EmailType_Bonus, EmailID_TopArena_Top4);
        } 
        
        //TOP8
        for(int i=0; i<4; i++) {
            if(m_toparena.player_arr_8_4[i].winer) //取败者
                hero_id = m_toparena.player_arr_8_4[i].hero_b.hero_id;
            else
                hero_id = m_toparena.player_arr_8_4[i].hero_a.hero_id;
            
            //先插入巅峰对决结果的邮件状态
            insert_into_email(hero_id, 0, EmailType_Bonus, EmailID_TopArena_Top8);
        }
    }
}

void ProcServerThread::PvP(BattleType battle_type, FirstBloodBoard fb, 
    unsigned int hero_a, unsigned int hero_b, FightScript& script_a, FightScript& script_b,
    unsigned int battle_kind)
{
    //查询我方上阵阵型
    unsigned int team_pos_vec[4] = {0, 0, 0, 0};
    {
        std::vector<int> arr;
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , hero_a, hero_a);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, hero_a, pos);
                }
                else
                {
                    team_pos_vec[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询对方阵型
    unsigned int comp_pos_vec[4] = {0, 0, 0, 0};
    {
        std::vector<int> arr;
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , hero_b, hero_b);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, hero_b, pos);
                }
                else
                {
                    comp_pos_vec[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
        //查询双方排名
        /*unsigned int order_a =0;
        unsigned int order_b =0;
        query_both_two_order(hero_a, hero_b, order_a, order_b);

        FirstBloodBoard fb = FBB_Random;
        if(order_a < order_b)
            fb = FBB_BoardA;
        else if(order_a > order_b)
            fb = FBB_BoardB;*/

        //查询双方等级
        unsigned int hero_a_level = 0;
        {
            HeroInfo info;
            GetHeroBasicInfo(hero_a,info);
            hero_a_level = info.level;
        }
        unsigned int hero_b_level = 0;
        {
            HeroInfo info;
            GetHeroBasicInfo(hero_b,info);
            hero_b_level = info.level;
        }
        
    
    //生成战斗脚本
    {
        ScriptBuilderUserData userData;
        FightSUD f_sud;
        userData.data = &f_sud;
        
        f_sud.battle_type = battle_type;
        f_sud.battle_kind = battle_kind;
        f_sud.heroId = 0;
        f_sud.taskId = 0;
        f_sud.gridId = 0;
        f_sud.hero_a_level = hero_a_level;
        f_sud.hero_b_level = hero_b_level;
        FightScriptBuilder scriptBuild;
        f_sud.fightIndex = 1;
    
        scriptBuild.genScript(team_pos_vec, comp_pos_vec
            , script_a, script_b
            , this
            , userData
            ,fb
            , BATTLE_ROUND_LIMIT);
    }
}



void ProcServerThread::getSomeotherHeroInTopList(unsigned int hero_order, std::vector < HeroAndOrder > & hero_vec)
{
    hero_vec.clear();
    
    //获取后3个英雄
    {
        unsigned int min_order = hero_order+1;
        unsigned int max_order = hero_order+3;

        if(hero_order <= 30)
        {
            min_order = 31;
            max_order = 33;
        }

        char sql[1024];
        sprintf(sql, "select hero_id, hero_order from hellgate.top_hero_list "
            " where hero_order>=%u and hero_order<=%u order by hero_order"
            , min_order, max_order);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                HeroAndOrder hero_and_order;
                hero_and_order.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                hero_and_order.order = atoi(Mysql_Thread_Conn->GetField("hero_order"));

                hero_vec.push_back(hero_and_order);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //获取排位高些的10个英雄
    {
        std::vector<unsigned int> order_vec;
        if(hero_order <= 40)
        {
            for(int i=31; i< hero_order; ++i)
            {
                order_vec.push_back(i);
            }
        }
        else
        {
            //stub 目前就取前面10个
            for(int i=hero_order-1; i>=hero_order-10; --i)
            {
                order_vec.push_back(i);
            }
        }
        
        for(int i=0; i<order_vec.size(); ++i)
        {
            char sql[1024];
            sprintf(sql, "select hero_id, hero_order from hellgate.top_hero_list "
                " where hero_order=%u order by hero_order"
                , order_vec[i]);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    HeroAndOrder hero_and_order;
                    hero_and_order.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                    hero_and_order.order = atoi(Mysql_Thread_Conn->GetField("hero_order"));

                    hero_vec.push_back(hero_and_order);
                }
                else
                {
                    LogMsg("%s, line %d, hero_order not exist in tophero. [%u]"
                            , __FILE__, __LINE__, order_vec[i]);
                    return;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
       
    }

    for(int i=0; i<hero_vec.size(); ++i)
    {
        GetHeroBasicInfo(hero_vec[i].hero_info.hero_id,hero_vec[i].hero_info);
    }

    return;
}

int ProcServerThread::heroEnterCityGuard(unsigned int hero_id
    ,unsigned int& last_total_turns,unsigned int& last_total_silver
    ,unsigned int& sucess_turn,unsigned int& current_silver)
{
    //首先检查表中是否有相应英雄信息，没有则创建 
    last_total_turns = 0;
    last_total_silver = 0;
    sucess_turn = 0;
    current_silver = 0;
    unsigned int next_monster_team_id = 0;
    unsigned int next_turn_silver = 0;
    {
        bool hero_exist = true;
        
        char sql[1024];
        sprintf(sql, "select last_total_turns, last_total_silver, sucess_turn, current_silver "
            " , next_monster_team_id, next_turn_silver"
            " from hellgate.cityguard_hero_info where hero_id=%u and expired_time>%u"
            , hero_id, (unsigned int)time(0));
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                last_total_turns = atoi(Mysql_Thread_Conn->GetField("last_total_turns"));
                last_total_silver = atoi(Mysql_Thread_Conn->GetField("last_total_silver"));
                sucess_turn = atoi(Mysql_Thread_Conn->GetField("sucess_turn"));
                current_silver = atoi(Mysql_Thread_Conn->GetField("current_silver"));
                next_monster_team_id = atoi(Mysql_Thread_Conn->GetField("next_monster_team_id"));
                next_turn_silver = atoi(Mysql_Thread_Conn->GetField("next_turn_silver"));
            }
            else
            {
                hero_exist = false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        if(!hero_exist)
        {
            char sql[1024];
            sprintf(sql, "insert into hellgate.cityguard_hero_info "
                " set hero_id=%u, expired_time=%u"
                , hero_id, (unsigned int)Utl::time_today_end());
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    //如果下一轮怪物还没定，则选定怪物
    //防止玩家反复进入刷对自己有利的怪物
    if(next_monster_team_id == 0)
    {
        //
        sucess_turn = 0;
        current_silver = 0;

        
        //查找等级最低的队伍
        {
            char sql[1024];
            sprintf(sql, "select monster_team_id"
                " from hellgate.cityguard_monster_team"
                " order by team_level limit 1"
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    next_monster_team_id = atoi(Mysql_Thread_Conn->GetField("monster_team_id")); 
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        
    }

    //
    next_turn_silver = 100*(sucess_turn+5);

    {
        char sql[1024];
        sprintf(sql, "update hellgate.cityguard_hero_info set "
            " sucess_turn=%u, current_silver=%u, next_monster_team_id=%u, next_turn_silver=%u"
            " where hero_id=%u"
            , sucess_turn, current_silver, next_monster_team_id, next_turn_silver, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return 0;
}

void ProcServerThread::setNextTurnCityGuardMonsterTeamAndSilver(
    unsigned int hero_id)
{
    unsigned int current_silver = 0;
    unsigned int sucess_turn = 0;
    unsigned int monster_team_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select sucess_turn, current_silver, next_turn_silver, next_monster_team_id"
            " from hellgate.cityguard_hero_info"
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                sucess_turn = atoi(Mysql_Thread_Conn->GetField("sucess_turn"));
                current_silver = atoi(Mysql_Thread_Conn->GetField("current_silver"));
                current_silver += atoi(Mysql_Thread_Conn->GetField("next_turn_silver")); 
                monster_team_id = atoi(Mysql_Thread_Conn->GetField("next_monster_team_id")); 
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    sucess_turn++;

    //获取更高级的守城的怪物
    {
        char sql[1024];
        sprintf(sql, "select monster_team_id"
            " from hellgate.cityguard_monster_team"
            " where team_level>(select team_level from hellgate.cityguard_monster_team where monster_team_id=%u)"
            " order by team_level limit 1"
            , monster_team_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                monster_team_id = atoi(Mysql_Thread_Conn->GetField("monster_team_id")); 
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //
    unsigned int silver = 100*(sucess_turn+5);

    {
        char sql[1024];
        sprintf(sql, "update hellgate.cityguard_hero_info set "
            " sucess_turn=%u, current_silver=%u, next_monster_team_id=%u, next_turn_silver=%u"
            " where hero_id=%u"
            , sucess_turn, current_silver, monster_team_id, silver, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return;
}

void ProcServerThread::clearCityGuardMonsterTeamAndSilver(unsigned int hero_id, bool isGiveUp)
{
    unsigned int sucess_turn = 0;
    unsigned int current_silver = 0;
    unsigned int next_turn_silver = 0;
    {
        char sql[1024];
        sprintf(sql, "select sucess_turn, current_silver, next_turn_silver from hellgate.cityguard_hero_info"
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                sucess_turn = atoi(Mysql_Thread_Conn->GetField("sucess_turn"));
                current_silver = atoi(Mysql_Thread_Conn->GetField("current_silver"));
                next_turn_silver = atoi(Mysql_Thread_Conn->GetField("next_turn_silver")); 
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    int last_total_silver = current_silver;
    if(!isGiveUp)
    {
        //战败倒扣
        last_total_silver -= next_turn_silver;
        if(last_total_silver < 0)
        {
            last_total_silver = 0;
        }
    }

    {
        char sql[1024];
        sprintf(sql, "update hellgate.cityguard_hero_info set "
            " last_total_turns=%u, last_total_silver=%u, "
            " sucess_turn=0, current_silver=0, next_monster_team_id=0, next_turn_silver=0"
            " where hero_id=%u"
            , sucess_turn, last_total_silver, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

void ProcServerThread::getCityGuardCurrentSilverAndNextSilver(unsigned int hero_id
    ,unsigned int& current_silver,unsigned int& nextSilver)
{
    char sql[1024];
    sprintf(sql, "select current_silver, next_turn_silver from hellgate.cityguard_hero_info"
        " where hero_id=%u"
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            current_silver = atoi(Mysql_Thread_Conn->GetField("current_silver"));
            nextSilver = atoi(Mysql_Thread_Conn->GetField("next_turn_silver")); 
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
}

void ProcServerThread::arenaTimer()
{
    //获取锁
    CPthreadMutexAutoLockAutoUnlock auto_lock(&m_arena.mutex);
    
    //进入竞技场数据结构
    {
        time_t current_time = time(0);
        
        for(int i=0; i<HERO_MAX_LEVEL+ARENA_HARD_LEVEL_COUNT-1; ++i)
        {
            ArenaRoom* room = &(m_arena.room_arr[i]);

            if(room->hero_vec.size() > 0 && current_time - room->create_time >= ArenaCreateTeamTimeOut)
            {
                std::vector<ArenaHero> total_hero_vec = room->hero_vec;
                
                //超时，找人填充
                for(int index_stub=0; index_stub<4-room->hero_vec.size(); ++index_stub)
                {
                    //
                    std::vector<unsigned int> hero_except;
                    for(int m=0; m<total_hero_vec.size(); ++m)
                    {
                        hero_except.push_back(total_hero_vec[m].hero_id);
                    }
                    std::vector<unsigned int> robot_vec;

                    //stub
                    getRobot(1, 30, hero_except,1,robot_vec);
                    
                    //
                    ArenaHero stub_hero;
                    stub_hero.type = ArenaHeroType_StubPlayer;
                    stub_hero.hero_id = robot_vec[0];
                    
                    total_hero_vec.push_back(stub_hero);

                    //给所有真实在线玩家发送update
                    for(int index_hero=0; index_hero<room->hero_vec.size(); ++index_hero)
                    {
                        if(room->hero_vec[index_hero].type == ArenaHeroType_OnlinePlayer)
                        {
                            sendArenaUpdateRoomRsp(room->hero_vec[index_hero].hero_id
                                , stub_hero.hero_id);
                        }
                    }
                }

                //清空room
                room->create_time = 0;
                room->hero_vec.clear();

                //生成并发送战斗脚本以及宝箱
                sendArenaBattleAndGiftRsp(total_hero_vec);

                /* 2014.04.17 去掉每日任务
                //支线任务竞技场完成
                for(int i=0; i<total_hero_vec.size(); ++i)
                {
                    if(total_hero_vec[i].type == ArenaHeroType_OnlinePlayer)
                    {
                        subtaskPointFinished(total_hero_vec[i].hero_id, SubtaskId_Richang_jingjichang_duanzaocailiao);
                    }
                }
                */

                
            }
        }
    }
}

void ProcServerThread::sendArenaUpdateRoomRsp(unsigned int to_hero_id
        , unsigned int new_enter_hero_id)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::sendArenaUpdateRoomRsp to_hero_id[%u], new_hero_id[%u]"
, __FILE__, __LINE__, to_hero_id, new_enter_hero_id);
#endif //_DEBUG


    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_id"
            " from hellgate.zhuangbei_list"
            " where zhuangbei_hero_id=%u"
            , new_enter_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    int rspDataLen = sizeof(SPCmd_ArenaUpdateRoomRsp) + zhuangbei_detail_data_len;
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = arenaUpdateRoomRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ArenaUpdateRoomRsp* rspBody = (SPCmd_ArenaUpdateRoomRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    HeroInfo heroinfo;
    GetHeroBasicInfo(new_enter_hero_id,heroinfo);
    hton_hero_info(heroinfo, rspBody->new_hero_info);
    

    //
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = to_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::sendArenaEnterRsp(
    unsigned int to_client_id, unsigned int to_hero_id
    , std::string fd_account,std::vector < ArenaHero > partner)
{
    assert(partner.size() < 4);
    
    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    if(partner.size() > 0)
    {
        {
            char zhuangbei_hero_str[128];
            sprintf(zhuangbei_hero_str, " zhuangbei_hero_id=%u ", partner[0].hero_id);
            for(int i=1; i<partner.size(); ++i)
            {
                char str[64];
                sprintf(str, " or zhuangbei_hero_id=%u ", partner[i].hero_id);

                strcat(zhuangbei_hero_str, str);
            }
            
            char sql[2048];
            sprintf(sql, "select zhuangbei_id"
                " from hellgate.zhuangbei_list"
                " where %s"
                , zhuangbei_hero_str);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    __ZhuangbeiDetail detail;
                    
                    detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                    zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        for(int i=0; i<zhuangbei_vec.size(); ++i)
        {
            unsigned int owner_id;
            getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
        }
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    int rspDataLen = sizeof(SPCmd_ArenaEnterRsp) + zhuangbei_detail_data_len;
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = arenaEnterRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_ArenaEnterRsp* rspBody = (SPCmd_ArenaEnterRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->hero_info_arr[0].hero_id = 0;
    rspBody->hero_info_arr[1].hero_id = 0;
    rspBody->hero_info_arr[2].hero_id = 0;
    for(int i=0; i<partner.size(); ++i)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(partner[i].hero_id,hero_info);

        hton_hero_info(hero_info,rspBody->hero_info_arr[i]);
    }

    //
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = fd_account;
    rsppack->client_id = to_client_id;
    rsppack->main_hero_id = to_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}

void ProcServerThread::sendArenaBattleAndGiftRsp(std::vector < ArenaHero > hero_vec)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::sendArenaBattleAndGiftRsp "
, __FILE__, __LINE__);
#endif //_DEBUG

    //最终战斗脚本，index与hero_vec一致
    std::vector<FightScript> hero_script_arr[4];
    
    //先分组，给0随机找一个对手即可
    int comp_index_for_index_0 = Utl::auto_random()%3 + 1;

    unsigned int team_1_a = 0;
    unsigned int team_1_b = comp_index_for_index_0;
    unsigned int team_2_a = comp_index_for_index_0 == 1 ? 2 : 1;
    unsigned int team_2_b = comp_index_for_index_0 == 3 ? 2 : 3;
    unsigned int team_final_a;
    unsigned int team_final_b;

    //先查询出4个参赛阵容
    unsigned int team_pos_vec_1_a[4] = {0, 0, 0, 0};
    unsigned int team_pos_vec_1_b[4] = {0, 0, 0, 0};
    unsigned int team_pos_vec_2_a[4] = {0, 0, 0, 0};
    unsigned int team_pos_vec_2_b[4] = {0, 0, 0, 0};
    queryHeroBattleFormation(hero_vec[team_1_a].hero_id, team_pos_vec_1_a);
    queryHeroBattleFormation(hero_vec[team_1_b].hero_id, team_pos_vec_1_b);
    queryHeroBattleFormation(hero_vec[team_2_a].hero_id, team_pos_vec_2_a);
    queryHeroBattleFormation(hero_vec[team_2_b].hero_id, team_pos_vec_2_b);

    //决赛阵容
    unsigned int team_pos_vec_final_a[4] = {0, 0, 0, 0};
    unsigned int team_pos_vec_final_b[4] = {0, 0, 0, 0};

    //查询等级
    unsigned int hero_1_a_level = 0;
    {
        HeroInfo info;
        GetHeroBasicInfo(hero_vec[team_1_a].hero_id,info);
        hero_1_a_level = info.level;
    }
    unsigned int hero_1_b_level = 0;
    {
        HeroInfo info;
        GetHeroBasicInfo(hero_vec[team_1_b].hero_id,info);
        hero_1_b_level = info.level;
    }
    unsigned int hero_2_a_level = 0;
    {
        HeroInfo info;
        GetHeroBasicInfo(hero_vec[team_2_a].hero_id,info);
        hero_2_a_level = info.level;
    }
    unsigned int hero_2_b_level = 0;
    {
        HeroInfo info;
        GetHeroBasicInfo(hero_vec[team_2_b].hero_id,info);
        hero_2_b_level = info.level;
    }
    

    //第一组战斗脚本
    FightScript team_1_a_script;
    FightScript team_1_b_script;
    {
        ScriptBuilderUserData userData;
        FightSUD f_sud;
        userData.data = &f_sud;
        
        f_sud.battle_type = BattleType_Arena;
        f_sud.heroId = 0;
        f_sud.taskId = 0;
        f_sud.gridId = 0;
        f_sud.hero_a_level = hero_1_a_level;
        f_sud.hero_b_level = hero_1_b_level;
        FightScriptBuilder scriptBuild;
        f_sud.fightIndex = 1;
        
        scriptBuild.genScript(team_pos_vec_1_a, team_pos_vec_1_b
            , team_1_a_script, team_1_b_script
            , this
            , userData
            , FBB_BoardA
            , -1);
    }
    //
    hero_script_arr[team_1_a].push_back(team_1_a_script);
    hero_script_arr[team_1_b].push_back(team_1_b_script);
    //
    if(team_1_a_script.endResult.myResult == Result_Win)
    {
        memcpy(team_pos_vec_final_a, team_pos_vec_1_a, sizeof(team_pos_vec_1_a));
        team_final_a = team_1_a;
    }
    else
    {
        memcpy(team_pos_vec_final_a, team_pos_vec_1_b, sizeof(team_pos_vec_1_b));
        team_final_a = team_1_b;
    }

    //第二组战斗脚本
    FightScript team_2_a_script;
    FightScript team_2_b_script;
    {
        ScriptBuilderUserData userData;
        FightSUD f_sud;
        userData.data = &f_sud;
        
        f_sud.battle_type = BattleType_Arena;
        f_sud.heroId = 0;
        f_sud.taskId = 0;
        f_sud.gridId = 0;
        f_sud.hero_a_level = hero_2_a_level;
        f_sud.hero_b_level = hero_2_b_level;
        FightScriptBuilder scriptBuild;
        f_sud.fightIndex = 1;
        
        scriptBuild.genScript(team_pos_vec_2_a, team_pos_vec_2_b
            , team_2_a_script, team_2_b_script
            , this
            , userData
            , FBB_BoardA
            , -1);
    }
    //
    hero_script_arr[team_2_a].push_back(team_2_a_script);
    hero_script_arr[team_2_b].push_back(team_2_b_script);
    //
    if(team_2_a_script.endResult.myResult == Result_Win)
    {
        memcpy(team_pos_vec_final_b, team_pos_vec_2_a, sizeof(team_pos_vec_2_a));
        team_final_b = team_2_a;
    }
    else
    {
        memcpy(team_pos_vec_final_b, team_pos_vec_2_b, sizeof(team_pos_vec_2_b));
        team_final_b = team_2_b;
    }

    //查询等级
    unsigned int hero_final_a_level = 0;
    {
        HeroInfo info;
        GetHeroBasicInfo(hero_vec[team_final_a].hero_id,info);
        hero_final_a_level = info.level;
    }
    unsigned int hero_final_b_level = 0;
    {
        HeroInfo info;
        GetHeroBasicInfo(hero_vec[team_final_a].hero_id,info);
        hero_final_b_level = info.level;
    }

    //第三场战斗
    FightScript team_final_a_script;
    FightScript team_final_b_script;
    {
        ScriptBuilderUserData userData;
        FightSUD f_sud;
        userData.data = &f_sud;
        
        f_sud.battle_type = BattleType_Arena;
        f_sud.heroId = 0;
        f_sud.taskId = 0;
        f_sud.gridId = 0;
        f_sud.hero_a_level = hero_final_a_level;
        f_sud.hero_b_level = hero_final_b_level;
        FightScriptBuilder scriptBuild;
        f_sud.fightIndex = 1;
        
        scriptBuild.genScript(team_pos_vec_final_a, team_pos_vec_final_b
            , team_final_a_script, team_final_b_script
            , this
            , userData
            , FBB_BoardA
            , -1);
    }
    //
    hero_script_arr[team_final_a].push_back(team_final_a_script);
    hero_script_arr[team_final_b].push_back(team_final_b_script);

    //向在线玩家打包发送
    for(int i=0; i<hero_vec.size(); ++i)
    {
        if(hero_vec[i].type == ArenaHeroType_OnlinePlayer)
        {
#ifdef _DEBUG
LogMsg("%s, line %d,sendArenaBattleAndGiftRsp to hero_id[%u]"
, __FILE__, __LINE__, hero_vec[i].hero_id);
#endif //_DEBUG

            //扣除随机模式竞技场次数
            {
                char sql[1024];
                sprintf(sql, "update hellgate.arena_hero_info set "
                    " free_fight_remainder_time=free_fight_remainder_time-1 "
                    " where hero_id=%u"
                    , hero_vec[i].hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            //
            unsigned int remainder_time = 0;
            {
                char sql[1024];
                sprintf(sql, "select free_fight_remainder_time from hellgate.arena_hero_info "
                    " where hero_id=%u"
                    , hero_vec[i].hero_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        remainder_time = atoi(Mysql_Thread_Conn->GetField("free_fight_remainder_time"));
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            //先打包战斗脚本
            FightScriptBuilder scriptBuild;
            int buf_len;
            char* buf = scriptBuild.FightScriptVec_2_CharArr(hero_script_arr[i], buf_len);
            CMemGuard guard(buf);
            
            //
            int rspDataLen = sizeof(SPCmd_ArenaGetBattleScriptGiftRsp) + buf_len;
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = arenaGetBattleScriptAndGiftRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_ArenaGetBattleScriptGiftRsp* rspBody = (SPCmd_ArenaGetBattleScriptGiftRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Success);

            rspBody->battle_time_remainder = htonl(remainder_time);

            rspBody->first_turn_hero_id_arr[0] = htonl(hero_vec[team_1_a].hero_id);
            rspBody->first_turn_hero_id_arr[1] = htonl( hero_vec[team_1_b].hero_id);
            rspBody->first_turn_hero_id_arr[2] = htonl( hero_vec[team_2_a].hero_id);
            rspBody->first_turn_hero_id_arr[3] = htonl( hero_vec[team_2_b].hero_id);
            rspBody->second_turn_hero_id_arr[0] = htonl( hero_vec[team_final_a].hero_id);
            rspBody->second_turn_hero_id_arr[1] = htonl( hero_vec[team_final_b].hero_id);

            //宝箱
            if(hero_script_arr[i].size() == 1)
            {
                //第一轮就是输了，只开一个箱子
                rspBody->gift_available_count = 1;
            }
            else if(hero_script_arr[i][1].endResult.myResult == Result_Win)
            {
                //第二轮胜利，开3个箱子 
                rspBody->gift_available_count = 3;
            }
            else
            {
                //第二轮失败，开2个箱子 
                rspBody->gift_available_count = 2;
            }
            std::vector<GiftJifen> gift_vec;
            create9ArenaGiftBox(hero_vec[i].hero_id, (rspBody->gift_available_count), gift_vec);
            for(int j=0; j<9; ++j)
            {
                rspBody->gift_jifen_arr[j].gift_id = htonl(gift_vec[j].gift_id);
                rspBody->gift_jifen_arr[j].jifen = htonl(gift_vec[j].jifen);
            }

            //把脚本打包进去
            rspBody->fightNum = htonl(hero_script_arr[i].size());
            memcpy(rspBody->fightScript_array, buf, buf_len);
            
            Packet* rsppack = new Packet;
            rsppack->fd_account = "";
            rsppack->client_id = 0;
            rsppack->main_hero_id = hero_vec[i].hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);

            
            //触发日常任务  这个在两个线程中 可能需要加入信号量
            send_system_bonus_notify(hero_vec[i].hero_id, BonusType_DayWelfare, BonusID_Random_Arena);
        }
    }

}

void ProcServerThread::getRobot(unsigned int level_min,unsigned int level_max
    , std::vector < unsigned int > hero_id_except
    ,unsigned int robot_need_count,std::vector < unsigned int > & robot_vec)
{
    robot_vec.clear();

    if(robot_need_count > 1)
    {
        assert(false);
        return;
    }

    //stub
    //从hero_list里随机
    std::vector<unsigned int> hero_vec;
    {
        char sql[1024];
        sprintf(sql, "select hero_id "
            " from hellgate.hero_infor "
            " where parent_hero_id=0 "
            " and level>=%u and level<=%u"
            , level_min, level_max);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                if(hero_id > 0)
                {
                    int i=0;
                    for(; i<hero_id_except.size(); ++i)
                    {
                        if(hero_id == hero_id_except[i])
                        {
                            break;
                        }
                    }
                    if(i == hero_id_except.size())
                    {
                        hero_vec.push_back(hero_id);
                    }
                    
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(hero_vec.size() ==0)
    {
        char sql[1024];
        sprintf(sql, "select hellgate.hero_list.hero_id "
            " from hellgate.hero_list, hellgate.hero_infor "
            " where hellgate.hero_list.hero_id=hellgate.hero_infor.hero_id "
            " and level>=8"
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                if(hero_id > 0)
                {
                    int i=0;
                    for(; i<hero_id_except.size(); ++i)
                    {
                        if(hero_id == hero_id_except[i])
                        {
                            break;
                        }
                    }
                    if(i == hero_id_except.size())
                    {
                        hero_vec.push_back(hero_id);
                    }
                    
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    unsigned int index = Utl::auto_random()%(hero_vec.size());
    robot_vec.push_back(hero_vec[index]);


}

Guaiwu ProcServerThread::getTeamBossMonster(unsigned int level, unsigned int hard_level)
{
    GuaiWuData g_Data;
    g_Data.level = level;
    g_Data.gongJiLi = 800 + 800;
    g_Data.xueLiang = 2600+ 2;
    g_Data.baoJiLv = 100 + 8;
    g_Data.baoShangYinZi = 120;
    g_Data.jiNengChuFaLv = 100 + 60;
    g_Data.huJiaJianMianLv = 20;
    g_Data.kangXingJianMianLv = 10 + 5;
    g_Data.gongJiJuLi = 1;
    g_Data.shangHaiLeiXing = SHANG_HAI_WU_LI;
    g_Data.profession = (Profession)90;
    
    Guaiwu boss;
    boss.initWithGuaiwuData(g_Data);
    boss.setDefaultCdTime(0);

    boss.skilVec.push_back(SkillType_LeiBao);

    return boss;
}


void ProcServerThread::getHeroSkill(unsigned int hero_id
    , SkillType& skill_type, unsigned int& skill_level)
{
    //
    skill_type = (SkillType)SkillType_LieGong;
    skill_level = 1;
    {
        char sql[1024];
        sprintf(sql, "select skill_type, skill_level "
            " from hellgate.skill_in_team where own_hero_id=%u and is_equiped=1"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_type = (SkillType)atoi(Mysql_Thread_Conn->GetField("skill_type"));
                skill_level = atoi(Mysql_Thread_Conn->GetField("skill_level"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u] has not equiped skill."
                        , __FILE__, __LINE__, hero_id);
                skill_type = SkillType_LieGong;
                skill_level = 1;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return ;
}


void ProcServerThread::create9ArenaGiftBox(
    unsigned int hero_id, int available_box_count, std::vector< GiftJifen>& gift_vec)
{
    
    //生成9个随机积分
    {
        //九个宝箱中固定5个煅金粉，2个恶魔骨，2个1级宝石
        int jifen_gao_count =3;
        int jifen_zhong_count =3;
        int jifen_di_count = 3;
        for(int i=0; i<9; ++i)
        {
            GiftJifen gift;
            gift.gift_id = 0;
            gift.jifen = 0;
            
            int v = Utl::auto_random()%(9 -i);
            if((v -= jifen_gao_count) < 0)
            {
                gift.jifen = 20;

                jifen_gao_count--;
            }
            else if((v -= jifen_zhong_count) < 0)
            {
                gift.jifen = 16;

                jifen_zhong_count--;
            }
            else if((v -= jifen_di_count) < 0)
            {
                gift.jifen = 12;

                jifen_di_count--;
            }
            else
            {
                assert(false);
            }

            gift_vec.push_back(gift);
        }
    }
    

    //获取锁
    pthread_mutex_lock(&m_arena_gift_pool_mutex);
    {
        //首先找到目前最大的宝箱id
        unsigned int max_gift_id = 0;
        {
            char sql[1024];
            sprintf(sql, "select max(gift_id) max_gift_id "
                " from hellgate.arena_gift"
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    max_gift_id = atoi(Mysql_Thread_Conn->GetField("max_gift_id"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        for(int i=0; i<available_box_count; ++i)
        {
            gift_vec[i].gift_id = max_gift_id+1+i;
            
            char sql[1024];
            sprintf(sql, "insert into  hellgate.arena_gift set gift_id=%u, hero_id=%u, jifen_count=%u"
                , gift_vec[i].gift_id, hero_id, gift_vec[i].jifen);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    pthread_mutex_unlock(&m_arena_gift_pool_mutex);
    
}

bool ProcServerThread::getArenaGiftBox(unsigned int hero_id,unsigned int gift_id,GiftJifen & gift_data)
{
    //获取锁
    CPthreadMutexAutoLockAutoUnlock auto_lock(&m_arena_gift_pool_mutex);
    
    //查找
    bool found= false;
    unsigned int jifen_count;
    {
        
        char sql[1024];
        sprintf(sql, "select jifen_count from hellgate.arena_gift "
            " where gift_id=%u and hero_id=%u"
            , gift_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                found= true;
                
                jifen_count = atoi(Mysql_Thread_Conn->GetField("jifen_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!found)
    {
        return false;
    }
    

    //
    gift_data.gift_id = gift_id;
    gift_data.jifen = jifen_count;

    //delete
    {
        
        char sql[1024];
        sprintf(sql, "delete from hellgate.arena_gift "
            " where gift_id=%u and hero_id=%u"
            , gift_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

ArenaRoom* ProcServerThread::getArenaRoom(unsigned int hero_level,unsigned char hard_level)
{
    //stub
    return &(m_arena.room_arr[0]);;
    
    int room_index = hero_level-1;
    
    if(hero_level == HERO_MAX_LEVEL)
    {
        room_index += hard_level - 1;
    }

    return &(m_arena.room_arr[room_index]);
}

void ProcServerThread::teamBossTimer()
{
    //获取锁
    CPthreadMutexAutoLockAutoUnlock auto_lock(&m_teamBossHall.mutex);
    
    //进入团队boss数据结构
    {
        time_t current_time = time(0);
        
        for(int i=0; i<HERO_MAX_LEVEL+ARENA_HARD_LEVEL_COUNT-1; ++i)
        {
            TeamBossRoom* room = &(m_teamBossHall.room_arr[i]);

            if(room->hero_vec.size() > 0 && current_time - room->create_time >= TeamBossCreateTeamTimeOut)
            {
                std::vector<TeamBossHero> total_hero_vec = room->hero_vec;
                
                //超时，找人填充
                for(int index_stub=0; index_stub<4-room->hero_vec.size(); ++index_stub)
                {
                    //
                    std::vector<unsigned int> hero_except;
                    for(int m=0; m<total_hero_vec.size(); ++m)
                    {
                        hero_except.push_back(total_hero_vec[m].hero_id);
                    }
                    std::vector<unsigned int> robot_vec;
                    getRobot(i,i, hero_except, 1, robot_vec);
                    
                    //
                    TeamBossHero stub_hero;
                    stub_hero.type = TeamBossHeroType_StubPlayer;
                    stub_hero.hero_id = robot_vec[0];
                    
                    total_hero_vec.push_back(stub_hero);

                    //给所有真实在线玩家发送update
                    for(int index_hero=0; index_hero<room->hero_vec.size(); ++index_hero)
                    {
                        if(room->hero_vec[index_hero].type == TeamBossHeroType_OnlinePlayer)
                        {
                            sendTeamBossUpdateRoomRsp(room->hero_vec[index_hero].hero_id
                                , stub_hero.hero_id);
                        }
                    }
                }

                //清空room
                room->create_time = 0;
                room->hero_vec.clear();

                //生成并发送战斗脚本以及宝箱
                sendTeamBossBattleAndGiftRsp(i+1, 0, total_hero_vec);

                //支线任务竞技场完成
                for(int i=0; i<total_hero_vec.size(); ++i)
                {
                    if(total_hero_vec[i].type == TeamBossHeroType_OnlinePlayer)
                    {
                        subtaskPointFinished(total_hero_vec[i].hero_id, SubtaskId_Richang_teamboss_duanzaocailiao);
                    }
                }
            }
        }
    }
}
TeamBossRoom* ProcServerThread::getTeamBossRoom(unsigned int hero_level, unsigned char hard_level)
{
    //stub
    return &(m_teamBossHall.room_arr[0]);
    
    int room_index = hero_level-1;
    
    if(hero_level == HERO_MAX_LEVEL)
    {
        room_index += hard_level - 1;
    }

    return &(m_teamBossHall.room_arr[room_index]);
}
void ProcServerThread::sendTeamBossUpdateRoomRsp(unsigned int to_hero_id, unsigned int new_enter_hero_id)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::sendTeamBossUpdateRoomRsp to_hero_id[%u], new_hero_id[%u]"
, __FILE__, __LINE__, to_hero_id, new_enter_hero_id);
#endif //_DEBUG

    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_id"
            " from hellgate.zhuangbei_list"
            " where zhuangbei_hero_id=%u"
            , new_enter_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    int rspDataLen = sizeof(SPCmd_TeamBossUpdateRoomRsp) + zhuangbei_detail_data_len;
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = teamBossUpdateRoomRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TeamBossUpdateRoomRsp* rspBody = (SPCmd_TeamBossUpdateRoomRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    HeroInfo heroinfo;
    GetHeroBasicInfo(new_enter_hero_id,heroinfo);
    hton_hero_info(heroinfo, rspBody->new_hero_info);

    //
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = to_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}
void ProcServerThread::sendTeamBossEnterRsp(unsigned int to_client_id, unsigned int to_hero_id
    , std::string fd_account, std::vector<TeamBossHero> partner)
{
    assert(partner.size() < 4);
    
    //获取装备列表
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;
    if(partner.size() > 0)
    {
        {
            char zhuangbei_hero_str[128];
            sprintf(zhuangbei_hero_str, " zhuangbei_hero_id=%u ", partner[0].hero_id);
            for(int i=1; i<partner.size(); ++i)
            {
                char str[64];
                sprintf(str, " or zhuangbei_hero_id=%u ", partner[i].hero_id);

                strcat(zhuangbei_hero_str, str);
            }
            
            char sql[2048];
            sprintf(sql, "select zhuangbei_id"
                " from hellgate.zhuangbei_list"
                " where %s"
                , zhuangbei_hero_str);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    __ZhuangbeiDetail detail;
                    
                    detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                    zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        for(int i=0; i<zhuangbei_vec.size(); ++i)
        {
            unsigned int owner_id;
            getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
        }
    }

    //先将zhuangbeidetail转换出来
    char* zhuangbei_detail_data = new char[ZhuangbeiDetail::max_length()*zhuangbei_vec.size()];
    CMemGuard guard((char*)zhuangbei_detail_data);
    unsigned int zhuangbei_detail_data_len = 0;
    char* p = zhuangbei_detail_data;
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int len;
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton((ZhuangbeiDetail*)p, len);

        p += len;
        zhuangbei_detail_data_len += len;
    }

    //
    int rspDataLen = sizeof(SPCmd_TeamBossEnterRsp) + zhuangbei_detail_data_len;
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = teamBossEnterRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_TeamBossEnterRsp* rspBody = (SPCmd_TeamBossEnterRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    
    rspBody->hero_info_arr[0].hero_id = 0;
    rspBody->hero_info_arr[1].hero_id = 0;
    rspBody->hero_info_arr[2].hero_id = 0;
    for(int i=0; i<partner.size(); ++i)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(partner[i].hero_id,hero_info);

        hton_hero_info(hero_info, rspBody->hero_info_arr[i]);
    }

    //
    rspBody->zhuangbei_count = htonl(zhuangbei_vec.size());
    
    memcpy(rspBody->data, zhuangbei_detail_data, zhuangbei_detail_data_len);

    Packet* rsppack = new Packet;
    rsppack->fd_account = fd_account;
    rsppack->client_id = to_client_id;
    rsppack->main_hero_id = to_hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}
void ProcServerThread::sendTeamBossBattleAndGiftRsp(
    unsigned int room_level, unsigned char room_hard_level
    , std::vector<TeamBossHero> hero_vec)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::sendTeamBossBattleAndGiftRsp "
, __FILE__, __LINE__);
#endif //_DEBUG

    //保存最终计算出的4个玩家队伍的总属性
    std::vector<TeamBaseProperty> player_team_pro_vec;
    std::vector< std::vector<EquipData> > main_hero_equip;
    unsigned int main_hero_jineng_chufazhouqi = 0;
    unsigned int main_hero_jineng_chufalunci = 0;
    unsigned int main_hero_jineng_jiacheng = 0;
    for(int i=0; i<hero_vec.size(); ++i)
    {
        //获取队伍布阵
        unsigned int team_pos[4] = {0, 0, 0, 0};
        queryHeroBattleFormation(hero_vec[i].hero_id, team_pos);

        //独立计算每个角色的属性
        std::vector<TeamBaseProperty> pro_vec;
        for(int index=0; index<4; ++index)
        {
            if(team_pos[index] == 0)
            {
                continue;
            }

            //
            Hero* actor = new Hero();
            {
                //首先获取基本属性 
                HeroDetail hero_detail;
                GetHeroDetail(team_pos[index], hero_detail);

                //获取装备
                std::vector<__ZhuangbeiDetail> zhuangbei_vec;
                {
                    char sql[1024];
                    sprintf(sql, "select zhuangbei_id "
                        " from hellgate.zhuangbei_list "
                        " where zhuangbei_hero_id=%u"
                        , team_pos[index]);
                    try
                    {
                        Mysql_Thread_Conn->Query(sql);
                        while(Mysql_Thread_Conn->FetchRow() != NULL)
                        {
                            __ZhuangbeiDetail detail;
                            
                            detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                            

                            //
                            zhuangbei_vec.insert(zhuangbei_vec.end(), detail);
                        }
                        
                        Mysql_Thread_Conn->FreeResult();
                    }
                    catch(CMysqlException& e)
                    {
                        LogMsg("%s, line %d, mysql exception. [%s]"
                                    , __FILE__, __LINE__, e.GetErrMsg());
                        //
                        exit(1);
                    }
                }
                for(int i=0; i<zhuangbei_vec.size(); ++i)
                {
                    unsigned int owner_id;
                    getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);
                }

                
                {
                    HeroBaseProperty property;
                    property.hero_id= team_pos[index];
                    property.profession = (Profession)hero_detail.basic_info.profession_id;
                    property.level = hero_detail.basic_info.level;

                    property.exp_current = hero_detail.exp_current;
                    property.exp_need = hero_detail.exp_need;
                    property.parent_hero_id = hero_detail.parent_hero_id;
                    property.postion = hero_detail.postion;
                    property.vit_current = hero_detail.vit_current;

                    property.mLiLiang = hero_detail.hero_attr_without_zhuangbei.liliang;
                    property.mMinJie = hero_detail.hero_attr_without_zhuangbei.mingjie;
                    property.mZhiLi = hero_detail.hero_attr_without_zhuangbei.zhili;
                    property.mTiNeng = hero_detail.hero_attr_without_zhuangbei.tineng;
                    property.mHP = hero_detail.hero_attr_without_zhuangbei.xueliang;
                    property.mGongJiJuLi = CS::getHeroGongjiJuLiByProfession(hero_detail.basic_info.profession_id);
                    property.mBaoJiLv = hero_detail.hero_attr_without_zhuangbei.baoji;
                    //property.mBaoJiShangHaiYinZi = hero_detail.hero_attr_without_zhuangbei.baoshang;
                    property.mBaoJiShangHaiYinZi = hero_detail.hero_attr_without_zhuangbei.baoshang;
                    property.mJiNengFaChuLv = hero_detail.hero_attr_without_zhuangbei.jinengchufa;
                    property.mShangHaiLeiXing = getShangHaiType((Profession)hero_detail.basic_info.profession_id);
                    actor->init(property);
                    actor->setDefaultCdTime(TeamBossRestartCDTime);

                    SkillType skill_type;
                    unsigned int skill_level;
                    getHeroSkill(actor->getHeroBaseProperty_R()->hero_id, skill_type, skill_level);
                    SkillDataForFight skill_data(skill_type, skill_level);
                    actor->skilVec.push_back(skill_data);

                    for(int i=0; i<zhuangbei_vec.size(); ++i)
                    {
                        unsigned int tmp_detail_data_len = 0;
                        ZhuangbeiDetail* tmp_detail 
                            = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];
                        CMemGuard guard_1((char*)tmp_detail);
                        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton(tmp_detail, tmp_detail_data_len);
                        ZhuangbeiDetail* out_detail 
                            = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];;
                        CMemGuard guard_2((char*)out_detail);
                        ntoh_zhuangbei_detail(*tmp_detail,*out_detail);
                        
                        EquipData data;
                        data.initWithZhungbeiDetail(out_detail);

                        actor->equipVec.push_back(data);

                        
                    }
                    //如果是主角，则记录下他的装备
                    if(hero_detail.parent_hero_id == 0)
                    {
                        main_hero_equip.push_back(actor->equipVec);
                    }
                        
                    actor->zhuangbeiOpEnd();

                }

                ////角色与装备合成
                FightScriptBuilder builder;
                TeamBaseProperty teambase_pro = builder.combineActorProperty(actor);
                if(hero_detail.parent_hero_id == 0)
                {
                    main_hero_jineng_chufalunci = teambase_pro.mJiNengTurn;
                    main_hero_jineng_chufazhouqi = teambase_pro.mJiNengZhouQi;
                    main_hero_jineng_jiacheng = teambase_pro.mJiNengResultPercent;
                }
                
                pro_vec.push_back(teambase_pro);
            }

            
        }

        //
        HeroInfo main_hero_info;
        GetHeroBasicInfo(hero_vec[i].hero_id, main_hero_info);
        
        //将本队所有队员的属性合成
        TeamBaseProperty pro;
        memset(&pro, 0, sizeof(pro));
        pro.leaderProfression = (Profession)main_hero_info.profession_id;
        pro.mLeaderId = main_hero_info.hero_id;
        pro.mLevel = main_hero_info.level;
        pro.mGongJiJuLi = CS::getHeroGongjiJuLiByProfession(main_hero_info.profession_id);
        pro.mShangHaiLeiXing = getShangHaiType((Profession)main_hero_info.profession_id);
        for(int index=0; index<pro_vec.size(); ++index)
        {
            pro.mHP += pro_vec[index].mHP;                          // 生命值,
            pro.mGongJiLi_MIN += pro_vec[index].mGongJiLi_MIN;                   // 攻击力
            pro.mGongJiLi_MAX += pro_vec[index].mGongJiLi_MAX;                   // 攻击力
            pro.mBaoJiLv += pro_vec[index].mBaoJiLv;                          // 暴击率
            pro.mBaoJiShangHaiYinZi += pro_vec[index].mBaoJiShangHaiYinZi;              // 暴击的伤害因子，比如150%，就是攻击的150
            pro.mJiNengFaChuLv += pro_vec[index].mJiNengFaChuLv;                    // 技能发出概率
            pro.mShanBiLv += pro_vec[index].mShanBiLv;                         // 闪避率
            pro.mGeDangLv += pro_vec[index].mGeDangLv;                          // 格挡率
            pro.mGeDangZhi += pro_vec[index].mGeDangZhi;                       // 格挡值
            pro.mHuJiaZhi += pro_vec[index].mHuJiaZhi;                       // 护甲值
            pro.mKangXingZhi += pro_vec[index].mKangXingZhi;                     // 抗性值
            pro.mDefaultFreezyNum = TeamBossRestartCDTime;                  // 默认冷却时间
        }
        pro.mJiNengResultPercent = main_hero_jineng_jiacheng;
        pro.mJiNengTurn = main_hero_jineng_chufalunci;
        pro.mJiNengZhouQi = main_hero_jineng_chufazhouqi;
        pro.mBaoJiLv /= pro_vec.size();
        pro.mBaoJiShangHaiYinZi /= pro_vec.size();
        pro.mJiNengFaChuLv /= pro_vec.size();
        pro.mShanBiLv /= pro_vec.size();
        pro.mGeDangLv /= pro_vec.size();


        //
        player_team_pro_vec.push_back(pro);
    }

    //生成脚本
    std::vector<FightScript> fight_scripts;
    TeamEndParam fight_endData;
    {
    
        FightScriptBuilder builder;
        
        std::vector<TeamHero> teams;
        {
            for(int i=0; i<hero_vec.size(); ++i)
            {
                TeamHero hero;
                hero.initWithTeamBaseProperty(player_team_pro_vec[i]);

                SkillType skill_type;
                unsigned int skill_level;
                getHeroSkill(hero_vec[i].hero_id, skill_type, skill_level);
                SkillDataForFight skill_data(skill_type, skill_level);
                hero.skilVec.push_back(skill_data);
                hero.equipVec = main_hero_equip[i];

                teams.push_back(hero);
            }
        }


        Guaiwu boss = getTeamBossMonster(room_level, room_hard_level);
        
        TeamHero* teams_p[4] = {NULL};
        for(int i=0; i<teams.size(); ++i)
        {
            teams_p[i] = &teams[i];
        }
        builder.genTeamFightScript(teams_p,&boss,fight_scripts,fight_endData);
    }

    //计算排名
    std::vector<unsigned int> player_order;
    for(int i=0; i<hero_vec.size(); ++i)
    {
        int hp = fight_endData.fightedBlood[i];
        int order = 1;
        for(int j=0; j<hero_vec.size(); ++j)
        {
            if(j == i)
            {
                continue;
            }

            if(fight_endData.fightedBlood[j] > hp)
            {
                order++;
            }
            else if(fight_endData.fightedBlood[j] == hp)
            {
                if(i > j)
                {
                    //排在后面的吃点亏
                    order++;
                }
            }
        }

        player_order.push_back(order);
    }

    //向在线玩家打包发送
    for(int i=0; i<hero_vec.size(); ++i)
    {
        if(hero_vec[i].type == TeamBossHeroType_OnlinePlayer)
        {
#ifdef _DEBUG
LogMsg("%s, line %d,sendTeamBossBattleAndGiftRsp to hero_id[%u]"
, __FILE__, __LINE__, hero_vec[i].hero_id);
#endif //_DEBUG

            //先打包战斗脚本
            FightScriptBuilder scriptBuild;
            int buf_len;
            std::vector<FightScript> script_vec;
            script_vec.push_back(fight_scripts[i]);
            char* buf = scriptBuild.FightScriptVec_2_CharArr(script_vec, buf_len);
            CMemGuard guard(buf);

            //
            int rspDataLen = sizeof(SPCmd_TeamBossGetBattleScriptGiftRsp) + buf_len;
            SPHead* rspHead;
            (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
            (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
            (rspHead)->protocol_ver = 1;
            (rspHead)->cmd = teamBossGetBattleScriptAndGiftRsp;
            (rspHead)->data_len = rspDataLen;
            //将包头转换为网络字节序
            hton_SPHead((rspHead));
            
            SPCmd_TeamBossGetBattleScriptGiftRsp* rspBody = (SPCmd_TeamBossGetBattleScriptGiftRsp*)((rspHead)+1);
            rspBody->err_code = htonl(Success);

            //排名结算
            for(int index=0; index<hero_vec.size(); ++index)
            {
                rspBody->score_arr[index].hero_id = htonl(hero_vec[index].hero_id);
                rspBody->score_arr[index].order = player_order[index];
                rspBody->score_arr[index].boss_hp = htonl(fight_endData.fightedBlood[index]);
            }

            //宝箱
            rspBody->gift_available_count = 0;
            //判断是否打赢
            if(fight_scripts[i].endResult.myResult == Result_Win)
            {
                if(player_order[i] == 1)
                {
                    //
                    rspBody->gift_available_count = 3;
                }
                else if(player_order[i] == 2)
                {
                    //
                    rspBody->gift_available_count = 2;
                }
                else
                {
                    //
                    rspBody->gift_available_count = 1;
                }
                std::vector<GiftData> gift_vec;
                create9TeamBossGiftBox(hero_vec[i].hero_id, (rspBody->gift_available_count), gift_vec);
                for(int j=0; j<9; ++j)
                {
                    rspBody->gift_data_arr[j] = gift_vec[j].htonl_gift();
                }
            }

            //把脚本打包进去
            memcpy(rspBody->fightScript, buf, buf_len);
            
            Packet* rsppack = new Packet;
            rsppack->fd_account = "";
            rsppack->client_id = 0;
            rsppack->main_hero_id = hero_vec[i].hero_id;
            rsppack->packdata = (char*)rspHead;

            m_outport_q->push(rsppack);
        }
    }
}

void ProcServerThread::create9TeamBossGiftBox(unsigned int hero_id
    , int available_box_count, std::vector<GiftData>& gift_vec)
{
    //生成9个随机宝箱
    {
        //九个宝箱中固定5个煅金粉，2个恶魔骨，2个1级宝石
        int cailiao_cy_count=2;
        //int cailiao_xy_count=5;
        int baoshi_count=2;
        for(int i=0; i<9; ++i)
        {
            GiftData gift;
            gift.type = GiftType_Item;
            gift.data_union.item.type = 0;
            gift.data_union.item.count = 0;
            
            int v = Utl::auto_random()%(9 -i);
            if((v -= cailiao_cy_count) < 0)
            {
                gift.data_union.item.type = ItemsType_QianghuaChuangqi;
                gift.data_union.item.count = 5;

                cailiao_cy_count--;
            }
            /*
            else if((v -= cailiao_xy_count) < 0)
            {
                gift.data_union.item.type = ItemsType_QianghuaXiyou;
                gift.data_union.item.count = 5;

                cailiao_xy_count--;
            }
            */
            else if((v -= baoshi_count) < 0)
            {
                unsigned int x = Utl::auto_random()%4;
                switch(x)
                {
                    case 0:
                        gift.data_union.item.type = ItemsType_Baoshi_hong_1;
                    break;
                    case 1:
                        gift.data_union.item.type = ItemsType_Baoshi_lv_1;
                    break;
                    case 2:
                        gift.data_union.item.type = ItemsType_Baoshi_huang_1;
                    break;
                    default:
                        //gift.data_union.item.type = ItemsType_Baoshi_zhi_1;
                    break;
                    
                }
                
                gift.data_union.item.count = 3;

                baoshi_count--;
            }
            else
            {
                assert(false);
            }

            gift_vec.push_back(gift);
        }
    }

    //获取锁
    pthread_mutex_lock(&m_teamboss_gift_pool_mutex);
    {
        //首先找到目前最大的宝箱id
        unsigned int max_gift_id = 0;
        {
            char sql[1024];
            sprintf(sql, "select max(gift_id) max_gift_id "
                " from hellgate.teamboss_gift"
                );
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    max_gift_id = atoi(Mysql_Thread_Conn->GetField("max_gift_id"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        for(int i=0; i<available_box_count; ++i)
        {
            gift_vec[i].gift_id = max_gift_id+1+i;
            
            char sql[1024];
            sprintf(sql, "insert into  hellgate.teamboss_gift set gift_id=%u, hero_id=%u, item_type=%u, item_count=%u"
                , gift_vec[i].gift_id, hero_id, gift_vec[i].data_union.item.type, gift_vec[i].data_union.item.count);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    pthread_mutex_unlock(&m_teamboss_gift_pool_mutex);
}
bool ProcServerThread::getTeamBossGiftBox(unsigned int hero_id, unsigned int gift_id, GiftData& gift_data)
{
    //获取锁
    CPthreadMutexAutoLockAutoUnlock auto_lock(&m_teamboss_gift_pool_mutex);
    
    //查找
    bool found= false;
    unsigned int item_type;
    unsigned int item_count;
    {
        
        char sql[1024];
        sprintf(sql, "select item_type, item_count from hellgate.teamboss_gift "
            " where gift_id=%u and hero_id=%u"
            , gift_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                found= true;
                
                item_type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item_count = atoi(Mysql_Thread_Conn->GetField("item_count")); 
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!found)
    {
        return false;
    }
    

    //
    gift_data.gift_id = gift_id;
    gift_data.type = GiftType_Item;
    gift_data.data_union.item.type = item_type;
    gift_data.data_union.item.count = item_count;

    //delete
    {
        
        char sql[1024];
        sprintf(sql, "delete from hellgate.teamboss_gift "
            " where gift_id=%u and hero_id=%u"
            , gift_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

void ProcServerThread::subtaskPointFinished(unsigned int hero_id,unsigned int subtask_id)
{
    //首先查询英雄是否有此任务 
    unsigned int reward_item_id = 0;
    unsigned int reward_item_count = 0;
    {
        char sql[1024];
        sprintf(sql, "select "
            " reward_item_id, reward_item_count "
            " from hellgate.hero_subtask, hellgate.subtask_list "
            " where hellgate.hero_subtask.task_id=hellgate.subtask_list.task_id "
            " and hellgate.hero_subtask.task_id=%u and hero_id=%u and task_status=%u "
            , subtask_id, hero_id, (int)TaskStatus_Got);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                reward_item_id = atoi(Mysql_Thread_Conn->GetField("reward_item_id"));
                reward_item_count = atoi(Mysql_Thread_Conn->GetField("reward_item_count"));
            }
            else
            {
                //无此任务，返回
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //先获取奖励
    ObtainItem(hero_id,reward_item_id,reward_item_count);
    //删除任务
    {
        char sql[1024];
        sprintf(sql, "delete from hellgate.hero_subtask where hero_id=%u and task_id=%u "
            , hero_id, subtask_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    //
    int rspDataLen = sizeof(SPCmd_SubTaskSubmitedRsp);
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = subTaskSubmitedRsp;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SubTaskSubmitedRsp* rspBody = (SPCmd_SubTaskSubmitedRsp*)((rspHead)+1);
    rspBody->err_code = htonl(Success);

    rspBody->task_id = htonl(subtask_id);
    rspBody->reward_item_id = htonl(reward_item_id);
    rspBody->reward_item_count = htonl(reward_item_count);
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::queryHeroBattleFormation(
    unsigned int main_hero_id, unsigned int hero_formation[])
{
    hero_formation[0] = 0;
    hero_formation[1] = 0;
    hero_formation[2] = 0;
    hero_formation[3] = 0;
    
    {
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , main_hero_id, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, main_hero_id, pos);
                }
                else
                {
                    hero_formation[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


bool ProcServerThread::checkAndBuyItemInArenaMarket(unsigned int hero_id
    ,unsigned int item_type,unsigned int item_count , unsigned int& jifen_balance)
{
    jifen_balance = 0;
    
    //查询价格
    unsigned int jifen_need;
    {
        char sql[1024];
        sprintf(sql, "select jifen_count, item_count "
            " from hellgate.arena_market where item_type=%u"
            , item_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int tmp_jifen = atoi(Mysql_Thread_Conn->GetField("jifen_count"));
                unsigned int tmp_count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                if(tmp_count > 0 ) {
                    jifen_need = tmp_jifen * (item_count /tmp_count);
                }
                else {
                    LogMsg("%s, line %d, item_type[%u] item_count[%u] is 0"
                            , __FILE__, __LINE__, item_type, item_count);

                    Mysql_Thread_Conn->FreeResult();
                    return false;
                }
            }
            else
            {
                LogMsg("%s, line %d, item_type[%u] not in market"
                        , __FILE__, __LINE__, item_type);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询余额
    {
        char sql[1024];
        sprintf(sql, "select jifen "
            " from hellgate.arena_hero_info where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                jifen_balance = atoi(Mysql_Thread_Conn->GetField("jifen"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u] not exist"
                        , __FILE__, __LINE__, hero_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(jifen_balance < jifen_need)
    {
        LogMsg("%s, line %d, hero_id[%u] jifen balance not enough"
                        , __FILE__, __LINE__, hero_id);
        return false;
    }

    //先添加物品
    {
        ObtainItem(hero_id,item_type,item_count);
    }

    //再扣钱
    jifen_balance -= jifen_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.arena_hero_info set jifen=%u "
            " where hero_id=%u"
            , jifen_balance, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

bool ProcServerThread::checkAndBuyChlgTime(unsigned int main_hero_id, unsigned int buy_time
    ,unsigned int & chlg_remainder_time, unsigned int& buy_chalg_remainder_time
    ,unsigned int & gold_balance)
{
    chlg_remainder_time = 0;
    gold_balance = 0;
    buy_chalg_remainder_time = 0;

    //查询能买几次
    {
        char sql[1024];
        sprintf(sql, "select buy_arena_num from hellgate.hero_vip_info "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                buy_chalg_remainder_time = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(buy_chalg_remainder_time == 0)
    {
        return false;
    }
    if(buy_time > buy_chalg_remainder_time)
    {
        return false;
    }

    //总共需要多少钱 
    unsigned int gold_need = buy_time*CS::arenaBuyOneChlgTimeNeedGold();

    //查询余额
    gold_balance = getItemCountInTeam(main_hero_id, ItemsType_Gold);

    if(gold_balance < gold_need)
    {
        LogMsg("%s, line %d, hero_id[%u] gold balance not enough"
                        , __FILE__, __LINE__, main_hero_id);
        return false;
    }

    //
    buy_chalg_remainder_time -= buy_time;

    
    //先添加
    {
        char sql[1024];
        sprintf(sql, "update hellgate.arena_hero_info set "
            " challenge_remainder_time=challenge_remainder_time+%u "
            " where hero_id=%u"
            , buy_time
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //更新竞技场购买次数
    updateHeroVipInfo(main_hero_id, VIP_FIELD_TYPE_ARENA, buy_chalg_remainder_time);

    //再扣钱
    gold_balance -= gold_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , gold_balance, main_hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再查询
    {
        char sql[1024];
        sprintf(sql, "select challenge_remainder_time from hellgate.arena_hero_info "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                chlg_remainder_time = atoi(Mysql_Thread_Conn->GetField("challenge_remainder_time"));
            }
            else
            {
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

bool ProcServerThread::checkAndRefreshArenaChlgList(unsigned int hero_id
    , vector < ArenaChlgerHeroInfo > & hero_vec
    , unsigned int & gold_balance, unsigned int& silver_balance, ItemInfo& item)
{
    hero_vec.clear();
    gold_balance = 0;
    silver_balance = 0;

    HeroInfo main_hero_info;
    GetHeroBasicInfo(hero_id, main_hero_info);

    //查询余额
    gold_balance = getItemCountInTeam(hero_id, ItemsType_Gold);
    silver_balance = getItemCountInTeam(hero_id, ItemsType_Silver);
    
    //首先查本次刷新需要多少钱
    unsigned int refresh_times = 0;
    {
        //
        char sql[1024];
        sprintf(sql, "select refresh_times "
            " from hellgate.arena_hero_chlg_list "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                refresh_times = atoi(Mysql_Thread_Conn->GetField("refresh_times"));
            }
            else {
                LogMsg("%s, line %d, in checkAndRefreshArenaChlgList nut has not chlg_list record. hero_id[%u]"
                        , __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询刷新需要货币
    CS::refreshArenaChlgListNeedItem(refresh_times +1, item);

    if(item.type == ItemsType_Gold) { // 消耗金币刷新
        if(gold_balance < item.count){
            LogMsg("%s, line %d, hero_id[%u] gold balance not enough"
                , __FILE__, __LINE__, hero_id);
            return false;
        }
    }
    else if(item.type == ItemsType_Silver) { // 消耗银币刷新
        if(silver_balance < item.count){
            LogMsg("%s, line %d, hero_id[%u] gold balance not enough"
                , __FILE__, __LINE__, hero_id);
            return false;
        }
    }

    //刷新
    {
        std::vector<unsigned int> robot_id_vec;
        for(int i=0; i<6; ++i)
        {
            std::vector<unsigned int> hero_id_except;
            hero_id_except.push_back(hero_id);
            hero_id_except.insert(hero_id_except.end(), robot_id_vec.begin(), robot_id_vec.end());
            std::vector<unsigned int> temp_vec;

            unsigned int robot_level_min = 0;
            if(main_hero_info.level >= 3)
            {
                robot_level_min = main_hero_info.level - 3;
            }
            getRobot(robot_level_min,main_hero_info.level+3, hero_id_except,1,temp_vec);

            robot_id_vec.push_back(temp_vec[0]);
        }
        
        //查询出对手信息
        for(int i=0; i<robot_id_vec.size(); ++i)
        {
            HeroInfo hero_info;
            GetHeroBasicInfo(robot_id_vec[i],hero_info);

            //计算应得积分
            unsigned int jifen = ArenaChallenge_NormalJifen;
            if(hero_info.level > main_hero_info.level+1)
            {
                jifen = ArenaChallenge_HighJifen;
            }
            else if(hero_info.level < main_hero_info.level-1)
            {
                 jifen = ArenaChallenge_LowJifen;
            }

            ArenaChlgerHeroInfo chlger_info;
            memcpy(&chlger_info.hero_info, &hero_info, sizeof(hero_info));
            chlger_info.has_win = false;
            chlger_info.jifen = jifen;

            hero_vec.push_back(chlger_info);
        }

        //已等级来从大到小的排序
        arena_bubble_sort(hero_vec);

        //
        char sql[1024];
        sprintf(sql, "update hellgate.arena_hero_chlg_list "
            " set refresh_timestamp=%u, refresh_times=%u, "
            " chlger_hero_id_1=%u, jifen_1=%u, chlg_win_1=0, "
            " chlger_hero_id_2=%u, jifen_2=%u, chlg_win_2=0, "
            " chlger_hero_id_3=%u, jifen_3=%u, chlg_win_3=0, "
            " chlger_hero_id_4=%u, jifen_4=%u, chlg_win_4=0, "
            " chlger_hero_id_5=%u, jifen_5=%u, chlg_win_5=0, "
            " chlger_hero_id_6=%u, jifen_6=%u, chlg_win_6=0 "
            " where hero_id=%u"
            , (unsigned int)time(0), refresh_times +1
            , hero_vec[0].hero_info.hero_id, hero_vec[0].jifen
            , hero_vec[1].hero_info.hero_id, hero_vec[1].jifen
            , hero_vec[2].hero_info.hero_id, hero_vec[2].jifen
            , hero_vec[3].hero_info.hero_id, hero_vec[3].jifen
            , hero_vec[4].hero_info.hero_id, hero_vec[4].jifen
            , hero_vec[5].hero_info.hero_id, hero_vec[5].jifen
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        
    }

    //再扣钱
    if(item.type == ItemsType_Gold) {
        gold_balance -= item.count;
        
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , gold_balance, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else if(item.type == ItemsType_Silver) {
        silver_balance -= item.count;
        
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_balance, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //返回刷新后 下一次所需货币
    CS::refreshArenaChlgListNeedItem(refresh_times +2, item);

    return true;
}

bool ProcServerThread::checkArenaChallengeValideAndGetJifen(
    unsigned int hero_id,unsigned int chlger_id,unsigned int & jifen)
{
    //
    std::vector<ArenaChlgerHeroInfo> hero_vec;
    bool has_record = false;
    {
        char sql[1024];
        sprintf(sql, "select  "
            " chlger_hero_id_1, jifen_1, chlg_win_1, "
            " chlger_hero_id_2, jifen_2, chlg_win_2, "
            " chlger_hero_id_3, jifen_3, chlg_win_3, "
            " chlger_hero_id_4, jifen_4, chlg_win_4, "
            " chlger_hero_id_5, jifen_5, chlg_win_5, "
            " chlger_hero_id_6, jifen_6, chlg_win_6 "
            " from hellgate.arena_hero_chlg_list"
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                has_record = true;

                for(int i=1;i<=6; ++i)
                {
                    char hero_id_str[32];
                    char jifen_str[32];
                    char chlg_win_str[32];
                    sprintf(hero_id_str, "chlger_hero_id_%u", i);
                    sprintf(jifen_str, "jifen_%u", i);
                    sprintf(chlg_win_str, "chlg_win_%u", i);

                    ArenaChlgerHeroInfo info;
                    info.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField(hero_id_str));
                    info.jifen = atoi(Mysql_Thread_Conn->GetField(jifen_str));
                    info.has_win = (bool)atoi(Mysql_Thread_Conn->GetField(chlg_win_str));

                    hero_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //检查
    for(int i=0; i<hero_vec.size(); ++i)
    {
        if(hero_vec[i].hero_info.hero_id == chlger_id)
        {
            if(!hero_vec[i].has_win)
            {
                jifen = hero_vec[i].jifen;

                return true;
            }
        }
    }

    return false;
}


bool ProcServerThread::checkAndRefreshZahuopu(unsigned int hero_id
    , std::vector < ZahuopuItem > & item_vec,unsigned int & silver_balance
    ,unsigned int & silver_need_for_manual_refresh, unsigned int &draw_need_coupons)
{
    item_vec.clear();
    silver_balance = 0;
    silver_need_for_manual_refresh= 0;
    draw_need_coupons = 0;

    //查询余额
    silver_balance = getItemCountInTeam(hero_id, ItemsType_Silver);

    
    
    //首先查本次刷新需要多少钱
    unsigned int need_silver = 0;
    {
        //
        char sql[1024];
        sprintf(sql, "select next_manual_refresh_need_silver "
            " from hellgate.zahuopu "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                need_silver = atoi(Mysql_Thread_Conn->GetField("next_manual_refresh_need_silver"));
            }
            else
            {
                LogMsg("%s, line %d, in checkAndRefreshZahuopu nut has not chlg_list record. hero_id[%u]"
                        , __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(silver_balance < need_silver)
    {
        LogMsg("%s, line %d, hero_id[%u] silver balance not enough"
                        , __FILE__, __LINE__, hero_id);
        return false;
    }

    //刷新
    //stub 暂时固定1000银币
    silver_need_for_manual_refresh = 1000;
    draw_need_coupons = 5;
    {
        std::vector<unsigned int> order_vec;
        getRandom6ZahuopuItem(item_vec, order_vec);

        //
        char sql[1024];
        sprintf(sql, "update hellgate.zahuopu "
            " set refresh_timestamp=%u, next_manual_refresh_need_silver=%u, "
            " draw_need_coupons=%u, already_get_item_count=0, "
            " item_type_1=%u, suipian_id_1=%u, count_1=%u, get_order_1=%u, "
            " item_type_2=%u, suipian_id_2=%u, count_2=%u, get_order_2=%u, "
            " item_type_3=%u, suipian_id_3=%u, count_3=%u, get_order_3=%u, "
            " item_type_4=%u, suipian_id_4=%u, count_4=%u, get_order_4=%u, "
            " item_type_5=%u, suipian_id_5=%u, count_5=%u, get_order_5=%u, "
            " item_type_6=%u, suipian_id_6=%u, count_6=%u, get_order_6=%u"
            " where hero_id=%u"
            , (unsigned int)time(0), silver_need_for_manual_refresh, draw_need_coupons
            , item_vec[0].item_type, item_vec[0].suipian_id, item_vec[0].count, order_vec[0]
            , item_vec[1].item_type, item_vec[1].suipian_id, item_vec[1].count, order_vec[1]
            , item_vec[2].item_type, item_vec[2].suipian_id, item_vec[2].count, order_vec[2]
            , item_vec[3].item_type, item_vec[3].suipian_id, item_vec[3].count, order_vec[3]
            , item_vec[4].item_type, item_vec[4].suipian_id, item_vec[4].count, order_vec[4]
            , item_vec[5].item_type, item_vec[5].suipian_id, item_vec[5].count, order_vec[5]
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再扣钱
    silver_balance -= need_silver;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , silver_balance, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

void ProcServerThread::getRandom6ZahuopuItem( vector < ZahuopuItem > & item_vec,std :: vector < unsigned int > & order_vec)
{
    item_vec.clear();
    order_vec.clear();

    
    //先查询出杂货铺所有可能的物品
    std::list<ZahuopuItem> item_list;
    std::list<unsigned int> weight_list;
    unsigned int weight_total = 0;
    //
    {
        char sql[1024];
        sprintf(sql, "select item_type, suipian_id, item_count, weight "
            " from hellgate.zahuopu_item_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ZahuopuItem item;
                item.item_type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.suipian_id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                item.already_got = false;
                
                item_list.push_back(item);

                unsigned int weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                weight_list.push_back(weight);

                weight_total += weight;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(item_list.size() < 6)
    {
        LogMsg("%s, line %d, zahuopo_item_list not enought"
                        , __FILE__, __LINE__);
        assert(false);
        return;
    }

    //固定取出6个item
    for(int i=0; i<6; ++i)
    {
        int rand_weight = Utl::auto_random()%weight_total;

        std::list<ZahuopuItem>::iterator item_list_pos = item_list.begin();
        std::list<unsigned int>::iterator weight_list_pos = weight_list.begin();
        for(; item_list_pos!=item_list.end(); ++item_list_pos, ++weight_list_pos)
        {
            rand_weight -= *weight_list_pos;
            if(rand_weight < 0)
            {
                //就他了
                item_vec.push_back(*item_list_pos);

                //
                item_list.erase(item_list_pos);
                weight_list.erase(weight_list_pos);
                weight_total -= *weight_list_pos;

                break;
            }
        }
        if(item_list_pos == item_list.end())
        {
            assert(false);
        }
    }

    //随机生成order
    std::list<unsigned int> temp_order_list;
    for(int i=0; i<6; ++i)
    {
        temp_order_list.push_back(i+1);
    }
    for(int i=0; i<6; ++i)
    {
        unsigned int r = Utl::auto_random()%temp_order_list.size();
        std::list<unsigned int>::iterator pos = temp_order_list.begin();
        for(int x=0; x<r; ++x)
        {
            pos++;
        }

        order_vec.push_back(*pos);

        temp_order_list.erase(pos);
    }

    return;
}

bool ProcServerThread::checkAndZahuopuGetOneItem(unsigned int hero_id
    , ZahuopuItem & item_zahuopu,unsigned int & item_list_index,unsigned int & gold_balance
    , unsigned int& coupons_balance)
{
    gold_balance = 0;
    coupons_balance = 0;
    item_list_index = 0;

    //查询金币余额
    gold_balance = getItemCountInTeam(hero_id, ItemsType_Gold);
    //查询代购券剩余数量
    coupons_balance = getItemCountInTeam(hero_id, ItemsType_DaiGouJuan);

    unsigned int coupons_need = 5;
    unsigned int gold_need = 0;
    if(coupons_balance < coupons_need) {
        gold_need = CS::zahuopuGetOneItemNeedGold(coupons_balance);
        if(gold_balance < gold_need)
        {
            LogMsg("%s, line %d, hero_id[%u] balance not enough"
                            , __FILE__, __LINE__, hero_id);
            return false;
        }
    }


    unsigned int already_get_item_count = 0;
    //找到物品
    {
        char sql[1024];
        sprintf(sql, "select  "
            " already_get_item_count, "
            " item_type_1, suipian_id_1, count_1,  get_order_1, "
            " item_type_2, suipian_id_2, count_2,  get_order_2, "
            " item_type_3, suipian_id_3, count_3,  get_order_3, "
            " item_type_4, suipian_id_4, count_4,  get_order_4, "
            " item_type_5, suipian_id_5, count_5,  get_order_5, "
            " item_type_6, suipian_id_6, count_6,  get_order_6 "
            " from hellgate.zahuopu"
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {

                already_get_item_count = atoi(Mysql_Thread_Conn->GetField("already_get_item_count"));
                if(already_get_item_count >= 6)
                {
                    LogMsg("%s, line %d, already_get_item_count=[%u]. hero_id[%u]"
                        , __FILE__, __LINE__, already_get_item_count, hero_id);
                    return false;
                }

                item_list_index = 0;
                for(;item_list_index<6; ++item_list_index)
                {
                    char item_type_str[32];
                    char suipian_id_str[32];
                    char count_str[32];
                    char order_str[32];
                    sprintf(item_type_str, "item_type_%u", item_list_index+1);
                    sprintf(suipian_id_str, "suipian_id_%u", item_list_index+1);
                    sprintf(count_str, "count_%u", item_list_index+1);
                    sprintf(order_str, "get_order_%u", item_list_index+1);

                    item_zahuopu.item_type = atoi(Mysql_Thread_Conn->GetField(item_type_str));
                    item_zahuopu.suipian_id = atoi(Mysql_Thread_Conn->GetField(suipian_id_str));
                    item_zahuopu.count = atoi(Mysql_Thread_Conn->GetField(count_str));
                    item_zahuopu.already_got = true;
                    unsigned int order = atoi(Mysql_Thread_Conn->GetField(order_str));
                    if(order == already_get_item_count+1)
                    {
                        //就是他了
                        break;
                    }
                }
                if(item_list_index == 6)
                {
                    LogMsg("%s, line %d, order can not found already_get_item_count=[%u]"
                        , __FILE__, __LINE__, already_get_item_count);
                    assert(false);
                    return false;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //添加物品
    if(item_zahuopu.suipian_id == 0)
    {
        ObtainItem(hero_id,item_zahuopu.item_type,item_zahuopu.count);
        
        if(item_zahuopu.item_type == ItemsType_Shenbing_Jianding) {
            //杂货铺抽取到凯恩之书插入到跑马灯队列中
            insert_marquee_message(MarqueeType_VarietyStore, hero_id, 
                item_zahuopu.item_type, item_zahuopu.count);
        }
    }
    else
    {
        ObtainItemSuipian(hero_id,item_zahuopu.item_type, item_zahuopu.suipian_id,item_zahuopu.count);
    }

    //修改状态
    already_get_item_count++;
    {
        char sql[1024];
        sprintf(sql, "update  hellgate.zahuopu "
            " set already_get_item_count=%u "
            " where hero_id=%u"
            , already_get_item_count
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //先扣代购券
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , (coupons_balance<coupons_need) ? coupons_balance : coupons_need
            , hero_id, ItemsType_DaiGouJuan);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(coupons_balance < coupons_need){//再扣钱
        gold_balance -= gold_need;
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , gold_need, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询金币余额
    gold_balance = getItemCountInTeam(hero_id, ItemsType_Gold);
    //查询代购券剩余数量
    coupons_balance = getItemCountInTeam(hero_id, ItemsType_DaiGouJuan);
    
    //触发日常任务
    send_system_bonus_notify(hero_id, BonusType_DayWelfare, BonusID_VarietyStore);

    return true;
}


bool ProcServerThread::canHeroEnterTaskGrid(
    unsigned int hero_id, unsigned int task_id, unsigned int grid, bool battle)
{
    if(task_id < MainTaskId_max)
    {
        //首先获取主任务进度
        unsigned int maintask_last_actived  = 1;
        unsigned int maintask_status = TaskStatus_NotGot;
        {
            //
            char sql[1024];

            sprintf(sql, "select maintask_last_actived, status "
                " from hellgate.hero_maintask_progress "
                " where hero_id=%u"
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                    maintask_status = atoi(Mysql_Thread_Conn->GetField("status"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //判断任务是否可进入
        if(maintask_last_actived < task_id
            || (maintask_last_actived == task_id && 
                (maintask_status == TaskStatus_NotActived || maintask_status == TaskStatus_NotGot)))
        {
            LogMsg("%s, line %d, what is the hell"
                            , __FILE__, __LINE__);
            return false;
        }

        if(battle) { //战斗 查看是否为关卡id
            char sql[1024], field[32];
            sprintf(field, "grid_id_%u", grid);
            sprintf(sql, "select %s "
                " from hellgate.task_chessboard "
                " where hero_id=%u and task_id=%u"
                , field, hero_id, task_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    int tmp_grid_id = atoi(Mysql_Thread_Conn->GetField(field));
                    if(tmp_grid_id <= 0)
                        return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        /*
        //首先获取棋盘的布局
        unsigned int grid_count_heng = 0;
        unsigned int grid_count_shu = 0;
        CS::getTaskChessboardFormat(task_id,grid_count_heng,grid_count_shu);

        //再判断grid是否合法
        if(grid == 0) 
        {
            //0号格子是永远都可以进的
            return true;
        }
        else
        {
            if(grid > grid_count_heng*grid_count_shu-1)
            {
                LogMsg("%s, line %d, what is the hell. grid=[%u]"
                            , __FILE__, __LINE__, grid);
                return false;
            }
            
            //获取task棋盘信息
            bool chess_board[9] 
                = {false, false, false, false, false, false, false, false, false};
            {
                //
                char sql[1024];

                sprintf(sql, "select grid_1_stat, grid_2_stat, grid_3_stat, grid_4_stat, "
                    " grid_5_stat, grid_6_stat, grid_7_stat, grid_8_stat, grid_9_stat "
                    " from hellgate.task_chessboard "
                    " where hero_id=%u and task_id=%u"
                    , hero_id, task_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        chess_board[0] = atoi(Mysql_Thread_Conn->GetField("grid_1_stat"));
                        chess_board[1] = atoi(Mysql_Thread_Conn->GetField("grid_2_stat"));
                        chess_board[2] = atoi(Mysql_Thread_Conn->GetField("grid_3_stat"));
                        chess_board[3] = atoi(Mysql_Thread_Conn->GetField("grid_4_stat"));
                        chess_board[4] = atoi(Mysql_Thread_Conn->GetField("grid_5_stat"));
                        chess_board[5] = atoi(Mysql_Thread_Conn->GetField("grid_6_stat"));
                        chess_board[6] = atoi(Mysql_Thread_Conn->GetField("grid_7_stat"));
                        chess_board[7] = atoi(Mysql_Thread_Conn->GetField("grid_8_stat"));
                        chess_board[8] = atoi(Mysql_Thread_Conn->GetField("grid_9_stat"));
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            //记录哪些格子是能走的
            bool grid_valide[9]
                = {false, false, false, false, false, false, false, false, false};;
            {
                for(int i=0; i<9; ++i)
                {
                    if(chess_board[i])
                    {
                        //已经探索过的格子是能走的
                        grid_valide[i] = true;
                        
                        //一个已经探索过的格子的上下左右都是可以走的
                        //上 
                        if(i+grid_count_heng < grid_count_heng*grid_count_shu)
                        {
                            grid_valide[i+grid_count_heng] = true;
                        }
                        //下
                        if(i-(int)grid_count_heng >= 0)
                        {
                            grid_valide[i-grid_count_heng] = true;
                        }
                        //左
                        if(i%grid_count_heng>0 && i!=0)
                        {
                            grid_valide[i-1] = true;
                        }
                        //右
                        if((i+1)%grid_count_heng != 0)
                        {
                            grid_valide[i+1] = true;
                        }
                    }
                }
            }

            if(grid_valide[grid])
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        */
        
        return true;
    }
    
    return false;
}

bool ProcServerThread::canHeroSaodangTask(unsigned int hero_id,unsigned int task_id)
{
    if(task_id > MainTaskId_max)
    {
        return false;
    }

    //首先获取主任务进度
    unsigned int maintask_last_actived  = 1;
    unsigned int maintask_status = TaskStatus_NotGot;
    {
        //
        char sql[1024];

        sprintf(sql, "select maintask_last_actived, status "
            " from hellgate.hero_maintask_progress "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                maintask_status = atoi(Mysql_Thread_Conn->GetField("status"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //判断任务是否已经通关了
    if(maintask_last_actived > task_id
        || (maintask_last_actived == task_id && 
            (maintask_status == TaskStatus_Finished || maintask_status == TaskStatus_Submitted)))
    {
        return true;
    }

    

    return false;
}

void ProcServerThread::updateHeroVitality(unsigned int hero_id)
{

    //先查询上次update时间和当前体力
    unsigned int vit_current = 0;
    time_t vit_last_modify_time = time(0);
    {
        char sql[1024];
        //
        sprintf(sql, "select vit_current, vit_last_modify_time "
            " from hellgate.hero_infor where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                vit_current = atoi(Mysql_Thread_Conn->GetField("vit_current"));
                vit_last_modify_time = atoi(Mysql_Thread_Conn->GetField("vit_last_modify_time"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(vit_current >= Vitality_Total)
    {
        return;
    }

    int time_gap = time(0) - vit_last_modify_time;
    if(time_gap < VitalityUpdateTimeGap)
    {
        return;
    }

    vit_current += time_gap/VitalityUpdateTimeGap;
    
    if(vit_current > Vitality_Total)
        vit_current = Vitality_Total;

    //update
    {
        char sql[1024];
        //
        sprintf(sql, "update hellgate.hero_infor set vit_current=%u, vit_last_modify_time=%u "
            " where hero_id=%u"
            , vit_current, (unsigned int)time(0), hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

void ProcServerThread::InitHero(Profession hero_prof, unsigned int hero_id)
{
    char sql[1024];
    //
    sprintf(sql, "insert into hellgate.hero_maintask_progress "
        " set hero_id=%u, maintask_last_actived=1, status=1"
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    //
    sprintf(sql, "insert into hellgate.hero_progress_subtask_daily_zhuangbei "
        " set hero_id=%u, status=0"
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    //
    sprintf(sql, "insert into hellgate.hero_progress_subtask_daily_baoshi "
        " set hero_id=%u, status=0"
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    
    /* 2014.07.15 注释掉初始金币和银币
    //gold 
    sprintf(sql, "insert into hellgate.items_in_team "
        " set hero_id=%u, item_type=%u, item_count=%u"
        , hero_id, ItemsType_Gold, Hero_init_gold);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    //silver 
    sprintf(sql, "insert into hellgate.items_in_team "
        " set hero_id=%u, item_type=%u, item_count=%u"
        , hero_id, ItemsType_Silver, Hero_init_silver);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    */

    //初始装备
    if(hero_prof == Profession_Yemanren)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Jian;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Jian, hero_id,detail);
        zb_id = ObtainZhuangbei(hero_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

        name_id = ZhuangBeiInitNameId_DunPai;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_DunPai, hero_id,detail);
        zb_id = ObtainZhuangbei(hero_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

    }
    else if(hero_prof == Profession_Chike)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Jian;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Jian, hero_id,detail);
        zb_id = ObtainZhuangbei(hero_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

        name_id = ZhuangBeiInitNameId_DunPai;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_DunPai, hero_id,detail);
        zb_id = ObtainZhuangbei(hero_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

    }
    else if(hero_prof == Profession_Fashi)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_FazhangShangshou;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_FazhangShangshou, hero_id,detail);
        zb_id = ObtainZhuangbei(hero_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

    }
    else
    {
        LogMsg("%s, line %d, profession[%d] not supported"
                    , __FILE__, __LINE__, (int)hero_prof);
        assert(false);
    }

    //初始技能
    unsigned int init_skill = 0;
    if(hero_prof == Profession_Yemanren)
    {
        init_skill = SkillType_BaoLieZhan;
    }
    else if(hero_prof == Profession_Chike)
    {
        init_skill = SkillType_ShaLu;
    }
    else if(hero_prof == Profession_Fashi)
    {
        init_skill = SkillType_ShanDian;
    }
    else
    {
        LogMsg("%s, line %d, profession[%d] not supported"
                    , __FILE__, __LINE__, (int)hero_prof);
        assert(false);
    }
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.skill_in_team set "
            " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=1"
            , hero_id, hero_id, (unsigned int)1, init_skill);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    

    //英雄榜 
    {
        unsigned int max_hero_order = 0;
        char sql[1024];
        //
        sprintf(sql, "select max(hero_order) max_order from hellgate.top_hero_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                char* v = Mysql_Thread_Conn->GetField("max_order");
                if(v == NULL)
                {
                    max_hero_order = 0;
                }
                else
                {
                    max_hero_order = atoi(v);
                }
                
            }
            else
            {
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        max_hero_order++;
        
        //
        sprintf(sql, "insert into hellgate.top_hero_list "
            " set hero_id=%u, hero_order=%u"
            , hero_id, max_hero_order);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //助手
    if(hero_prof == Profession_Yemanren)
    {
        unsigned int assit_id = 0;
        
        assit_id = createAssitant(hero_id,Profession_MiShu);
        {
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor set position=%u "
                        "where hero_id=%u"
                        , 3, assit_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        

    }
    else if(hero_prof == Profession_Chike)
    {
        unsigned int assit_id = 0;
        
        assit_id = createAssitant(hero_id,Profession_LieShou);
        {
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor set position=%u "
                        "where hero_id=%u"
                        , 3, assit_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

    }
    else if(hero_prof == Profession_Fashi)
    {
        unsigned int assit_id = 0;
        
        assit_id = createAssitant(hero_id,Profession_YouXia);
        {
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor set position=%u "
                        "where hero_id=%u"
                        , 1, assit_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        

    }
    else
    {
        LogMsg("%s, line %d, profession[%d] not supported"
                    , __FILE__, __LINE__, (int)hero_prof);
        assert(false);
    }
}

void ProcServerThread::InitAssistant(unsigned int parent_id, Profession hero_prof,unsigned int hero_id,
    bool is_unlocked/*=true*/)
{
    if(is_unlocked) { //初始化助手装备
        init_assistant_arms(parent_id, hero_prof, hero_id);
    }

    //初始技能
    unsigned int init_skill = 0;
    if(hero_prof == Profession_Qishi)
    {
        init_skill = SkillType_JianShou;
    }
    else if(hero_prof == Profession_WuSeng)
    {
        init_skill = SkillType_ShenZhiXingNian;
    }
    else if(hero_prof == Profession_YouXia)
    {
        init_skill = SkillType_LiRenHuiXuan;
    }
    else if(hero_prof == Profession_ShenJianShou)
    {
        init_skill = SkillType_LieGong;
    }
    else if(hero_prof == Profession_LieShou)
    {
        init_skill = SkillType_JianYu;
    }
    else if(hero_prof == Profession_MiShu)
    {
        init_skill = SkillType_HuoQiuShu;
    }
    else if(hero_prof == Profession_WuShi)
    {
        init_skill = SkillType_WenYi;
    }
    else
    {
        LogMsg("%s, line %d, profession[%d] not supported"
                    , __FILE__, __LINE__, (int)hero_prof);
    }
    //生成skill_id
    unsigned skill_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select max(skill_id) max_skill_id "
            " from hellgate.skill_in_team where main_hero_id=%u"
            , parent_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                skill_id = atoi(Mysql_Thread_Conn->GetField("max_skill_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    skill_id++;
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.skill_in_team set "
            " main_hero_id=%u, own_hero_id=%u, skill_id=%u, skill_type=%u, is_equiped=1"
            , parent_id, hero_id, skill_id, init_skill);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
}


void ProcServerThread::init_assistant_arms(unsigned int parent_id, Profession hero_prof, unsigned int hero_id)
{
    //初始装备
    if(hero_prof == Profession_Qishi)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Jian;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Jian, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
        
        name_id = ZhuangBeiInitNameId_DunPai;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_DunPai, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

    }
    else if(hero_prof == Profession_WuSeng)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Jian;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Jian, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
        
        name_id = ZhuangBeiInitNameId_DunPai;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_DunPai, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

    }
    else if(hero_prof == Profession_YouXia)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Jian;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Jian, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
        
        name_id = ZhuangBeiInitNameId_DunPai;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_DunPai, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);

    }
    else if(hero_prof == Profession_ShenJianShou)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Gong;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Gong, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
    }
    else if(hero_prof == Profession_LieShou)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_Gong;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_Gong, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
    }
    else if(hero_prof == Profession_MiShu)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_FazhangShangshou;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_FazhangShangshou, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
    }
    else if(hero_prof == Profession_WuShi)
    {
        __ZhuangbeiDetail detail;

        unsigned int name_id;
        unsigned long long zb_id;

        name_id = ZhuangBeiInitNameId_FazhangShangshou;
        createZhuangbei(name_id, ZhuangBeiInitGroupId_FazhangShangshou, parent_id,detail);
        zb_id = ObtainZhuangbei(parent_id,name_id,detail);
        __equipZhuangbeiToHero(zb_id, hero_id);
    }
    else
    {
        LogMsg("%s, line %d, profession[%d] not supported"
                    , __FILE__, __LINE__, (int)hero_prof);
    }

}


void ProcServerThread::__equipZhuangbeiToHero(unsigned long long zhuangbei_id,unsigned int hero_id)
{
    char sql[1024];
    sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=%u "
                "where zhuangbei_id=%llu"
                , hero_id, zhuangbei_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    //换装结束 更新战斗力
    calculate_fight_capacity(hero_id);
}

unsigned int ProcServerThread::createAssitant(unsigned int main_hero_id,unsigned int profession, 
    	bool is_unlocked, bool is_unlock_able)
{
    //需要生成hero ID
    unsigned int assit_hero_id;
    char sql[1024];
    sprintf(sql, "select max(hero_id) max_hero_id "
        " from hellgate.hero_infor");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            assit_hero_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    assit_hero_id++;

    //
    sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, "
        " is_unlocked=%u, is_unlock_able=%u, "
        " parent_hero_id=%u, profession_id=%u, "
        " level=1, hero_name='', exp_current=0"
        , assit_hero_id
        , is_unlocked, is_unlock_able
        , main_hero_id, profession);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    //初始化
    InitAssistant(main_hero_id, (Profession)profession, assit_hero_id, is_unlocked);

    return assit_hero_id;
}


unsigned int ProcServerThread::make_assitant_unlock_able(unsigned int main_hero_id, unsigned int profession)
{
    char sql[1024];
    sprintf(sql, "update hellgate.hero_infor set is_unlock_able=1 "
        " where parent_hero_id=%u and profession_id=%u and is_unlock_able=0 "
        , main_hero_id, profession);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
   

    return 0;
}


unsigned int ProcServerThread::createYuanshen(unsigned int hero_id)
{
    //首先检查是否已经有元神了
    unsigned int yuanshen_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select hero_id "
            " from hellgate.hero_infor where is_yuanshen=1 and zhenshen_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                yuanshen_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(yuanshen_id > 0)
    {
        return yuanshen_id;
    }
    
    HeroDetail hero_detail;
    GetHeroDetail(hero_id, hero_detail);
    unsigned int main_hero_id = hero_detail.parent_hero_id;
    if(hero_detail.parent_hero_id == 0)
    {
        main_hero_id = hero_id;
    }
    
    //需要生成hero ID
    char sql[1024];
    sprintf(sql, "select max(hero_id) max_hero_id "
        " from hellgate.hero_infor");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            yuanshen_id = atoi(Mysql_Thread_Conn->GetField("max_hero_id"));
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    yuanshen_id++;

    //
    sprintf(sql, "insert into hellgate.hero_infor set hero_id=%u, is_unlocked=1, is_unlock_able=1 "
        ", is_yuanshen=1, zhenshen_id=%u "
        ", parent_hero_id=%u, profession_id=%u "
        ", level=1, hero_name='', exp_current=0"
        , yuanshen_id, hero_id, main_hero_id, hero_detail.basic_info.profession_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    return yuanshen_id;
}


void ProcServerThread::GetHeroList(unsigned int client_id, vector < HeroInfo > & heroVec)
{
    //需要生成客户端ID
    char sql[1024];
    sprintf(sql, "select hero_list.hero_id, vip_level, profession_id, level, stage,  "
        " hero_name from hellgate.hero_list, hellgate.hero_infor "
        "where hero_list.client_id=%u and hero_list.hero_id=hero_infor.hero_id"
        , client_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        while(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            HeroInfo info;
            
            info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
            info.is_yuanshen = false;
            info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
            info.profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
            info.level = atoi(Mysql_Thread_Conn->GetField("level"));
            info.stage = atoi(Mysql_Thread_Conn->GetField("stage"));
            strncpy(info.name, Mysql_Thread_Conn->GetField("hero_name"), HeroNameMaxLen);
            info.name[HeroNameMaxLen] = 0;

            heroVec.insert(heroVec.end(), info);
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    unsigned int hero_id;
    sprintf(sql, "select vip_level, hero_id "
        " from hellgate.hero_vip_info order by hero_id");
    try
    {
        Mysql_Thread_Conn->Query(sql);
        while(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
            for(int i=0; i<heroVec.size(); i++){
                if(hero_id == heroVec[i].hero_id){
                    heroVec[i].vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                }
            }
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
}

bool ProcServerThread::GetHeroBasicInfo(unsigned int hero_id,HeroInfo & hero_info)
{
    hero_info.hero_id = hero_id;

    //先按主角
    unsigned int parent_hero_id = 0;
    char sql[1024];
    sprintf(sql, "select is_yuanshen, zhenshen_id "
        " , parent_hero_id, profession_id, level, stage, hero_name"
        " from hellgate.hero_infor where hero_id=%u"
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            parent_hero_id = atoi(Mysql_Thread_Conn->GetField("parent_hero_id"));

            hero_info.is_yuanshen = atoi(Mysql_Thread_Conn->GetField("is_yuanshen"));
            hero_info.zhenshen_id = atoi(Mysql_Thread_Conn->GetField("zhenshen_id"));
            
            hero_info.profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
            hero_info.level = atoi(Mysql_Thread_Conn->GetField("level"));
            hero_info.stage = atoi(Mysql_Thread_Conn->GetField("stage"));
            strncpy(hero_info.name, Mysql_Thread_Conn->GetField("hero_name"), HeroNameMaxLen);
            hero_info.name[HeroNameMaxLen] = 0;
            //hero_info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
        }
        else
        {
            return false;
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    //判断是否是主角
    if(parent_hero_id > 0)
    {
        //是助手，则vip_level从主角取
        char sql[1024];
        sprintf(sql, "select vip_level "
            " from hellgate.hero_vip_info where hero_id=%u"
            , parent_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                
                hero_info.name[0] = 0;
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u], parent_hero_id[%u]."
                        , __FILE__, __LINE__, hero_id, parent_hero_id);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else {
        char sql[1024];
        sprintf(sql, "select vip_level "
            " from hellgate.hero_vip_info where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u], parent_hero_id[%u]."
                        , __FILE__, __LINE__, hero_id, parent_hero_id);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    return true;
}

void ProcServerThread::GetHeroDetail(unsigned int hero_id,HeroDetail& hero_detail)
{
    //assert(hero_id!=0);
    
    hero_detail.basic_info.hero_id = hero_id;
    if(hero_id == 0)
    {
        return;
    }

    //先按照主角查询
    {
        char sql[1024];
        sprintf(sql, "select is_unlocked, is_unlock_able, is_yuanshen, zhenshen_id "
            ", parent_hero_id, profession_id, level, stage, hero_name "
            ", vit_current, exp_current, position"
            " from hellgate.hero_infor where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_detail.basic_info.is_yuanshen = atoi(Mysql_Thread_Conn->GetField("is_yuanshen"));
                hero_detail.basic_info.zhenshen_id = atoi(Mysql_Thread_Conn->GetField("zhenshen_id"));
            
                hero_detail.basic_info.profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                hero_detail.basic_info.level = atoi(Mysql_Thread_Conn->GetField("level"));
                hero_detail.basic_info.stage = atoi(Mysql_Thread_Conn->GetField("stage"));
                
                strncpy(hero_detail.basic_info.name, Mysql_Thread_Conn->GetField("hero_name"), HeroNameMaxLen);
                hero_detail.basic_info.name[HeroNameMaxLen] = 0;
                //hero_detail.basic_info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                
                hero_detail.parent_hero_id = atoi(Mysql_Thread_Conn->GetField("parent_hero_id"));
                hero_detail.postion = atoi(Mysql_Thread_Conn->GetField("position"));

                hero_detail.is_unlocked = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlocked"));
                hero_detail.unlockAble = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlock_able"));

                hero_detail.exp_current = atoi(Mysql_Thread_Conn->GetField("exp_current"));
                hero_detail.vit_current = atoi(Mysql_Thread_Conn->GetField("vit_current"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    //判断是否是主角
    if(hero_detail.parent_hero_id > 0)
    {
        //是助手，则vip_level从主角取
        char sql[1024];
        sprintf(sql, "select vit_current "
            " from hellgate.hero_infor where hero_id=%u"
            , hero_detail.parent_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_detail.vit_current = atoi(Mysql_Thread_Conn->GetField("vit_current"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u], parent_hero_id[%u]."
                        , __FILE__, __LINE__, hero_id, hero_detail.parent_hero_id);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
        sprintf(sql, "select vip_level "
            " from hellgate.hero_vip_info where hero_id=%u"
            , hero_detail.parent_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_detail.basic_info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u], parent_hero_id[%u]."
                        , __FILE__, __LINE__, hero_id, hero_detail.parent_hero_id);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else {
        char sql[1024];
        sprintf(sql, "select vip_level "
            " from hellgate.hero_vip_info where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_detail.basic_info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u]."
                        , __FILE__, __LINE__, hero_id);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

    }

    //如果是元神则为0
    if(hero_detail.basic_info.is_yuanshen)
    {
        memset(&hero_detail.hero_attr_without_zhuangbei, 0, sizeof(HeroAttrWithoutZhuangbei));
    }
    else
    {
        getProfessionLevelAttr((Profession)hero_detail.basic_info.profession_id
            , hero_detail.basic_info.level
            , hero_detail.hero_attr_without_zhuangbei.liliang
            , hero_detail.hero_attr_without_zhuangbei.mingjie
            , hero_detail.hero_attr_without_zhuangbei.zhili
            , hero_detail.hero_attr_without_zhuangbei.tineng
            , hero_detail.hero_attr_without_zhuangbei.xueliang
            , hero_detail.hero_attr_without_zhuangbei.baoji
            , hero_detail.hero_attr_without_zhuangbei.baoshang
            ,hero_detail.hero_attr_without_zhuangbei.jinengchufa);
    }
    

    //exp_need应该是填写下一等级的
    if(hero_detail.basic_info.is_yuanshen)
    {
        hero_detail.exp_need = get_levelup_need_exp(HeroType_Soul, hero_detail.basic_info.level+1);
    }
    else
    {
        hero_detail.exp_need = get_levelup_need_exp(HeroType_Hero, hero_detail.basic_info.level+1);
    }
    
    
}


void ProcServerThread::GetMonsterDetail(unsigned int monster_id, GuaiWuData& monster_detail
    , unsigned int& skill_type, int level)
{
    assert(monster_id!=0);

    //
    int gongji_add, hp_add, baoji_lv_add, baojishanghai_add, jineng_chufa_lv_add, hujia_jianmian_add, kangxing_jianmian_add;
    {
        char sql[1024];
        sprintf(sql, "select guaiwu_zhiye, guaiwu_level, is_jingying, "
            " hp_add, gongji_add, jineng_chufa_lv_add, baojishanghai_add, baoji_lv_add, "
            " hujia_jianmian_add, kangxing_jianmian_add "
            " from hellgate.guaiwu_list_new "
            " where  "
            "  guaiwu_id=%u"
            , monster_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                monster_detail.profession = (Profession)atoi(Mysql_Thread_Conn->GetField("guaiwu_zhiye"));
                monster_detail.level = atoi(Mysql_Thread_Conn->GetField("guaiwu_level"));
                monster_detail.type 
                    = atoi(Mysql_Thread_Conn->GetField("is_jingying"))==true ? Type_Guaiwu_jingying : Type_Guaiwu_putong;
                gongji_add = atoi(Mysql_Thread_Conn->GetField("gongji_add"));
                hp_add = atoi(Mysql_Thread_Conn->GetField("hp_add"));
                baoji_lv_add = atoi(Mysql_Thread_Conn->GetField("baoji_lv_add"));
                baojishanghai_add = atoi(Mysql_Thread_Conn->GetField("baojishanghai_add"));
                jineng_chufa_lv_add = atoi(Mysql_Thread_Conn->GetField("jineng_chufa_lv_add"));
                hujia_jianmian_add = atoi(Mysql_Thread_Conn->GetField("hujia_jianmian_add"));
                kangxing_jianmian_add = atoi(Mysql_Thread_Conn->GetField("kangxing_jianmian_add"));
                

            }
            else
            {
                LogMsg("%s, line %d, monster_id[%u] not exist", __FILE__, __LINE__, monster_id);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(level > 0 )
        monster_detail.level = level;
//
    unsigned int profession_type_id = 0;
    {
    
        char sql[1024];
        sprintf(sql, "select hellgate.guaiwu_profession_type_list.profession_type_id type_id, "
            " profession_name, pic, "
            " gongji, gongji_add_per_level, gongji_multi_per_level, "
            " xueliang, xueliang_add_per_level, xueliang_multi_per_level, "
            " baoji, baoshang, jinengchufa, hujia_jianmian, kangxing_jianmian, size_x, "
            " skill_type "
            " from hellgate.guaiwu_profession_list, hellgate.guaiwu_profession_type_list "
            "where hellgate.guaiwu_profession_list.profession_type_id=hellgate.guaiwu_profession_type_list.profession_type_id "
            " and profession_id=%u"
            , monster_detail.profession);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                profession_type_id = atoi(Mysql_Thread_Conn->GetField("type_id"));
                monster_detail.gongJiLi = atoi(Mysql_Thread_Conn->GetField("gongji"));
                monster_detail.xueLiang = atoi(Mysql_Thread_Conn->GetField("xueliang"));
                monster_detail.baoJiLv = atoi(Mysql_Thread_Conn->GetField("baoji"));
                monster_detail.baoShangYinZi = atoi(Mysql_Thread_Conn->GetField("baoshang"));
                monster_detail.jiNengChuFaLv = atoi(Mysql_Thread_Conn->GetField("jinengchufa"));
                monster_detail.huJiaJianMianLv = atoi(Mysql_Thread_Conn->GetField("hujia_jianmian"));
                monster_detail.kangXingJianMianLv = atoi(Mysql_Thread_Conn->GetField("kangxing_jianmian"));
                monster_detail.x_size = atoi(Mysql_Thread_Conn->GetField("size_x"));

                //unsigned int gongji_add = atoi(Mysql_Thread_Conn->GetField("gongji_add_per_level"));
                //unsigned int xueliang_add = atoi(Mysql_Thread_Conn->GetField("xueliang_add_per_level"));
                //monster_detail.gongJiLi += gongji_add*(monster_detail.level-1);
                //monster_detail.xueLiang += xueliang_add*(monster_detail.level-1);

                float gongji_multi = 1.0 + ((float)atoi(Mysql_Thread_Conn->GetField("gongji_multi_per_level")))/100.0;
                float xueliang_multi = 1.0 + ((float)atoi(Mysql_Thread_Conn->GetField("gongji_multi_per_level")))/100.0;
                monster_detail.gongJiLi *= powf(gongji_multi, monster_detail.level-1);
                monster_detail.xueLiang *= powf(xueliang_multi, (monster_detail.level-1));

                skill_type = atoi(Mysql_Thread_Conn->GetField("skill_type"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        

        //如果是boss就必须是精英
        if(monster_detail.x_size > 1)
        {
            monster_detail.type = Type_Guaiwu_jingying;
        }
        
        //

        monster_detail.shangHaiLeiXing 
            = (profession_type_id == Type_FaShi) ? SHANG_HAI_MO_FA : SHANG_HAI_WU_LI;
        monster_detail.gongJiJuLi 
            = (profession_type_id == Type_JinZhan) ? 1 : 2;
    }

    //精英怪加成
    unsigned int jingying_gongji_add = 0;
    unsigned int jingying_xueliang_add = 0;
    {
        char sql[1024];
        sprintf(sql, "select gongji_add_percent, xueliang_add_percent "
            " from hellgate.guaiwu_jingying_shuxing limit 1"
            );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                jingying_gongji_add = atoi(Mysql_Thread_Conn->GetField("gongji_add_percent"));
                jingying_xueliang_add = atoi(Mysql_Thread_Conn->GetField("xueliang_add_percent"));
            }
            else
            {
                LogMsg("%s, line %d, guaiwu_jingying_shuxing table empty."
                        , __FILE__, __LINE__);
                assert(false);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(monster_detail.type == Type_Guaiwu_jingying)
    {
        monster_detail.xueLiang += monster_detail.xueLiang*jingying_xueliang_add/100;
        monster_detail.gongJiLi += monster_detail.gongJiLi*jingying_gongji_add/100;
    }

    //加上额外附加
    monster_detail.gongJiLi += gongji_add;
    monster_detail.xueLiang += hp_add;
    monster_detail.baoJiLv += baoji_lv_add;
    monster_detail.baoShangYinZi += baojishanghai_add;
    monster_detail.jiNengChuFaLv += jineng_chufa_lv_add;
    monster_detail.huJiaJianMianLv += hujia_jianmian_add;
    monster_detail.kangXingJianMianLv += kangxing_jianmian_add;

/*
    //怪物血量和攻击力进行+-20%的随机
    {
        float x = Utl::auto_random()%41;
        x += 80;
        x /=100;
        monster_detail.gongJiLi *= x;

        x = Utl::auto_random()%41;
        x += 80;
        x /=100;
        monster_detail.xueLiang *= x;
    }
*/
    return;
}




bool ProcServerThread::canZhuangbeiEquipToHero(unsigned long long zhuangbei_id,unsigned int hero_id)
{
    //查询出装备所属团队的主英雄
    unsigned int owner_hero_id = 0;
    unsigned int zhuangbei_level = 0;
    unsigned int zhuangbei_type = 0;
    {
        char sql[1024];
        sprintf(sql, "select owner_hero_id, zhuangbei_level, zhuangbei_type "
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_list.zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    unsigned int parent_id = 0;
    unsigned int hero_level = 1;
    unsigned int profession_id = 0;
    HeroDetail detail;
    GetHeroDetail(hero_id,detail);
    {
        parent_id = detail.parent_hero_id;
        hero_level = detail.basic_info.level;
        profession_id = detail.basic_info.profession_id;
    }
    if(parent_id == 0)
    {
        parent_id = hero_id;
    }

    //
    if(owner_hero_id != parent_id)
    {
        LogMsg("%s, line %d, zhuangbei[%llu] not belong to hero[%u]"
                        , __FILE__, __LINE__, zhuangbei_id, hero_id);
        return false;
    }

    //
    if(detail.basic_info.is_yuanshen)
    {
        if(!isYuanshenZhuangbeiTypeOpen(hero_level, zhuangbei_type))
        {
            LogMsg("%s, line %d, yuanshen[%u] zhuangbei not open for zhuangbei_type[%lu]"
                            , __FILE__, __LINE__,hero_id, zhuangbei_type);
            return false;
        }
    }
    else
    {
        if(hero_level < zhuangbei_level)
        {
            LogMsg("%s, line %d, zhuangbei_level[%u] > hero_level[%u]"
                            , __FILE__, __LINE__, zhuangbei_level, hero_level);
            return false;
        }
    }

    
    //
    bool match = false;
    switch(zhuangbei_type)
    {
        case ZhuangbeiType_DanshouJian:
            if((profession_id == Profession_Yemanren)
                || (profession_id == Profession_Chike)
                || (profession_id == Profession_Qishi)
                || (profession_id == Profession_WuSeng)
                || (profession_id == Profession_YouXia))
            {
                match = true;
            }
            break;
        case ZhuangbeiType_ShuangshouBishou:
            if(profession_id == Profession_Chike)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_ShuangshouFu:
            if(profession_id == Profession_Yemanren)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_ShuangshouFazhang:
            if(profession_id == Profession_Fashi
                || profession_id == Profession_MiShu
                || profession_id == Profession_WuShi)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_DanshouFazhang:
            if(profession_id == Profession_Fashi)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_Gong:
            if(profession_id == Profession_LieShou
                || profession_id == Profession_ShenJianShou)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_Faqi:
            if(profession_id == Profession_Fashi)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_Dunpai:
            if((profession_id == Profession_Yemanren)
                || (profession_id == Profession_Chike)
                || (profession_id == Profession_Qishi)
                || (profession_id == Profession_WuSeng)
                || (profession_id == Profession_YouXia))
            {
                match = true;
            }
            break;
        case ZhuangbeiType_Hushenfu:
            match = true;
            break;
        case ZhuangbeiType_KuijiaZhong:
            if((profession_id == Profession_Yemanren)
                || (profession_id == Profession_Chike)
                || (profession_id == Profession_Qishi)
                || (profession_id == Profession_WuSeng)
                || (profession_id == Profession_YouXia))
            {
                match = true;
            }
            break;
        case ZhuangbeiType_KuijiaQin:
            if(profession_id == Profession_Fashi
                || profession_id == Profession_MiShu
                || profession_id == Profession_WuShi
                || profession_id == Profession_LieShou
                || profession_id == Profession_ShenJianShou)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_Jiezhi:
            match = true;
            break;
        default:
            LogMsg("%s, line %d, zhuangbei_type[%u] what is the hell"
                        , __FILE__, __LINE__, zhuangbei_type);
            return false;
            break;
    }
    if(!match)
    {
        return false;
    }
    

    return true;
}

bool ProcServerThread::isYuanshenZhuangbeiTypeOpen(unsigned int yuanshen_level,unsigned int zhuangbei_type)
{
    bool wuqi_open = false;
    bool fushou_open = false;
    bool kuijia_open = false;
    bool hushenfu_open = false;
    bool jiezhi_open = false;
    CS::openZhuangbeiOfYuanshenLevel(yuanshen_level
        , wuqi_open, fushou_open, kuijia_open, hushenfu_open, jiezhi_open);

    bool match = false;
    switch(zhuangbei_type)
    {
        case ZhuangbeiType_DanshouJian:
        case ZhuangbeiType_ShuangshouBishou:
        case ZhuangbeiType_ShuangshouFu:
        case ZhuangbeiType_ShuangshouFazhang:
        case ZhuangbeiType_DanshouFazhang:
        case ZhuangbeiType_Gong:
            if(wuqi_open)
            {
                match = true;
            }
            break;
       
        case ZhuangbeiType_Faqi:
        case ZhuangbeiType_Dunpai:
        case ZhuangbeiType_Hushenfu:
            if(fushou_open)
            {
                match = true;
            }
            
            break;
        case ZhuangbeiType_KuijiaZhong:
        case ZhuangbeiType_KuijiaQin:
            if(kuijia_open)
            {
                match = true;
            }
            break;
        case ZhuangbeiType_Jiezhi:
            if(jiezhi_open)
            {
                match = true;
            }
            
            break;
        default:
            LogMsg("%s, line %d, zhuangbei_type[%u] what is the hell"
                        , __FILE__, __LINE__, zhuangbei_type);
            return false;
            break;
    }

    return match;
}


bool ProcServerThread::isZhuangbeiConfilct( std::vector< unsigned long long >& zb_vec)
{
    //0-头，1-衣服，2-裤子，3-靴子，4-武器，5-副手，6-附身符，7-戒指
    bool has_kuijia = false;
    bool has_wuqi = false;
    bool has_fushou = false;
    bool has_hushenfu = false;
    int has_jiezhi_count = 0;
    

    if(zb_vec.size() > 6)
    {
        return true;
    }
    
    for(int i=0; i<zb_vec.size(); ++i)
    {
        unsigned int zhuangbei_type = 0;
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_type "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu"
                , zb_vec[i]);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                            , __FILE__, __LINE__, zb_vec[i]);

                    Mysql_Thread_Conn->FreeResult();
                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        switch(zhuangbei_type)
        {
            case ZhuangbeiType_DanshouJian:
            case ZhuangbeiType_DanshouFazhang:
                if(has_wuqi)
                {
                    return true;
                }
                else
                {
                    has_wuqi = true;
                }
                break;
            case ZhuangbeiType_ShuangshouBishou:
            case ZhuangbeiType_ShuangshouFu:
            case ZhuangbeiType_ShuangshouFazhang:
            case ZhuangbeiType_Gong:
                if(has_wuqi || has_fushou)
                {
                    return true;
                }
                else
                {
                    has_wuqi = true;
                    has_fushou = true;
                }
                break;
            case ZhuangbeiType_Faqi:
            case ZhuangbeiType_Dunpai:
                if(has_fushou)
                {
                    return true;
                }
                else
                {
                    has_fushou = true;
                }
                break;
            case ZhuangbeiType_Hushenfu:
                if(has_hushenfu)
                {
                    return true;
                }
                else
                {
                    has_hushenfu = true;
                }
                break;
            case ZhuangbeiType_KuijiaZhong:
            case ZhuangbeiType_KuijiaQin:
                if(has_kuijia)
                {
                    return true;
                }
                else
                {
                    has_kuijia = true;
                }
                break;
            case ZhuangbeiType_Jiezhi:
                if(has_jiezhi_count >= 2)
                {
                    return true;
                }
                else
                {
                    has_jiezhi_count++;
                }
                break;
            default:
                LogMsg("%s, line %d, zhuangbei_type[%u] what is the hell"
                            , __FILE__, __LINE__, zhuangbei_type);
                return true;
                break;
        }
    }

    return false;
}

unsigned int ProcServerThread::getItemCountInTeam(unsigned int main_hero_id,unsigned int item_type)
{
    unsigned int item_count = 0;
    
    char sql[1024];
    sprintf(sql, "select item_count from hellgate.items_in_team "
        " where hero_id=%u and item_type=%u"
        , main_hero_id, item_type);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            item_count = atoi(Mysql_Thread_Conn->GetField("item_count"));
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    return item_count;
}


bool ProcServerThread::getZhuangbeiDetail(
    unsigned long long zhuangbei_id, unsigned int& owner_id,__ZhuangbeiDetail & detail)
{
    detail.zhuangbei_id = zhuangbei_id;
    
    {
        char sql[4096];
        sprintf(sql, "select group_id, zhuangbei_type, "
            "zhuangbei_colour, zhuangbei_name, zhuangbei_pic, zhuangbei_desc,"
            "owner_hero_id, zhuangbei_hero_id, zhuangbei_level, "
            "hole, diamond_type_1, diamond_type_2, diamond_type_3, "
            "gongji_min, gongji_max, hujia,"
            " attr_count, "
            /*" attr_type_1, attr_value_1, cuiqu_suc_ratio_1, "
            " attr_type_2, attr_value_2, cuiqu_suc_ratio_2, "
            " attr_type_3, attr_value_3, cuiqu_suc_ratio_3, "
            " attr_type_4, attr_value_4, cuiqu_suc_ratio_4, "
            " attr_type_5, attr_value_5, cuiqu_suc_ratio_5, "
            " attr_type_6, attr_value_6, cuiqu_suc_ratio_6, "
            " attr_type_7, attr_value_7, cuiqu_suc_ratio_7, "
            " attr_type_8, attr_value_8, cuiqu_suc_ratio_8, "
            " attr_type_9, attr_value_9, cuiqu_suc_ratio_9, "
            " attr_type_10, attr_value_10, cuiqu_suc_ratio_10, "
            " attr_type_11, attr_value_11, cuiqu_suc_ratio_11, "
            " attr_type_12, attr_value_12, cuiqu_suc_ratio_12, "
            " attr_type_13, attr_value_13, cuiqu_suc_ratio_13, "
            " attr_type_14, attr_value_14, cuiqu_suc_ratio_14, "*/
            " attr_type_1, attr_value_1, "
            " attr_type_2, attr_value_2, "
            " attr_type_3, attr_value_3, "
            " attr_type_4, attr_value_4, "
            " attr_type_5, attr_value_5, "
            " attr_type_6, attr_value_6, "
            " attr_type_7, attr_value_7, "
            " attr_type_8, attr_value_8, "
            " attr_type_9, attr_value_9, "
            " attr_type_10, attr_value_10, "
            " attr_type_11, attr_value_11, "
            " attr_type_12, attr_value_12, "
            " attr_type_13, attr_value_13, "
            " attr_type_14, attr_value_14, "
            " qianghua_count"
            ", qianghua_level_1, qianghua_percent_1"
            ", qianghua_level_2, qianghua_percent_2"
            ", qianghua_level_3, qianghua_percent_3"
            ", qianghua_level_4, qianghua_percent_4"
            ", qianghua_level_5, qianghua_percent_5"
            ", qianghua_level_6, qianghua_percent_6"
            ", qianghua_level_7, qianghua_percent_7"
            ", qianghua_level_8, qianghua_percent_8"
            ", qianghua_level_9, qianghua_percent_9"
            ", has_fumo, fumo_attr_type, fumo_attr_value, fumo_attr_cuiqu_suc_ratio "
            ", jinglian_level, "
            " jinglian_attr_type_1, jinglian_attr_value_1,"
            " jinglian_attr_type_2, jinglian_attr_value_2,"
            " next_jinglian_attr_type_1, next_jinglian_attr_value_1, "
            " next_jinglian_attr_type_2, next_jinglian_attr_value_2, "
            " is_unlocked,"
            " identified_attr_count, "
            " hide_attr_type_1, hide_attr_value_1," 
            " hide_attr_type_2, hide_attr_value_2," 
            " hide_attr_type_3, hide_attr_value_3," 
            " hide_attr_type_4, hide_attr_value_4," 
            " hide_attr_type_5, hide_attr_value_5," 
            " has_jingwen, "
            " jingwen_attr_type_1, jingwen_attr_value_1, " 
            " jingwen_attr_type_2, jingwen_attr_value_2, " 
            " purify_hole, "
            " purify_attr_type_1, purify_attr_value_1, "
            " purify_attr_type_2, purify_attr_value_2, purify_attr_type_3, purify_attr_value_3, "
            " purify_attr_type_4, purify_attr_value_4, purify_attr_type_5, purify_attr_value_5 "
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                detail.group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                
                detail.zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                detail.zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                
                strncpy(detail.zhuangbei_name, Mysql_Thread_Conn->GetField("zhuangbei_name"), ZhuangbeiNameMaxLen);
                detail.zhuangbei_name[ZhuangbeiNameMaxLen] = 0;

                strncpy(detail.zhuangbei_pic, Mysql_Thread_Conn->GetField("zhuangbei_pic"), ZhuangbeiPicMaxLen);
                detail.zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;

                detail.desc = Mysql_Thread_Conn->GetField("zhuangbei_desc");


                detail.zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                owner_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                
                detail.zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                
                detail.hole = atoi(Mysql_Thread_Conn->GetField("hole"));
                detail.diamond_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                detail.diamond_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                detail.diamond_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));

                //检查孔和宝石数量合法性
                {
                }

                detail.gongji_min = atoi(Mysql_Thread_Conn->GetField("gongji_min"));
                detail.gongji_max = atoi(Mysql_Thread_Conn->GetField("gongji_max"));
                detail.hujia = atoi(Mysql_Thread_Conn->GetField("hujia"));

                //atrr
                int attr_count = atoi(Mysql_Thread_Conn->GetField("attr_count"));
                for(int i=0; i<attr_count; ++i)
                {
                    ZBAttr attr;

                    char str[32];
                    sprintf(str, "attr_type_%d", i+1);
                    attr.attr_type = atoi(Mysql_Thread_Conn->GetField(str));

                    sprintf(str, "attr_value_%d", i+1);
                    attr.attr_value = atoi(Mysql_Thread_Conn->GetField(str));

                    //sprintf(str, "cuiqu_suc_ratio_%d", i+1);
                    //attr.cuiqu_suc_ratio = atoi(Mysql_Thread_Conn->GetField(str));

                    detail.attr_vec.push_back(attr);
                }
                

                //强化数据
                detail.qianghua_data.max_qianghua_time 
                    = getQianghuaMaxTime((ZhuangbeiType)detail.zhuangbei_type
                    ,(ZhuangbeiColour)detail.zhuangbei_colour, detail.zhuangbei_level);
                detail.qianghua_data.qianghua_count = atoi(Mysql_Thread_Conn->GetField("qianghua_count"));
                
                for(int i=0; i<detail.qianghua_data.qianghua_count; ++i)
                {
                    QianghuaInfo info;
                    info.id = i+1;

                    char str[32];
                    sprintf(str, "qianghua_level_%d", info.id);
                    info.level = (char)atoi(Mysql_Thread_Conn->GetField(str));

                    sprintf(str, "qianghua_percent_%d", info.id);
                    info.percent = (char)atoi(Mysql_Thread_Conn->GetField(str));

                    detail.qianghua_data.info_arr[i] = info;
                }

                //附魔数据
                detail.has_fumo = false;
                if(atoi(Mysql_Thread_Conn->GetField("has_fumo")) != 0)
                {
                    detail.has_fumo = true;
                    detail.fumo_attr.attr_type = atoi(Mysql_Thread_Conn->GetField("fumo_attr_type"));
                    detail.fumo_attr.attr_value = atoi(Mysql_Thread_Conn->GetField("fumo_attr_value"));
                    detail.fumo_attr.cuiqu_suc_ratio = atoi(Mysql_Thread_Conn->GetField("fumo_attr_cuiqu_suc_ratio"));
                }
                
                //精炼数据
                detail.jinglian_level = 0;
                if(detail.zhuangbei_colour == ZhuangbeiColour_Chuanqi 
                    || detail.zhuangbei_colour == ZhuangbeiColour_Xiyou)
                {
                    float refine_weapon_gain = REFINE_EQUIP_GAIN_PER;
                    if(detail.zhuangbei_colour == ZhuangbeiColour_Xiyou)
                        refine_weapon_gain /= 2;
                    
                    detail.jinglian_level = atoi(Mysql_Thread_Conn->GetField("jinglian_level"));
                    if(detail.jinglian_level > 0)
                    {
                        if(detail.jinglian_level > 9)
                        {
                            LogMsg("%s, line %d, jinglian level >9. zhuangbei_id=%llu"
                            , __FILE__, __LINE__, zhuangbei_id);

                            detail.jinglian_level = 0;
                        }
                        else
                        {
                            if(detail.zhuangbei_type == ZhuangbeiType_DanshouJian || 
                                detail.zhuangbei_type == ZhuangbeiType_ShuangshouBishou ||
                                detail.zhuangbei_type == ZhuangbeiType_ShuangshouFu ||
                                detail.zhuangbei_type == ZhuangbeiType_DanshouFazhang ||
                                detail.zhuangbei_type == ZhuangbeiType_Gong ||
                                detail.zhuangbei_type == ZhuangbeiType_ShuangshouFazhang)
                            {//武器
                                ZBAttr attr;
                                attr.attr_type = AttrType_gongji_min;
                                attr.attr_value = detail.jinglian_level *refine_weapon_gain *detail.gongji_min;
                                attr.cuiqu_suc_ratio = 0;
                                detail.jinglian_attr_vec.push_back(attr);

                                
                                attr.attr_type = AttrType_gongji_max;
                                attr.attr_value = detail.jinglian_level *refine_weapon_gain *detail.gongji_max;
                                attr.cuiqu_suc_ratio = 0;
                                detail.jinglian_attr_vec.push_back(attr);
                            }
                            else if(detail.zhuangbei_type == ZhuangbeiType_Faqi)
                            {//法器
                                ZBAttr attr;
                                attr.attr_type = AttrType_zhili;

                                int i;
                                for(i=0; i<detail.attr_vec.size(); i++)
                                {
                                    if(detail.attr_vec[i].attr_type == AttrType_zhili)
                                        break;
                                }
                                
                                attr.attr_value = detail.jinglian_level *refine_weapon_gain *detail.attr_vec[i].attr_value;
                                attr.cuiqu_suc_ratio = 0;
                                detail.jinglian_attr_vec.push_back(attr);
                            }   
                            else if(detail.zhuangbei_type == ZhuangbeiType_KuijiaQin ||
                                detail.zhuangbei_type == ZhuangbeiType_KuijiaZhong ||
                                detail.zhuangbei_type == ZhuangbeiType_Dunpai)
                            {//盔甲和盾牌
                                ZBAttr attr;
                                attr.attr_type = AttrType_hujia_add;
                                attr.attr_value = detail.jinglian_level *refine_weapon_gain *detail.hujia;
                                attr.cuiqu_suc_ratio = 0;
                                detail.jinglian_attr_vec.push_back(attr);
                            }
                            else if(detail.zhuangbei_type == ZhuangbeiType_Jiezhi ||
                                detail.zhuangbei_type == ZhuangbeiType_Hushenfu)
                            {//戒指和护身符
                                ZBAttr attr;
                                bzero(&attr, sizeof(ZBAttr));
                                for(int i=0; i<detail.attr_vec.size(); i++)
                                {
                                    if(detail.attr_vec[i].attr_type == AttrType_liliang ||
                                        detail.attr_vec[i].attr_type == AttrType_mingjie ||
                                        detail.attr_vec[i].attr_type == AttrType_zhili ||
                                        detail.attr_vec[i].attr_type == AttrType_tineng)
                                    {
                                        if(detail.attr_vec[i].attr_value >= attr.attr_value){
                                            attr = detail.attr_vec[i];
                                        }   
                                    }
                                }
                                
                                attr.attr_value *= (detail.jinglian_level * refine_weapon_gain);
                                attr.cuiqu_suc_ratio = 0;
                                
                                if(attr.attr_value>0 && attr.attr_type>0)
                                    detail.jinglian_attr_vec.push_back(attr);
                            }
                            
                        }
                    }
                
                    
                }
                
                //洗炼信息
                unsigned int purify_hole = atoi(Mysql_Thread_Conn->GetField("purify_hole"));
                for(int i=0; i<purify_hole; ++i) {
                    ZBAttr attr;
                    char type_str[32];
                    char value_str[32];
                    sprintf(type_str, "purify_attr_type_%d", i+1);
                    sprintf(value_str, "purify_attr_value_%d", i+1);

                    attr.attr_type = atoi(Mysql_Thread_Conn->GetField(type_str));
                    attr.attr_value = atoi(Mysql_Thread_Conn->GetField(value_str));
                    attr.cuiqu_suc_ratio = 0;

                    detail.purify_attr.push_back(attr);
                }

                //神兵
                detail.is_shenbing = false;
                
                //解封印
                detail.is_unlocked = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlocked"));
                if(ZBGroupIsShenbing(detail.group_id) != -1)
                {
                    detail.is_shenbing = true;


                    //鉴定的隐藏属性
                    unsigned int identified_attr_count = atoi(Mysql_Thread_Conn->GetField("identified_attr_count"));
                    for(int i=1; i<=identified_attr_count; ++i)
                    {
                        char type_str[32];
                        char value_str[32];
                        sprintf(type_str, "hide_attr_type_%d", i);
                        sprintf(value_str, "hide_attr_value_%d", i);

                        ZBAttr attr;
                        attr.attr_type = atoi(Mysql_Thread_Conn->GetField(type_str));
                        attr.attr_value = atoi(Mysql_Thread_Conn->GetField(value_str));
                        attr.cuiqu_suc_ratio = 0;

                        detail.identified_attr.push_back(attr);
                    }

                    //经文
                    detail.has_jingwen = (bool)atoi(Mysql_Thread_Conn->GetField("has_jingwen"));
                    if(detail.has_jingwen)
                    {
                        for(int i=0; i<=1; ++i)
                        {
                            char type_str[32];
                            char value_str[32];
                            sprintf(type_str, "jingwen_attr_type_%d", i+1);
                            sprintf(value_str, "jingwen_attr_value_%d", i+1);

                            detail.jingwen_attr_arr[i].attr_type = atoi(Mysql_Thread_Conn->GetField(type_str));
                            detail.jingwen_attr_arr[i].attr_value = atoi(Mysql_Thread_Conn->GetField(value_str));
                            detail.jingwen_attr_arr[i].cuiqu_suc_ratio = 0;
                        }
                    }
                }
            }
            else
            {
                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    int index = ZBGroupIsShenbing(detail.group_id);
    if(index != -1){
        detail.profession_id = m_shenbing_vec[index].profession_id;
    } else {
        detail.profession_id = 0;
    }

    return true;
}

void ProcServerThread::unequipZhuangbei(unsigned int hero_id,unsigned long long zhuangbei_id)
{
    unsigned int zhuangbei_hero_id = 0;

    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_hero_id"
            " from hellgate.zhuangbei_list where zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_id=[%u] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(zhuangbei_hero_id != hero_id)
    {
        return;
    }

    //update
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list set zhuangbei_hero_id=0 where zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return;
}

int ProcServerThread::getQianghuaMaxTime(ZhuangbeiType type, ZhuangbeiColour colour, unsigned int level)
{
    if(_isWuqi(type) || type==ZhuangbeiType_KuijiaQin || type==ZhuangbeiType_KuijiaZhong)
    {
        if(level < 5)
        {
            return 4;
        }
        
        if(colour == ZhuangbeiColour_Baizhuang || colour == ZhuangbeiColour_Fumo)
        {
            return 5;
        }
        if(colour == ZhuangbeiColour_Xiyou)
        {
            return 7;
        }
        if(colour == ZhuangbeiColour_Chuanqi)
        {
            return 9;
        }
    }

    return 0;
}


bool ProcServerThread::createZhuangbei(
    unsigned int zhuangbei_name_id, unsigned int group_id
    , unsigned int owner_hero_id
    ,__ZhuangbeiDetail & detail_out, bool b_check_count/*=true*/, bool b_battle/*=false*/)
{
    //
    detail_out.init();

    if(b_check_count){
        if(get_unequipped_counts(owner_hero_id) >= MAX_COUNTS_IN_KNAPSACK) {
            LogMsg("%s, line %d, hero[%u] unequipped zb is over limit."
                , __FILE__, __LINE__, owner_hero_id);
            return false;
        }
    }

    //
    detail_out.group_id = group_id;
    
    
    //查询模板信息
    unsigned int zhuangbei_type, zhuangbei_colour, zhuangbei_level, gongji_min_min, 
         gongji_min_max, gongji_max_min, gongji_max_max, wufang_min, wufang_max, 
         hole_1_ratio, hole_2_ratio,hole_3_ratio, profession_id;
    std::string zhuangbei_name, zhuangbei_pic, zhuangbei_desc;
    std::vector<std::string> attr_vec;
    std::vector<std::string> jinglian_attr_vec;
    std::vector<std::string> hide_attr_vec;
    std::string jingwen_attr;
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_type, zhuangbei_name, zhuangbei_colour, "
            " zhuangbei_pic, zhuangbei_desc, zhuangbei_level, gongji_min_min, "
            " gongji_min_max, gongji_max_min, gongji_max_max, wufang_min, wufang_max, "
            " hole1_percent, hole2_percent, hole3_percent, "
            " attr_1, attr_2, attr_3, attr_4, attr_5, attr_6, attr_7, attr_8, attr_9, attr_10, "
            "jinglian_level_1_attr,"
            "jinglian_level_2_attr,"
            "jinglian_level_3_attr,"
            "jinglian_level_4_attr,"
            "jinglian_level_5_attr,"
            "jinglian_level_6_attr,"
            "jinglian_level_7_attr,"
            "jinglian_level_8_attr,"
            "jinglian_level_9_attr,"
            "hide_attr_1_attr,     "
            "hide_attr_2_attr,     "
            "hide_attr_3_attr,     "
            "hide_attr_4_attr,     "
            "hide_attr_5_attr,     "
            "jingwen_attr          "
            " from hellgate.zhuangbei_name_list_copy where zhuangbei_name_id=%u"
            , zhuangbei_name_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                gongji_min_min = atoi(Mysql_Thread_Conn->GetField("gongji_min_min"));
                gongji_min_max = atoi(Mysql_Thread_Conn->GetField("gongji_min_max"));
                gongji_max_min = atoi(Mysql_Thread_Conn->GetField("gongji_max_min"));
                gongji_max_max = atoi(Mysql_Thread_Conn->GetField("gongji_max_max"));
                wufang_min = atoi(Mysql_Thread_Conn->GetField("wufang_min"));
                wufang_max = atoi(Mysql_Thread_Conn->GetField("wufang_max"));
                hole_1_ratio = atoi(Mysql_Thread_Conn->GetField("hole1_percent"));
                hole_2_ratio = atoi(Mysql_Thread_Conn->GetField("hole2_percent"));
                hole_3_ratio = atoi(Mysql_Thread_Conn->GetField("hole3_percent"));
                
                get_zb_hole_percent(zhuangbei_level, zhuangbei_colour, zhuangbei_type,
                    hole_1_ratio, hole_2_ratio, hole_3_ratio);

                zhuangbei_name = std::string(Mysql_Thread_Conn->GetField("zhuangbei_name"));
                zhuangbei_pic = std::string(Mysql_Thread_Conn->GetField("zhuangbei_pic"));
                zhuangbei_desc = std::string(Mysql_Thread_Conn->GetField("zhuangbei_desc"));

                //普通属性
                {
                    for(int i=1; i<=10; ++i)
                    {
                        char str[32];
                        sprintf(str, "attr_%d", i);
                        if(strlen(Mysql_Thread_Conn->GetField(str)) > 0)
                        {
                            attr_vec.push_back(std::string(Mysql_Thread_Conn->GetField(str)));
                        }
                    }
                }

                //精炼属性
                if(zhuangbei_colour == ZhuangbeiColour_Chuanqi || zhuangbei_colour == ZhuangbeiColour_Xiyou)
                {
                    unsigned int jinglian_max_time = CS::getJingLianMaxTimes(zhuangbei_colour, zhuangbei_level);
                    
                    for(int i=1; i<=jinglian_max_time; ++i)
                    {
                        char str[32];
                        sprintf(str, "jinglian_level_%d_attr", i);
                        if(strlen(Mysql_Thread_Conn->GetField(str)) > 0)
                        {
                            jinglian_attr_vec.push_back(std::string(Mysql_Thread_Conn->GetField(str)));
                        }
                        /*else
                        {
                            LogMsg("%s, line %d, jinglian attr count error zhuangbei_group_id[%u]."
                                , __FILE__, __LINE__, group_id);
                            return false;
                        }*/
                    }
                }

                //神兵隐藏属性
                //神兵经文属性
                profession_id = 0;
                int index = ZBGroupIsShenbing(group_id);
                if(index != -1)
                {
                    profession_id = m_shenbing_vec[index].profession_id;
                    for(int i=1; i<=5; ++i)
                    {
                        char str[32];
                        sprintf(str, "hide_attr_%d_attr", i);
                        if(strlen(Mysql_Thread_Conn->GetField(str)) > 0)
                        {
                            hide_attr_vec.push_back(std::string(Mysql_Thread_Conn->GetField(str)));
                        }
                        /*
                        else
                        {
                            LogMsg("%s, line %d, shenbing hide_attr count error zhuangbei_group_id[%u]."
                                , __FILE__, __LINE__, group_id);
                            return false;
                        }
                        */
                    }

                    //神兵经文属性
                    jingwen_attr = Mysql_Thread_Conn->GetField("jingwen_attr");
                }
                
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_name_id=[%u] not exist"
                        , __FILE__, __LINE__, zhuangbei_name_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    {
        detail_out.zhuangbei_type = zhuangbei_type;
        strncpy(detail_out.zhuangbei_name, zhuangbei_name.c_str(), ZhuangbeiNameMaxLen);
        detail_out.zhuangbei_name[ZhuangbeiNameMaxLen] = 0;
        detail_out.zhuangbei_colour = zhuangbei_colour;
        strncpy(detail_out.zhuangbei_pic, zhuangbei_pic.c_str(), ZhuangbeiPicMaxLen);
        detail_out.zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;

        detail_out.zhuangbei_hero_id = 0;

        detail_out.zhuangbei_level = zhuangbei_level;
        detail_out.diamond_type_1 = 0;
        detail_out.diamond_type_2 = 0;
        detail_out.diamond_type_3 = 0;

        detail_out.desc = zhuangbei_desc;
    }
    //强化信息
    {
        detail_out.qianghua_data.max_qianghua_time 
            = getQianghuaMaxTime((ZhuangbeiType)detail_out.zhuangbei_type
                ,(ZhuangbeiColour)detail_out.zhuangbei_colour,detail_out.zhuangbei_level);
        detail_out.qianghua_data.qianghua_count = 0;
    }
    

    detail_out.hole = get_zb_hole(zhuangbei_level, zhuangbei_colour, zhuangbei_type);
    detail_out.profession_id = profession_id;
    
    //
    {
        detail_out.gongji_min = randomFromMinMax(gongji_min_min, gongji_min_max);
        detail_out.gongji_max = randomFromMinMax(gongji_max_min, gongji_max_max);
        detail_out.hujia = randomFromMinMax(wufang_min, wufang_max);
    }
    //处理属性组
    {
        for(int i=0; i<attr_vec.size(); ++i)
        {
            //取出所有键值对
            std::list<std::string> key_list;
            std::list<std::string> value_list;
            Str2KeyValueList(attr_vec[i], key_list, value_list);

            //
            if(key_list.size() == 0)
            {
                LogMsg("%s, line %d, zhuangbei module error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zhuangbei_name_id);
                continue;
            }

            //找到概率
            unsigned int gailv = 100;
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos != key_list.end() && value_pos != value_list.end()
                    ; ++key_pos, ++value_pos)
                {
                    if(*key_pos == ZB_Key_gailv)
                    {
                        gailv = atoi((*value_pos).c_str());

                        key_list.erase(key_pos);
                        value_list.erase(value_pos);

                        break;
                    }
                }
                if(key_pos == key_list.end())
                {
                    LogMsg("%s, line %d, zhuangbei module error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zhuangbei_name_id);
                    continue;
                }
            }
            //找到有效数
            unsigned int youxiao_count = 0;
            {
                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(; key_pos != key_list.end() && value_pos != value_list.end()
                    ; ++key_pos, ++value_pos)
                {
                    if(*key_pos == ZB_Key_count)
                    {
                        unsigned int min, max;
                        Str2MinMax(*value_pos,min,max);
                        youxiao_count = randomFromMinMax(min, max);

                        key_list.erase(key_pos);
                        value_list.erase(value_pos);

                        break;
                    }
                }
                if(key_pos == key_list.end())
                {
                    LogMsg("%s, line %d, zhuangbei module error. zhuangbei_name_id=[%u]"
                        , __FILE__, __LINE__, zhuangbei_name_id);
                    continue;
                }
            }
            
            
            if(youxiao_count == 0 || youxiao_count > key_list.size()
                || gailv == 0 || gailv > 100)
            {
                LogMsg("%s, line %d, zhuangbei module error. zhuangbei_name_id=[%u]"
                    , __FILE__, __LINE__, zhuangbei_name_id);

                continue;
            }

            //根据概率判断是否附带
            {
                if(Utl::auto_random()%100 >= gailv)
                {

                    continue;
                }
            }

            //填写属性值
            for(int i=0; i<youxiao_count; ++i)
            {
                //随机选择属性组中一个属性
                if(key_list.size() == 0)
                {
                    LogMsg("%s, line %d, zhuangbei module error. zhuangbei_name_id=[%u] youxiao_count=[%u]"
                        , __FILE__, __LINE__, zhuangbei_name_id, youxiao_count);
                    break;
                }
                
                int index = Utl::auto_random()%key_list.size();

                std::list<std::string>::iterator key_pos = key_list.begin();
                std::list<std::string>::iterator value_pos = value_list.begin();
                for(int x=0; x<index; ++x, ++key_pos, ++value_pos);


                ZBAttr attr;
                if(!keyValue2Attr(*key_pos,*value_pos,zhuangbei_type
                    ,zhuangbei_colour,zhuangbei_level,attr))
                {
                    LogMsg("%s, line %d, zhuangbei module error. zhuangbei_name_id=[%u]"
                            , __FILE__, __LINE__, zhuangbei_name_id);
                    continue;
                }
                if(zhuangbei_level < Cuiqu_zhuangbei_min_level)
                {
                    attr.cuiqu_suc_ratio = 0;
                }

                /*
                //对于教学萃取装备特殊处理
                if(group_id == ZhuangBei_FirstCuiqu_GroupId_jian)
                {
                    attr.cuiqu_suc_ratio = 100;
                }
                */

                //
                detail_out.attr_vec.push_back(attr);

                //
                key_list.erase(key_pos);
                value_list.erase(value_pos);
            }
        }
    }

    { //精炼
        detail_out.jinglian_level = 0;
    }

    { //神兵
        detail_out.is_shenbing = (ZBGroupIsShenbing(group_id) != -1);

        detail_out.has_jingwen = false;
    }
    
    if(zhuangbei_colour == ZhuangbeiColour_Xiyou && b_battle) { //是否鉴定
        std::map<unsigned int, unsigned int>::iterator pos = 
            m_assess_weapon_map.find(group_id);
        if(pos != m_assess_weapon_map.end())
            detail_out.is_unlocked = false;
        else
            detail_out.is_unlocked = true;
    }
    else {
        detail_out.is_unlocked = true;
    }

    unsigned int max_hole = CS::getPurifyMaxHoles(detail_out.zhuangbei_type, 
        detail_out.zhuangbei_colour, detail_out.zhuangbei_level);

    if(max_hole > 0) {
        ZBAttr attr;
        attr.attr_type = AttrType_baoshang;
        attr.attr_value = 5;
        attr.cuiqu_suc_ratio = 0;
        detail_out.purify_attr.push_back(attr);
    }

    return true;
}

bool ProcServerThread::keyValue2Attr(std::string key_str,std::string value_str
    , unsigned int zhuangbei_type, unsigned int zhuangbei_colour, unsigned int zhuangbei_level
    ,ZBAttr & attr)
{
    unsigned int value = 0;
    unsigned int min, max;
    Str2MinMax(value_str,min, max);
    value = randomFromMinMax(min, max);
                
    if(key_str == ZB_Key_liliang)
    {
        attr.attr_type = AttrType_liliang;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_mingjie)
    {
        attr.attr_type = AttrType_mingjie;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_zhili)
    {
        attr.attr_type = AttrType_zhili;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_tineng)
    {
        attr.attr_type = AttrType_tineng;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_kangxing)
    {
        attr.attr_type = AttrType_kangxing;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_baoji)
    {
        attr.attr_type = AttrType_baoji;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_baoshang)
    {
        attr.attr_type = AttrType_baoshang;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_hp_ration)
    {
        attr.attr_type = AttrType_hp_percent;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_gedanglv)
    {
        attr.attr_type = AttrType_gedanglv;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_gedangzhi)
    {
        attr.attr_type = AttrType_gedangzhi;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_gongji_min_add)
    {
        attr.attr_type = AttrType_gongji_min;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_gongji_max_add)
    {
        attr.attr_type = AttrType_gongji_max;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_hujia_add)
    {
        attr.attr_type = AttrType_hujia_add;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
            (ZhuangbeiType)zhuangbei_type,(ZhuangbeiColour)zhuangbei_colour,zhuangbei_level
            ,(AttrType)attr.attr_type,attr.attr_value);
    }
    else if(key_str == ZB_Key_skill_zhouqi)
    {
        attr.attr_type = AttrType_skillzhouqi;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = 0; //技能触发属性不可萃取
    }
    else if(key_str == ZB_Key_skill_turn)
    {
        attr.attr_type = AttrType_skillturn;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = 0; //技能触发属性不可萃取
    }
    else if(key_str == ZB_Key_skill_result)
    {
        attr.attr_type = AttrType_skillresult;
        attr.attr_value = value;
        attr.cuiqu_suc_ratio = 0; //技能加成属性不可萃取
    }
    else
    {
        return false;
    }

    return true;
}

void ProcServerThread::destroyZhuangbei(unsigned long long zhuangbei_id)
{
    char sql[2048];
        sprintf(sql, "delete from hellgate.zhuangbei_list "
            " where zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
}


struct _ZhuangbeiAndRatio
{
    unsigned int id;
    float ratio;

    bool operator < (const _ZhuangbeiAndRatio& hs) const
    {
        return ratio < hs.ratio;
    };
};

unsigned int ProcServerThread::chooseZhuangbeiNameIdFromGroupId(unsigned int zb_group_id)
{
    unsigned int zb_name_id = 0;
    
    //从group中选出具体子装备
    std::vector<_ZhuangbeiAndRatio> zb_name_vec;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_name_id, group_weight from hellgate.zhuangbei_name_list_copy "
            " where group_id=%u"
            , zb_group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                _ZhuangbeiAndRatio zb;
                
                zb.id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                zb.ratio = atoi(Mysql_Thread_Conn->GetField("group_weight"));

                zb_name_vec.push_back(zb);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(zb_name_vec.size() == 0)
    {
        LogMsg("%s, line %d, zb_group[%u] has no child"
                        , __FILE__, __LINE__, zb_group_id);
    }
    int total_ratio = 0;
    for(int i=0; i<zb_name_vec.size(); ++i)
    {
        total_ratio += zb_name_vec[i].ratio;
    }

    if(total_ratio <= 0)
    {
        LogMsg("%s, line %d, zb_group[%u] total_ratio=[%d]"
                        , __FILE__, __LINE__, zb_group_id, total_ratio);
    }
    else
    {
        /*
        //这里是按照权重，不要求total_ratio必须小于100
        int ratio = Utl::auto_random()%total_ratio;
        for(int i=0; i<zb_name_vec.size(); ++i)
        {
            ratio -= zb_name_vec[i].ratio;
            if(ratio < 0)
            {
                zb_name_id = zb_name_vec[i].id;
                break;
            }
        }
        */
        //这里是按照权重，不要求total_ratio必须小于100
        std::vector<float> weight_vec;
        for(int i=0; i<zb_name_vec.size(); ++i)
        {
            weight_vec.push_back(zb_name_vec[i].ratio);
        }
        int rand_index = RandomByWeight(weight_vec);
        if(rand_index < 0)
        {
            LogMsg("%s, line %d, shit."
                        , __FILE__, __LINE__);
            assert(false);
        }
        zb_name_id = zb_name_vec[rand_index].id;
    }

    return zb_name_id;
}


unsigned int ProcServerThread::randomFromMinMax(unsigned int min,unsigned int max)
{
    if(max == min)
    {
        return min;
    }

    if(max < min)
    {
        unsigned int tmp = max;
        max = min;
        min = tmp;
    }

    int v = Utl::auto_random()%(max-min+1);
    return min + v;
}

int ProcServerThread::RandomByWeight( std::vector < float > weightVec)
{
    float total_weight = 0;
    for(int i=0; i<weightVec.size(); ++i)
    {
        total_weight += weightVec[i];
    }

    if(total_weight == 0)
    {
        return -1;
    }

    //获得一个精确到小数点后两位的100以内的浮点数 
    float rand_weight = ((float)(Utl::auto_random()%10000)) / 100;


    for(int index=0; index<weightVec.size(); ++index)
    {
        //将总权重缩放为100.0。
        rand_weight -= weightVec[index]*(100.0/total_weight);

        if(rand_weight < 0)
        {
            return index;
        }
    }
    LogMsg("%s, line %d, can not blieve. [%f]"
                        , __FILE__, __LINE__, rand_weight);

    return -1;
}

void ProcServerThread::Str2KeyValueList( std::string str
    , std::list < std::string > & key_list,std::list < std :: string > & value_list)
{
    key_list.clear();
    value_list.clear();
    
    char* buf = new char[str.length()+1];
    CMemGuard guard(buf);
    strcpy(buf, str.c_str());

    //取出所有键值对
    {
        char* p_str = buf;
        while(true)
        {
            //寻找第一个'='
            char *p_eq = strchr(p_str, '=');
        	if(p_eq)
        	{
        		int pos = p_eq - p_str;
        		char *p_comma = strchr(p_eq, ',');
                if(p_comma)
                {
                    *p_comma = '\0';
                }
        		
                std::string key = std::string(p_str, 0, pos);
        		std::string value = std::string(p_str + pos+1);
        		Utl::Trim(key);
                Utl::Trim(value);

                key_list.insert(key_list.end(), key);
                value_list.insert(value_list.end(), value);
                
                //
                if(p_comma)
                {
                    p_str = p_comma+1;
                }
                else
                {
                    break;
                }
        	}
        	else
        	{
        		break;
        	}
        }
    }
}

bool ProcServerThread::isMainHeroOfClient(unsigned int client_id,unsigned int main_hero_id)
{
    unsigned int client_id_db = 0;
    {
        char sql[1024];
        sprintf(sql, "select client_id from hellgate.hero_list where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                client_id_db = atoi(Mysql_Thread_Conn->GetField("client_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(client_id_db == 0 || client_id_db != client_id)
    {
        return false;
    }

    return true;
}

bool ProcServerThread::isHeroBelong2Team(unsigned int hero_id,unsigned int main_hero_id)
{
    if(hero_id == main_hero_id)
    {
        return true;
    }

    unsigned int parent_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select parent_hero_id from hellgate.hero_infor where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                parent_id = atoi(Mysql_Thread_Conn->GetField("parent_hero_id"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u] not exist"
                        , __FILE__, __LINE__, hero_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(parent_id == main_hero_id)
    {
        return true;
    }
    else
    {
        return false;
    }
}
/*
void ProcServerThread::getSubTaskList(unsigned int hero_id, std::vector < SubTaskInfo > & sub_task_vec)
{
    //
    {
        SubTaskInfo task;
        getSubTaskDailyZhuangbei(hero_id, task);
        if(task.task_status != TaskStatus_NotActived)
        {
            sub_task_vec.insert(sub_task_vec.end(), task);
        }
        
    }
    {
        SubTaskInfo task;
        getSubTaskDailyBaoshi(hero_id, task);
        if(task.task_status != TaskStatus_NotActived)
        {
            sub_task_vec.insert(sub_task_vec.end(), task);
        }
    }
    
}

void ProcServerThread::getSubTaskDailyZhuangbei(unsigned int hero_id, SubTaskInfo & task)
{
    //
    task.clear();
    task.subtask_id = SubTaskId_DailyZhuangbei;

    //
    {
        char sql[1024];
        sprintf(sql, "select status, play_times_today, active_day_bitmap, play_times_limit_oneday "
            " from hellgate.subtask_daily_zhuangbei, hellgate.hero_progress_subtask_daily_zhuangbei "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                task.task_status = atoi(Mysql_Thread_Conn->GetField("status"));
                if(task.task_status == TaskStatus_NotActived)
                {
                    Mysql_Thread_Conn->FreeResult();
                    return;
                }

                task.active_day_bitmap = atoi(Mysql_Thread_Conn->GetField("active_day_bitmap"));
                
                task.is_play_times_limited = true;
                task.times_limit_oneday = atoi(Mysql_Thread_Conn->GetField("play_times_limit_oneday"));
                task.play_times_today = atoi(Mysql_Thread_Conn->GetField("play_times_today"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id=[%u] not exist"
                        , __FILE__, __LINE__, hero_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

void ProcServerThread::getSubTaskDailyBaoshi(unsigned int hero_id, SubTaskInfo & task)
{
    //
    task.clear();
    task.subtask_id = SubTaskId_DailyBaoshi;

    //
    {
        char sql[1024];
        sprintf(sql, "select status, play_times_today, active_day_bitmap, play_times_limit_oneday "
            " from hellgate.subtask_daily_baoshi, hellgate.hero_progress_subtask_daily_baoshi "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                task.task_status = atoi(Mysql_Thread_Conn->GetField("status"));
                if(task.task_status == TaskStatus_NotActived)
                {
                    Mysql_Thread_Conn->FreeResult();
                    return;
                }

                task.active_day_bitmap = atoi(Mysql_Thread_Conn->GetField("active_day_bitmap"));
                
                task.is_play_times_limited = true;
                task.times_limit_oneday = atoi(Mysql_Thread_Conn->GetField("play_times_limit_oneday"));
                task.play_times_today = atoi(Mysql_Thread_Conn->GetField("play_times_today"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id=[%u] not exist"
                        , __FILE__, __LINE__, hero_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}
*/

void ProcServerThread::CheckAndQianghuaZhuangbei(unsigned int hero_id, unsigned long long zhuangbei_id
        , bool b_gold_star, bool& qianghua_sucess, QianghuaInfo& qianghua_info)
{
    qianghua_sucess = false;
    
    //判断合法性
    unsigned int zhuangbei_hero_id = 0;
    unsigned int owner_hero_id = 0;
    unsigned int zhuangbei_type = 0;
    unsigned int zhuangbei_colour = 0;
    unsigned int zhuangbei_level = 0;
    unsigned int qianghua_count = 0;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_hero_id, owner_hero_id, zhuangbei_type, zhuangbei_colour "
            " , zhuangbei_level, qianghua_count "
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_list.zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                qianghua_count = atoi(Mysql_Thread_Conn->GetField("qianghua_count"));
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(owner_hero_id != hero_id)
    {
        LogMsg("%s, line %d, hero_id not match. hero_id=[%u], zhuangbei_id=[%llu]"
                        , __FILE__, __LINE__, hero_id, zhuangbei_id);
        
        return;
    }
    if(!CS::canZBTypeBeQianghua(zhuangbei_type))
    {
        LogMsg("%s, line %d, zhuangbei_type can not be qianghua. zhuangbei_type=[%u]"
                        , __FILE__, __LINE__, (int)zhuangbei_type);
        
        return;
    }
    if(zhuangbei_level < Qianghua_zhuangbei_min_level)
    {
        LogMsg("%s, line %d, zhuangbei_level too low. zhuangbei_id=[%llu]"
                        , __FILE__, __LINE__, zhuangbei_id);
        
        return;
    }
    if(qianghua_count == getQianghuaMaxTime((ZhuangbeiType)zhuangbei_type
        , (ZhuangbeiColour)zhuangbei_colour, zhuangbei_level))
    {
        LogMsg("%s, line %d, zhuangbei_id can not be qianghua more. zhuangbei_id=[%llu]"
                        , __FILE__, __LINE__, zhuangbei_id);
        
        return;
    }
    if(qianghua_count > getQianghuaMaxTime((ZhuangbeiType)zhuangbei_type
        , (ZhuangbeiColour)zhuangbei_colour, zhuangbei_level))
    {
        LogMsg("%s, line %d, shit. zhuangbei qianghua more times. qianghua_count=[%u] zhuangbei_id=[%llu]"
                        , __FILE__, __LINE__, qianghua_count, zhuangbei_id);
        
        return;
    }
    
    //获取item列表
    std::vector<ItemInfo> item_vec;
    {
        char sql[1024];
        sprintf(sql, "select item_type, item_count from hellgate.items_in_team "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ItemInfo item;
                
                item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                
                //
                item_vec.insert(item_vec.end(), item);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //计算强化材料所需数量
    unsigned int cailiao = CS::ItemsNeedForQianghuaZhuangbei(zhuangbei_level, zhuangbei_colour);
    int silver = CS::QianghuaZhuangbeiNeedSilver(zhuangbei_level, zhuangbei_colour);
    bool cailiao_enough = false;
    bool silver_enough = false;
    
    if(!b_gold_star) //普通强化
    {
        for(int i=0; i<item_vec.size(); ++i)
        {
            if(item_vec[i].type == ItemsType_QianghuaNormal && item_vec[i].count >= cailiao)
            {
                cailiao_enough = true;
            }
            
            if(item_vec[i].type == ItemsType_Silver && item_vec[i].count >= silver)
            {
                silver_enough = true;
            }
        }
        if(!cailiao_enough)
        {
            LogMsg("%s, line %d, normal cailiao not enough"
                        , __FILE__, __LINE__);
            return;
        }
        if(!silver_enough)
        {
            LogMsg("%s, line %d, silver not enough"
                        , __FILE__, __LINE__);
            return;
        }
    }
    else { //直接金星强化
        
        for(int i=0; i<item_vec.size(); ++i)
        {
            if(item_vec[i].type == ItemsType_GoldStar_Qianghua && item_vec[i].count >= 1)
            {
                cailiao_enough = true;
            }
            
        }
        if(!cailiao_enough)
        {
            LogMsg("%s, line %d, gold star material is not enough"
                        , __FILE__, __LINE__);
            return;
        }
    }

    //先强化
    {
        _QianghuaZhuangbei(zhuangbei_id, qianghua_count, b_gold_star, cailiao, qianghua_info);
    }

    //再扣材料
    if(!b_gold_star) //普通强化
    {
        //normal
        {
            char sql[1024];
            sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
                " where hero_id=%u and item_type=%u"
                , cailiao, hero_id, ItemsType_QianghuaNormal);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        //silver
        {
            char sql[1024];
            sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
                " where hero_id=%u and item_type=%u"
                , silver, hero_id, ItemsType_Silver);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    else //直接金星强化
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-1 "
            " where hero_id=%u and item_type=%u"
            , hero_id, ItemsType_GoldStar_Qianghua);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(qianghua_info.percent == QianghuaPercent_jin) { //触发日常任务
        send_system_bonus_notify(hero_id, BonusType_DayWelfare, BonusID_Intensify_GoldStar);
    }

    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }

    qianghua_sucess = true;
    return;
}

void ProcServerThread::_QianghuaZhuangbei(
    unsigned long long zhuangbei_id, unsigned int qianghua_count_now, bool b_gold_star, 
    unsigned int cailiao_count, QianghuaInfo& qianghua_info)
{
    //首先随机强化等级
    QianghuaLevel qh_level = QianghuaLevel_tie;
    if(!b_gold_star){ //普通强化
        int rand_var = Utl::auto_random()%100;
        if((rand_var -= QianghuaRatio_jin) < 0)
        {
            qh_level = QianghuaLevel_jin;
        }
        else if((rand_var -= QianghuaRatio_yin) < 0)
        {
            qh_level = QianghuaLevel_yin;
        }
        else if((rand_var -= QianghuaRatio_tong) < 0)
        {
            qh_level = QianghuaLevel_tong;
        }
    }
    else //直接金星强化
    {
        qh_level = QianghuaLevel_jin_special;
    }
    

    //强化百分比
    unsigned int qh_percent = 0;
    if(qh_level == QianghuaLevel_jin_special)
    {
        qh_percent = QianghuaPercent_jin;
    }
    else if(qh_level == QianghuaLevel_jin)
    {
        qh_percent = QianghuaPercent_jin;
    }
    else if(qh_level == QianghuaLevel_yin)
    {
        qh_percent = QianghuaPercent_yin;
    }
    else if(qh_level == QianghuaLevel_tong)
    {
        qh_percent = QianghuaPercent_tong;
    }
    else if(qh_level == QianghuaLevel_tie)
    {
        qh_percent = QianghuaPercent_tie;
    }
    
    if(qianghua_count_now >= Qianghua_time_max)
    {
        LogMsg("%s, line %d, fuck. qianghua_count_now=[%u]"
                    , __FILE__, __LINE__, qianghua_count_now);
        assert(false);
        return;
    }


    //入库
    if(!b_gold_star){
        char level_str[32];
        sprintf(level_str, " qianghua_level_%u", qianghua_count_now+1);
        char percent_str[32];
        sprintf(percent_str, " qianghua_percent_%u", qianghua_count_now+1);
        
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list "
            "set qianghua_count=%u, %s=%u, %s=%u, "
            " qianghua_cailiao_total_count=qianghua_cailiao_total_count+%u "
            "where zhuangbei_id=%llu "
            , qianghua_count_now+1, level_str, (int)qh_level, percent_str, qh_percent
            , cailiao_count
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else 
    {
        char level_str[32];
        sprintf(level_str, " qianghua_level_%u", qianghua_count_now+1);
        char percent_str[32];
        sprintf(percent_str, " qianghua_percent_%u", qianghua_count_now+1);
        
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list "
            "set qianghua_count=%u, %s=%u, %s=%u, "
            " qianghua_cailiao_goldstar_count=qianghua_cailiao_goldstar_count+1 "
            "where zhuangbei_id=%llu "
            , qianghua_count_now+1, level_str, (int)qh_level, percent_str, qh_percent
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    qianghua_info.id = qianghua_count_now+1;
    qianghua_info.level = qh_level;
    qianghua_info.percent = qh_percent;

    return;
}

bool ProcServerThread::CheckAndHuituiZhuangbei(
    unsigned int hero_id,unsigned long long zhuangbei_id
    , int keep_count, unsigned char id_arr[])
{
    //获取已有强化信息
    unsigned int zhuangbei_hero_id = 0;
    unsigned int owner_hero_id = 0;
    unsigned int qianghua_count = 0;
    unsigned int zb_type = 0;
    unsigned int zb_level = 0;
    unsigned int zb_colour = 0;
    std::vector<unsigned int> qh_level_vec;
    std::vector<unsigned int> qh_percent_vec;
    {
        char sql[2048];
        sprintf(sql, "select zhuangbei_hero_id, owner_hero_id, qianghua_count "
            ", zhuangbei_type, zhuangbei_colour, zhuangbei_level "
            ", qianghua_level_1, qianghua_percent_1"
            ", qianghua_level_2, qianghua_percent_2"
            ", qianghua_level_3, qianghua_percent_3"
            ", qianghua_level_4, qianghua_percent_4"
            ", qianghua_level_5, qianghua_percent_5"
            ", qianghua_level_6, qianghua_percent_6"
            ", qianghua_level_7, qianghua_percent_7"
            ", qianghua_level_8, qianghua_percent_8"
            ", qianghua_level_9, qianghua_percent_9"
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id   "
            " and zhuangbei_list.zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                qianghua_count = atoi(Mysql_Thread_Conn->GetField("qianghua_count"));
                zb_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zb_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                zb_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));

                for(int i=0; i<qianghua_count; ++i)
                {
                    char str[32];
                    sprintf(str, "qianghua_level_%d", i+1);
                    qh_level_vec.push_back(atoi(Mysql_Thread_Conn->GetField(str)));

                    sprintf(str, "qianghua_percent_%d", i+1);
                    qh_percent_vec.push_back(atoi(Mysql_Thread_Conn->GetField(str)));
                }
            }
            else {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(owner_hero_id != hero_id) {
        LogMsg("%s, line %d, hero_id not match. hero_id=[%u], zhuangbei_id=[%llu]"
                        , __FILE__, __LINE__, hero_id, zhuangbei_id);
        
        return false;
    }
    if(zb_level < Qianghua_zhuangbei_min_level) {
        LogMsg("%s, line %d, zhuangbei_level too low. zhuangbei_id=[%llu]"
                        , __FILE__, __LINE__, zhuangbei_id);
        
        return false;
    }
    if(qianghua_count == 0 || qianghua_count == keep_count) {
        LogMsg("%s, line %d, qianghua_count=[%u] keep_count=[%u]"
                        , __FILE__, __LINE__, qianghua_count, keep_count);
        
        return false;
    }
    if(keep_count > (getQianghuaMaxTime((ZhuangbeiType)zb_type, (ZhuangbeiColour)zb_colour, zb_level) -1)) {
        LogMsg("%s, line %d, keep_count=[%u] too more"
                        , __FILE__, __LINE__, keep_count);
        
        return false;
    }

    int gold_need = 0;
    if (keep_count > Huitui_zhuangbei_keep_max) { //查询余额
        int gold_balance = getItemCountInTeam(hero_id, ItemsType_Gold);
        gold_need = CS::HuituiZhuangbeiNeedGold(keep_count);
        if(gold_balance < gold_need) { //金币不足
            LogMsg("%s, line %d, hero[%u], gold[%u] is not enough. "
                , __FILE__, __LINE__, hero_id, gold_balance);
            return false;
        }
    }

    //保存需要keep的强化信息
    std::vector<unsigned int> level_keep_vec;
    std::vector<unsigned int> percent_keep_vec;
    for(int i=0; i<keep_count; ++i)
    {
        if(id_arr[i] > qh_level_vec.size()) {
            LogMsg("%s, line %d, qianghua_id not exist.zhuangbei_id=[%llu] qianghua_id=[%u]"
                , __FILE__, __LINE__, zhuangbei_id, (int)id_arr[i]);
            return false;
        }

        /* 2014.05.21 去掉熔金石金星强化
        if(qh_level_vec[id_arr[i]-1] > QianghuaLevel_jin) {
            LogMsg("%s, line %d, zhuangbei_id=[%llu] qianghua_id=[%u], qinghua_level=[%u] "
                , __FILE__, __LINE__, zhuangbei_id, (int)id_arr[i], qh_level_vec[id_arr[i]-1]);
            return false;
        }
        */

        level_keep_vec.push_back(qh_level_vec[id_arr[i]-1]);
        percent_keep_vec.push_back(qh_percent_vec[id_arr[i]-1]);
    }

    /* 2014.05.21 去掉熔金石金星强化
    //追加直接金星强化的
    for(int i=0; i<qh_level_vec.size(); i++) {
        if(qh_level_vec[i] == QianghuaLevel_jin_special) {
            level_keep_vec.push_back(qh_level_vec[i]);
            percent_keep_vec.push_back(qh_percent_vec[i]);
        }
    }
    */

    
    { //回退
        std::string level_percent_str;

        for(int i=0; i<level_keep_vec.size(); ++i)
        {
            char str[64];
            sprintf(str, ", qianghua_level_%u=%u, qianghua_percent_%u=%u "
                , i+1, level_keep_vec[i], i+1, percent_keep_vec[i]);

            level_percent_str += str;
        }
        
        
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list "
            "set qianghua_count=%u %s "
            "where zhuangbei_id=%llu "
            , (unsigned int)level_keep_vec.size(), level_percent_str.c_str()
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if (keep_count > Huitui_zhuangbei_keep_max) { //扣钱
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , gold_need, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }

    return true;
}


bool ProcServerThread::CheckAndChaijieZhuangbei(unsigned int hero_id, std::vector<unsigned long long> zb_vec, 
    std::vector<ItemInfo>& item_vec, std::vector<ItemInfo>& re_item_vec)
{
    item_vec.clear();
    re_item_vec.clear();
    
    /* 2014年03月12日 移除拆解需要的银币
    //获取现有silver数量
    unsigned silver_total_count = getItemCountInTeam(hero_id, ItemsType_Silver);
    */
        
    //逐个检查装备
    //unsigned silver_need_count = 0;
    for(int i=0; i<zb_vec.size(); ++i)
    {
        //
        unsigned int owner_hero_id = 0;
        unsigned int zhuangbei_hero_id = 0;
        unsigned int zhuangbei_type = 0;
        unsigned int zhuangbei_colour = 0;
        unsigned int zhuangbei_level = 0;
        unsigned int baoshi_type_1 = 0;
        unsigned int baoshi_type_2 = 0;
        unsigned int baoshi_type_3 = 0;
        unsigned int qianghua_cailiao_total_count = 0;
        unsigned int qianghua_cailiao_goldstar_count = 0;
        {
            char sql[1024];
            sprintf(sql, "select owner_hero_id, zhuangbei_hero_id, zhuangbei_type "
                " , zhuangbei_level, zhuangbei_colour "
                " , diamond_type_1, diamond_type_2, diamond_type_3 "
                " , qianghua_cailiao_total_count"
                " , qianghua_cailiao_goldstar_count"
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu"
                , zb_vec[i]);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                    zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                    zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                    zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                    baoshi_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                    baoshi_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                    baoshi_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));
                    qianghua_cailiao_total_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_total_count"));
                    qianghua_cailiao_goldstar_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_goldstar_count"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                            , __FILE__, __LINE__, zb_vec[i]);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

            if(owner_hero_id != hero_id)
            {
                LogMsg("%s, line %d, . hero_id=[%u], zhuangbei_id=[%llu]"
                                , __FILE__, __LINE__, hero_id, zb_vec[i]);
                
                return false;
            }
        }

        if(zhuangbei_colour == ZhuangbeiColour_Chuanqi) {//传奇装备不能分解
            LogMsg("%s, line %d, zhuangbei_id=[%llu] level=[%u], zhuangbei_colour[%u]"
                                , __FILE__, __LINE__, zb_vec[i], zhuangbei_level, zhuangbei_colour);
                
            return false;
        }
        
        if(zhuangbei_hero_id != 0) { //装备在角色身上的不能拆解
            LogMsg("%s, line %d, zhuangbei_id=[%llu] level=[%u], zhuangbei_hero_id[%u]"
                                , __FILE__, __LINE__, zb_vec[i], zhuangbei_level, zhuangbei_hero_id);
                
            return false;
        }
        
        /* 2014年03月12日 移除拆解需要的银币
        silver_need_count += CS::ChaijieZhuangbeiNeedSilver(zhuangbei_level, zhuangbei_colour);
        if(silver_total_count < silver_need_count)
        {
            LogMsg("%s, line %d, zhuangbei_id=[%llu] level=[%u], silver_need_count=[%u]"
                                , __FILE__, __LINE__, zb_vec[i], zhuangbei_level, silver_need_count);
                
            return false;
        }
        */

        //先获得拆解物品
        {
            //拆解装备本身的获得的材料
            std::vector<ItemInfo> tmp_item_vec;
            ItemsFromChaijieZhuangbei(zhuangbei_type, zhuangbei_level, zhuangbei_colour, tmp_item_vec);

            //扔到拆解道具输出容器里面
            for(int i=0; i<tmp_item_vec.size(); ++i) {
                bool b_not_found = true;
                for(int j=0; j<item_vec.size(); ++j) {
                    if(tmp_item_vec[i].type == item_vec[j].type) {
                        item_vec[j].count += tmp_item_vec[i].count;
                        b_not_found = false;
                        break;
                    }
                }

                if(b_not_found) { //没有找到 直接新加一个
                    item_vec.push_back(tmp_item_vec[i]);
                }
            }


            //返还装备使用了的材料
            std::vector<ItemInfo> re_tmp_item_vec;
            if(qianghua_cailiao_total_count > 0) { //装备强化后的强化粉
                ItemInfo info;
                info.type = ItemsType_QianghuaNormal;
                info.count = qianghua_cailiao_total_count;
                re_tmp_item_vec.push_back(info);
            }

            //宝石
            if(baoshi_type_1 > 0) {
                ItemInfo item;
                item.type = baoshi_type_1;
                item.count = 1;
                re_tmp_item_vec.push_back(item);
            }
            if(baoshi_type_2 > 0) {
                ItemInfo item;
                item.type = baoshi_type_2;
                item.count = 1;
                re_tmp_item_vec.push_back(item);
            }
            if(baoshi_type_3 > 0) {
                ItemInfo item;
                item.type = baoshi_type_3;
                item.count = 1;
                re_tmp_item_vec.push_back(item);
            }

            /* 2014.05.29 取消直接金星材料熔金石
            //直接金星材料的数量
            if(qianghua_cailiao_goldstar_count > 0) {
                ItemInfo item;
                item.type = ItemsType_GoldStar_Qianghua;
                item.count = qianghua_cailiao_goldstar_count;
                item_vec.insert(item_vec.end(), item);
            }
            */

            //扔到返还道具输出容器里面
            for(int i=0; i<re_tmp_item_vec.size(); ++i) {
                bool b_not_found = true;
                for(int j=0; j<re_item_vec.size(); ++j) {
                    if(re_tmp_item_vec[i].type == re_item_vec[j].type) {
                        re_item_vec[j].count += re_tmp_item_vec[i].count;
                        b_not_found = false;
                        break;
                    }
                }

                if(b_not_found) { //没有找到 直接新加一个
                    re_item_vec.push_back(re_tmp_item_vec[i]);
                }
            }
        }
    }

    //先把拆解所得的材料入库
    for(int i=0; i<item_vec.size(); ++i) {
        ObtainItem(hero_id, item_vec[i].type, item_vec[i].count);
    }
    
    //先把返还的材料入库
    for(int i=0; i<re_item_vec.size(); ++i) {
        ObtainItem(hero_id, re_item_vec[i].type, re_item_vec[i].count);
    }

    //销毁装备
    for(int i=0; i<zb_vec.size(); ++i) {
        char sql[1024];
        sprintf(sql, "delete from hellgate.zhuangbei_list where zhuangbei_id=%llu"
            , zb_vec[i]);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    /* 2014年03月12日 移除拆解需要的银币
    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need_count, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */

    return true;
}

void ProcServerThread::ItemsFromChaijieZhuangbei(
    unsigned int zhuangbei_type, unsigned int zhuangbei_level, unsigned int zhuangbei_colour,
    std::vector<ItemInfo> &item_vec)
{
    return CS::getItemsForChaijieZhuangbei(zhuangbei_level, zhuangbei_colour, item_vec);
}


bool ProcServerThread::CheckAndZhuangkong(unsigned int hero_id,unsigned long long zhuangbei_id)
{
    //判断合法性
    unsigned int owner_hero_id = 0;
    unsigned int zhuangbei_type = 0;
    unsigned int hole_count = 0;
    unsigned int zhuangbei_level = 0;
    unsigned int zhuangbei_colour = ZhuangbeiColour_Baizhuang;
    {
        char sql[1024];
        sprintf(sql, "select owner_hero_id, zhuangbei_type "
            " , zhuangbei_level, zhuangbei_colour, hole"
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_list.zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                hole_count = atoi(Mysql_Thread_Conn->GetField("hole"));
                zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        if(owner_hero_id != hero_id || !canZBTypeBeZhuangkong(zhuangbei_type, hole_count))
        {
            LogMsg("%s, line %d, . hero_id=[%u], zhuangbei_id=[%llu], zhuangbei_type=[%u], hole_count=[%u]"
                            , __FILE__, __LINE__, hero_id, zhuangbei_id, zhuangbei_type, hole_count);
            
            return false;
        }
    }

    //获取现有gold数量
    unsigned gold_count = getItemCountInTeam(hero_id, ItemsType_Gold);
    unsigned gold_need = ZhuangkongNeedGold(zhuangbei_level, zhuangbei_colour);
    if(gold_count < gold_need)
    {
        LogMsg("%s, line %d, zhuangbei_id=[%llu] level=[%u], gold_count=[%u]"
                            , __FILE__, __LINE__, zhuangbei_id, zhuangbei_level, gold_count);
            
        return false;
    }

    //先转孔
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list "
            " set hole=hole+1"
            " where zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , gold_need, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

bool ProcServerThread::canZBTypeBeZhuangkong(unsigned int zhuangbei_type,unsigned int hole_count)
{
    int hole_max = 0;
    switch(zhuangbei_type)
    {
        case ZhuangbeiType_DanshouJian:
        case ZhuangbeiType_ShuangshouBishou:
        case ZhuangbeiType_ShuangshouFu:
        case ZhuangbeiType_DanshouFazhang:
        case ZhuangbeiType_ShuangshouFazhang:
        case ZhuangbeiType_Gong:
        case ZhuangbeiType_Faqi:
        case ZhuangbeiType_Dunpai:
        //case ZhuangbeiType_Toukui:
        case ZhuangbeiType_Hushenfu:
        //case ZhuangbeiType_Xuezi:
        case ZhuangbeiType_Jiezhi:
            hole_max = 1;
            break;
        case ZhuangbeiType_KuijiaZhong:
        case ZhuangbeiType_KuijiaQin:
            hole_max = 3;
            break;
        //case ZhuangbeiType_KuziZhong:
        //case ZhuangbeiType_KuziQin:
            hole_max = 2;
            break;
        default:
            LogMsg("%s, line %d, zhuangbei_type[%u] what is the hell"
                        , __FILE__, __LINE__, zhuangbei_type);
            return false;
    }

    if(hole_count == hole_max)
    {
        return false;
    }
    if(hole_count > hole_max)
    {
        LogMsg("%s, line %d, zhuangbei_type[%u] what is the hell"
                        , __FILE__, __LINE__, zhuangbei_type);
        return false;
    }

    return true;
}

bool ProcServerThread::CheckAndXiangbaoshi(unsigned int hero_id
    ,unsigned long long zhuangbei_id,unsigned int baoshi_type)
{
    //判断装备合法性
    unsigned int zhuangbei_hero_id = 0;
    unsigned int owner_hero_id = 0;
    unsigned int hole_count = 0;
    unsigned int diamond_type_1 = 0;
    unsigned int diamond_type_2 = 0;
    unsigned int diamond_type_3 = 0;
    unsigned int zhuangbei_level = 0;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_hero_id, owner_hero_id, zhuangbei_level, "
            " hole, diamond_type_1, diamond_type_2, diamond_type_3"
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_list.zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                hole_count = atoi(Mysql_Thread_Conn->GetField("hole"));
                diamond_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                diamond_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                diamond_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        int diamond_count = 0;
        if(diamond_type_1 > 0)
        {
            diamond_count++;
        }
        if(diamond_type_2 > 0)
        {
            diamond_count++;
        }
        if(diamond_type_3 > 0)
        {
            diamond_count++;
        }

        if(owner_hero_id != hero_id || diamond_count>=hole_count)
        {
            LogMsg("%s, line %d, . hero_id=[%u], zhuangbei_id=[%llu], hole_count=[%u], diamond_count=[%u]"
                            , __FILE__, __LINE__, hero_id, zhuangbei_id, hole_count, diamond_count);
            
            return false;
        }
    }

    /* 2014年03月03日 移除镶嵌宝石需要的银币
    //获取现有silver数量
    unsigned silver_count = getItemCountInTeam(hero_id,ItemsType_Silver);
    //
    int silver_need = CS::XiangbaoshiNeedSilver(zhuangbei_level, baoshi_type);
    if(silver_count < silver_need)
    {
        LogMsg("%s, line %d, level=[%u], baoshi_type=[%u], silver_count=[%u]"
                            , __FILE__, __LINE__, zhuangbei_level, baoshi_type, silver_count);
            
        return false;
    }
    */

    //判断宝石是否存在
    unsigned int baoshi_count = getItemCountInTeam(hero_id,baoshi_type);
    if(baoshi_count == 0)
    {
        LogMsg("%s, line %d, hero_id=[%u], baoshi_type=[%u]"
            , __FILE__, __LINE__, hero_id, baoshi_type);
            
        return false;
    }
    

    //先镶嵌
    if(diamond_type_1 == 0)
    {
        diamond_type_1 = baoshi_type;
    }
    else if(diamond_type_2 == 0)
    {
        diamond_type_2 = baoshi_type;
    }
    else if(diamond_type_3 == 0)
    {
        diamond_type_3 = baoshi_type;
    }
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list "
            " set diamond_type_1=%u, diamond_type_2=%u, diamond_type_3=%u"
            " where zhuangbei_id=%llu"
            , diamond_type_1, diamond_type_2, diamond_type_3
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    /* 2014年03月03日 移除镶嵌宝石需要的银币
    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */
    
    //再扣宝石
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-1 "
            " where hero_id=%u and item_type=%u"
            , hero_id, baoshi_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }

    return true;

}

bool ProcServerThread::CheckAndHechengBaoshi(unsigned int hero_id
    ,unsigned int baoshi_type, int count)
{
    

    //获取现有gold数量
    unsigned gold_count = getItemCountInTeam(hero_id, ItemsType_Gold);

    //
    int gold_need = CS::HechengBaoshiNeedGold(baoshi_type) * count;
    if(gold_count < gold_need)
    {
        LogMsg("%s, line %d, baoshi_type=[%u], gold_count=[%u]"
                            , __FILE__, __LINE__, baoshi_type, gold_count);
            
        return false;
    }

    //判断宝石是否足够
    unsigned int baoshi_need_count = CS::HechengBaoshiNeedBaoshiCount(baoshi_type) * count;
    unsigned int baoshi_need_type = CS::HechengBaoshiNeedBaoshiType(baoshi_type);
    unsigned int baoshi_total_count = getItemCountInTeam(hero_id, baoshi_need_type);
    if(baoshi_total_count < baoshi_need_count)
    {
        LogMsg("%s, line %d, hero_id=[%u], baoshi_type=[%u]"
            , __FILE__, __LINE__, hero_id, baoshi_type);
            
        return false;
    }
    

    //先合成
    ObtainItem(hero_id,baoshi_type,count);

    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , gold_need, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //再扣宝石
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , baoshi_need_count, hero_id, baoshi_need_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

unsigned int ProcServerThread::ZhuangkongNeedGold(
    unsigned int zhuangbei_level, unsigned int zhuangbei_colour)
{
    unsigned int gold = zhuangbei_level;
    switch(zhuangbei_colour)
    {
        case ZhuangbeiColour_Xiyou:
            gold *= 2;
            break;
        case ZhuangbeiColour_Chuanqi:
            gold *= 4;
    }

    return gold;
}


bool ProcServerThread::CheckAndChaibaoshi(unsigned int hero_id,unsigned long long zhuangbei_id)
{
    
    //判断合法性
    unsigned int zhuangbei_hero_id = 0;
    unsigned int owner_hero_id = 0;
    unsigned int hole_count = 0;
    unsigned int diamond_type_1 = 0;
    unsigned int diamond_type_2 = 0;
    unsigned int diamond_type_3 = 0;
    unsigned int zhuangbei_level = 0;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_hero_id, owner_hero_id, zhuangbei_level, "
            " hole, diamond_type_1, diamond_type_2, diamond_type_3"
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_list.zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                owner_hero_id = atoi(Mysql_Thread_Conn->GetField("owner_hero_id"));
                zhuangbei_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                hole_count = atoi(Mysql_Thread_Conn->GetField("hole"));
                diamond_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                diamond_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                diamond_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));
            }
            else
            {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist"
                        , __FILE__, __LINE__, zhuangbei_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        int diamond_count = 0;
        if(diamond_type_1 > 0)
        {
            diamond_count++;
        }
        if(diamond_type_2 > 0)
        {
            diamond_count++;
        }
        if(diamond_type_3 > 0)
        {
            diamond_count++;
        }

        if(owner_hero_id != hero_id || diamond_count == 0)
        {
            LogMsg("%s, line %d, . hero_id=[%u], zhuangbei_id=[%llu], hole_count=[%u], diamond_count=[%u]"
                            , __FILE__, __LINE__, hero_id, zhuangbei_id, hole_count, diamond_count);
            
            return false;
        }
    }

    /* 2014年03月03日 移除拆卸宝石需要的银币
    //获取现有silver数量
    unsigned silver_count = getItemCountInTeam(hero_id,ItemsType_Silver);

    //
    int silver_need;
    if(diamond_type_1 > 0)
    {
        silver_need = CS::XiangbaoshiNeedSilver(zhuangbei_level, diamond_type_1);
    }
    if(diamond_type_2 > 0)
    {
        silver_need += CS::XiangbaoshiNeedSilver(zhuangbei_level, diamond_type_2);
    }
    if(diamond_type_3 > 0)
    {
        silver_need += CS::XiangbaoshiNeedSilver(zhuangbei_level, diamond_type_3);
    }
    if(silver_count < silver_need)
    {
        LogMsg("%s, line %d, level=[%u], silver_count=[%u]"
                            , __FILE__, __LINE__, zhuangbei_level, silver_count);
            
        return false;
    }
    */

    //先得到宝石
    if(diamond_type_1 > 0)
    {
        ObtainItem(hero_id, diamond_type_1, 1);
    }
    if(diamond_type_2 > 0)
    {
        ObtainItem(hero_id, diamond_type_2, 1);
    }
    if(diamond_type_3 > 0)
    {
        ObtainItem(hero_id, diamond_type_3, 1);
    }

    /* 2014年03月03日 移除拆卸宝石需要的银币
    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */

    //拆宝石
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list "
            " set diamond_type_1=0, diamond_type_2=0, diamond_type_3=0"
            " where zhuangbei_id=%llu"
            , zhuangbei_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }

    return true;
}


bool ProcServerThread::DeductItem(unsigned int hero_id,unsigned int item_type,unsigned int item_count)
{
    //
    unsigned int balance_count = 0;
    {
        char sql[1024];
        sprintf(sql, "select item_count from hellgate.items_in_team "
            " where hero_id=%u and item_type=%u"
            , hero_id, item_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                balance_count = atoi(Mysql_Thread_Conn->GetField("item_count"));
            }
            else {
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(balance_count < item_count) {
        return false;
    }
    
    { //扣除道具
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team "
            " set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , item_count, hero_id, item_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::ObtainItem(unsigned int hero_id,unsigned int item_type,unsigned int item_count)
{
    //
    bool type_exist = false;
    {
        char sql[1024];
        sprintf(sql, "select item_count from hellgate.items_in_team "
            " where hero_id=%u and item_type=%u"
            , hero_id, item_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!type_exist)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.items_in_team "
            " set hero_id=%u, item_type=%u, item_count=%u"
            , hero_id, item_type, item_count);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team "
            " set item_count=item_count+%u "
            " where hero_id=%u and item_type=%u"
            , item_count, hero_id, item_type);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

void ProcServerThread::ObtainItemSuipian(unsigned int hero_id
    ,unsigned int item_type,unsigned int suipian_id,unsigned int suipian_count)
{
    //
    bool type_exist = false;
    {
        char sql[1024];
        sprintf(sql, "select suipian_count from hellgate.item_suipian_in_team "
            " where hero_id=%u and item_type=%u and suipian_id=%u"
            , hero_id, item_type, suipian_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!type_exist)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.item_suipian_in_team "
            " set hero_id=%u, item_type=%u, suipian_id=%u, suipian_count=%u"
            , hero_id, item_type, suipian_id, suipian_count);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        char sql[1024];
        sprintf(sql, "update hellgate.item_suipian_in_team "
            " set suipian_count=suipian_count+%u "
            " where hero_id=%u and item_type=%u and suipian_id=%u"
            , suipian_count, hero_id, item_type, suipian_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

unsigned long long ProcServerThread::ObtainZhuangbei(unsigned int hero_id
    , unsigned int zhuangbei_name_id, __ZhuangbeiDetail detail)
{
    //先找zhuangbei_id最大值
    unsigned long long max_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select max(zhuangbei_id) max_id from hellgate.zhuangbei_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                max_id = atoll(Mysql_Thread_Conn->GetField("max_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    max_id++;

    //
    {
        std::string attr_str;
        char str[64];
        for(int i=0; i<detail.attr_vec.size(); ++i) {
            sprintf(str, "attr_type_%d=%u, attr_value_%d=%u, cuiqu_suc_ratio_%d=%u, "
                , i+1, detail.attr_vec[i].attr_type, i+1, detail.attr_vec[i].attr_value
                , i+1, detail.attr_vec[i].cuiqu_suc_ratio);

            attr_str += str;
        }

        std::string purify_str;
        sprintf(str, "purify_hole=%u, ", (unsigned int)detail.purify_attr.size());
        purify_str += str;
        for(int i=0; i<detail.purify_attr.size(); ++i) {
            sprintf(str, "purify_attr_type_%d=%u, purify_attr_value_%d=%u, "
                , i+1, detail.purify_attr[i].attr_type, i+1, detail.purify_attr[i].attr_value);
            purify_str += str;
        }
        
        
        char sql[2048];
        sprintf(sql, "insert into hellgate.zhuangbei_list set "
            " zhuangbei_id=%llu, zhuangbei_name_id=%u, owner_hero_id=%u, "
            " zhuangbei_hero_id=0, is_unlocked=%u, "
            " hole=%u, diamond_type_1=0, diamond_type_2=0, diamond_type_3=0, "
            " gongji_min=%u, gongji_max=%u, hujia=%u, "
            " attr_count=%u, "
            " %s "
            " %s "
            " qianghua_count=0, has_fumo=0"
            , max_id, zhuangbei_name_id, hero_id
            , detail.is_unlocked
            , detail.hole
            , detail.gongji_min, detail.gongji_max, detail.hujia
            , (unsigned int)detail.attr_vec.size()
            , attr_str.c_str()
            , purify_str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return max_id;
}

void ProcServerThread::ObtainZhuangbeiSuipian(unsigned int hero_id
    ,unsigned int zb_group_id,unsigned int suipian_id,unsigned int suipian_count)
{
    //
    bool type_exist = false;
    {
        char sql[1024];
        sprintf(sql, "select suipian_count from hellgate.shenbing_suipian_in_team "
            " where hero_id=%u and zb_group_id=%u and suipian_id=%u"
            , hero_id, zb_group_id, suipian_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!type_exist)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.shenbing_suipian_in_team "
            " set hero_id=%u, zb_group_id=%u, suipian_id=%u, suipian_count=%u"
            , hero_id, zb_group_id, suipian_id, suipian_count);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        char sql[1024];
        sprintf(sql, "update hellgate.shenbing_suipian_in_team "
            " set suipian_count=suipian_count+%u "
            " where hero_id=%u and zb_group_id=%u and suipian_id=%u"
            , suipian_count, hero_id, zb_group_id, suipian_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::ObtainGiftBag(unsigned int hero_id, unsigned int gift_id, unsigned int gift_count)
{    //
    bool type_exist = false;
    {
        char sql[1024];
        sprintf(sql, "select gift_bag_count from hellgate.gift_bag_hero "
            " where hero_id=%u and gift_bag_id=%u"
            , hero_id, gift_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                type_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!type_exist)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.gift_bag_hero "
            " set hero_id=%u, gift_bag_id=%u, gift_bag_count=%u"
            , hero_id, gift_id, gift_count);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        char sql[1024];
        sprintf(sql, "update hellgate.gift_bag_hero "
            " set gift_bag_count=gift_bag_count+%u "
            " where hero_id=%u and gift_bag_id=%u"
            , gift_count, hero_id, gift_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


bool ProcServerThread::checkAndCuiqu(unsigned int hero_id
    , unsigned long long zb_id, AttrType attr_type, unsigned int attr_value, bool is_fumo_attr
    , bool& cuiqu_suc, unsigned int& zb_type, unsigned int& jinghua_level)
{
    //
    cuiqu_suc = false;
    
    __ZhuangbeiDetail zb_detail;
    unsigned int owner_id;
    if(!getZhuangbeiDetail(zb_id,owner_id,zb_detail))
    {
        LogMsg("%s, line %d, zhuangbei_id not exist . [%llu]"
                        , __FILE__, __LINE__, zb_id);
        return false;
    }

    zb_type = zb_detail.zhuangbei_type;

    if(hero_id != owner_id)
    {
        LogMsg("%s, line %d, zhuangbei_id. [%llu]"
                        , __FILE__, __LINE__, zb_id);
        return false;
    }

    //等级是否合符要求
    if(zb_detail.zhuangbei_level < Cuiqu_zhuangbei_min_level)
    {
        LogMsg("%s, line %d, zhuangbei_id level too low. [%llu]"
                        , __FILE__, __LINE__, zb_id);
        return false;
    }

    //已经装备在角色身上的装不能萃取
    if(zb_detail.zhuangbei_hero_id != 0)
    {
        LogMsg("%s, line %d, zhuangbei_id weared. [%llu]"
                        , __FILE__, __LINE__, zb_id);
        return false;
    }
    if(!CS::isAttrTypeZBTypeCanCuiqu((ZhuangbeiType)zb_detail.zhuangbei_type,attr_type))
    {
        LogMsg("%s, line %d, zhuangbei_type[%u] attr_type[%u] not match"
                        , __FILE__, __LINE__, zb_detail.zhuangbei_type, attr_type);
        return false;
    }

    //判断属性是否真实
    unsigned int cuiqu_ratio = 0;
    if(is_fumo_attr)
    {
        cuiqu_ratio = zb_detail.fumo_attr.cuiqu_suc_ratio;
        
        if(zb_detail.fumo_attr.attr_type != attr_type
            || zb_detail.fumo_attr.attr_value != attr_value)
        {
            LogMsg("%s, line %d, zhuangbei_id attr type value not match. [%llu]"
                        , __FILE__, __LINE__, zb_id);
            return false;
        }
    }
    else
    {
        int i=0;
        for(; i<zb_detail.attr_vec.size(); ++i)
        {
            if(zb_detail.attr_vec[i].attr_type == attr_type
                && zb_detail.attr_vec[i].attr_value == attr_value)
            {
                cuiqu_ratio = zb_detail.attr_vec[i].cuiqu_suc_ratio;
                break;
            }
        }
        if(i == zb_detail.attr_vec.size())
        {
            LogMsg("%s, line %d, zhuangbei_id attr type value not match. [%llu]"
                        , __FILE__, __LINE__, zb_id);
            return false;
        }
    }

    //随机
    int val = Utl::auto_random()%100;
    if((val-=cuiqu_ratio) >= 0)
    {
        cuiqu_suc = false;

        //销毁装备
        destroyZhuangbei(zb_id);
        
        return true;
    }
    cuiqu_suc = true;
    zb_type = zb_detail.zhuangbei_type;
    
    //
    jinghua_level = genZBAttrCuiquLevel((ZhuangbeiType)zb_type, zb_detail.zhuangbei_level,attr_type);

    //入库
    bool type_exist = false;
    {
        char sql[1024];
        sprintf(sql, "select jh_count from hellgate.mofa_jinghua_in_team "
            " where hero_id=%u and zb_type=%u and attr_type=%u and jh_level=%u"
            , hero_id, zb_type, attr_type, jinghua_level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!type_exist)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.mofa_jinghua_in_team "
            " set hero_id=%u, zb_type=%u, attr_type=%u, jh_level=%u, jh_count=1"
            , hero_id, zb_type, attr_type, jinghua_level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        char sql[1024];
        sprintf(sql, "update hellgate.mofa_jinghua_in_team "
            " set jh_count=jh_count+1 "
            " where hero_id=%u and zb_type=%u and attr_type=%u and jh_level=%u"
            , hero_id, zb_type, attr_type, jinghua_level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //销毁装备
    destroyZhuangbei(zb_id);
    return true;
}

bool ProcServerThread::checkAndFumo(unsigned int hero_id
    ,unsigned long long zb_id,MofaJinghua jinghua,bool & fm_suc,ZBAttr & new_fm_attr)
{
    //
    fm_suc = false;
    
    __ZhuangbeiDetail detail;
    unsigned int owner_id = 0;
    if(!getZhuangbeiDetail(zb_id,owner_id,detail))
    {
        
        return false;
    }
    if(owner_id != hero_id)
    {
        return false;
    }
    if(jinghua.zb_type != detail.zhuangbei_type)
    {
        return false;
    }
    //等级是否合符要求
    if(detail.zhuangbei_level < Cuiqu_zhuangbei_min_level)
    {
        return false;
    }
    if(!CS::isAttrTypeZBTypeCanCuiqu((ZhuangbeiType)detail.zhuangbei_type,(AttrType)jinghua.attr_type))
    {
        LogMsg("%s, line %d, zhuangbei_type[%u] attr_type[%u] not match"
                        , __FILE__, __LINE__, detail.zhuangbei_type, jinghua.attr_type);
        return false;
    }
    
    int jinghua_count = 0;
    {
        char sql[1024];
        sprintf(sql, "select jh_count from hellgate.mofa_jinghua_in_team "
            " where hero_id=%u and zb_type=%u and attr_type=%u and jh_level=%u"
            , hero_id, jinghua.zb_type, jinghua.attr_type, jinghua.level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                jinghua_count=atoi(Mysql_Thread_Conn->GetField("jh_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(jinghua_count == 0)
    {
        return false;
    }

    unsigned int new_fm_value = genZBAttrValueFumo((ZhuangbeiType)jinghua.zb_type
        , detail.zhuangbei_level,(AttrType)jinghua.attr_type,jinghua.level);
    if(detail.has_fumo && detail.fumo_attr.attr_type==jinghua.attr_type 
        && new_fm_value<=detail.fumo_attr.attr_value)
    {
        //附魔效果未超过当前
        fm_suc = false;

        //扣精华
        {
            char sql[1024];
            sprintf(sql, "update hellgate.mofa_jinghua_in_team "
                " set jh_count=%d "
                " where hero_id=%u and zb_type=%u and attr_type=%u and jh_level=%u"
                , jinghua_count-1
                , hero_id, jinghua.zb_type, jinghua.attr_type, jinghua.level);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        return true;
    }

    new_fm_attr.attr_type = jinghua.attr_type;
    new_fm_attr.attr_value = new_fm_value;
    new_fm_attr.cuiqu_suc_ratio = genZBAttrCuiquRatio(
        (ZhuangbeiType)jinghua.zb_type,(ZhuangbeiColour)detail.zhuangbei_colour,detail.zhuangbei_level
        , (AttrType)jinghua.attr_type, new_fm_value);

    //入库
    {
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list "
            "set has_fumo=1, fumo_attr_type=%u, fumo_attr_value=%u, fumo_attr_cuiqu_suc_ratio=%u "
            "where zhuangbei_id=%llu "
            , new_fm_attr.attr_type, new_fm_attr.attr_value, new_fm_attr.cuiqu_suc_ratio
            , zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    //扣精华
    {
        char sql[1024];
        sprintf(sql, "update hellgate.mofa_jinghua_in_team "
            " set jh_count=%d "
            " where hero_id=%u and zb_type=%u and attr_type=%u and jh_level=%u"
            , jinghua_count-1
            , hero_id, jinghua.zb_type, jinghua.attr_type, jinghua.level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    fm_suc = true;
    return true;
}



//生成萃取成功率
unsigned int ProcServerThread::genZBAttrCuiquRatio(ZhuangbeiType zb_type, ZhuangbeiColour zb_colour, unsigned int zb_level
    , AttrType attr_type, unsigned int attr_value)
{
    unsigned int level_1_ratio = 0;
    unsigned int level_2_ratio = 0;
    unsigned int level_3_ratio = 0;
    unsigned int level_4_ratio = 0;

    if(!CS::isAttrTypeZBTypeCanCuiqu(zb_type, attr_type))
    {
        return 0;
    }
    if(zb_level < Cuiqu_zhuangbei_min_level)
    {
        return 0;
    }
    
    getZBAttrCuiquLevelRatio(zb_level,level_1_ratio,level_2_ratio,level_3_ratio,level_4_ratio);

    int value_min = 0;
    int value_max = 0;
    
    unsigned int tmp_min = 0;
    unsigned int tmp_max = 0;
    CS::getMofaJinghuaAttrValue(zb_type, attr_type, 1, tmp_min, tmp_max);
    value_min += tmp_min*level_1_ratio;
    value_max += tmp_max*level_1_ratio;

    CS::getMofaJinghuaAttrValue(zb_type, attr_type, 2, tmp_min, tmp_max);
    value_min += tmp_min*level_2_ratio;
    value_max += tmp_max*level_2_ratio;

    CS::getMofaJinghuaAttrValue(zb_type, attr_type, 3, tmp_min, tmp_max);
    value_min += tmp_min*level_3_ratio;
    value_max += tmp_max*level_3_ratio;

    CS::getMofaJinghuaAttrValue(zb_type, attr_type, 4, tmp_min, tmp_max);
    value_min += tmp_min*level_4_ratio;
    value_max += tmp_max*level_4_ratio;

    value_min /= 100;
    value_max /= 100;

    //根据attr_value在min和max之间的位置决定概率
    if(attr_value <= value_min)
    {
        return 5; //最少5%
    }
    if(attr_value >= value_max)
    {
        return 95; //最多95%
    }
    float ratio = ((float)(attr_value-value_min))/((float)(value_max-value_min));
    
    unsigned int ret = ratio*100;
    if(ret < 5)
    {
        ret = 5;
    }
    if(ret > 95)
    {
        ret = 95;
    }

    return ret;
}
void ProcServerThread::getZBAttrCuiquLevelRatio(unsigned int zb_level
    , unsigned int& level_1_ratio, unsigned int& level_2_ratio
    , unsigned int& level_3_ratio, unsigned int& level_4_ratio)
{
    level_1_ratio = 0;
    level_2_ratio = 0;
    level_3_ratio = 0;
    level_4_ratio = 0;
    
    unsigned int ratio_matrix[23][4] 
        = {{100,  0,  0,  0},
           {100,  0,  0,  0},
           {100,  0,  0,  0},
           { 95,  5,  0,  0},
           { 90, 10,  0,  0},
           { 90, 10,  0,  0},
           { 85, 15,  0,  0},
           { 80, 20,  0,  0},
           { 75, 25,  0,  0},
           { 60, 40,  0,  0},
           { 50, 50,  0,  0},
           { 40, 60,  0,  0},
           { 20, 75,  5,  0},
           { 10, 80, 10,  0},
           {  0, 75, 25,  0},
           {  0, 70, 30,  0},
           {  0, 60, 40,  0},
           {  0, 55, 45,  0},
           {  0, 50, 50,  0},
           {  0, 40, 60,  0},
           {  0, 25, 75,  0},
           {  0, 10, 85,  5},
           {  0,  0, 85, 15}};


    if(zb_level < 8 || zb_level > 30)
    {
        //LogMsg("%s, line %d, fuck. zb_level=[%d]"
        //                , __FILE__, __LINE__, zb_level);
        return;
    }

    level_1_ratio = ratio_matrix[zb_level-8][0];
    level_2_ratio = ratio_matrix[zb_level-8][1];
    level_3_ratio = ratio_matrix[zb_level-8][2];
    level_4_ratio = ratio_matrix[zb_level-8][3];
}
unsigned int ProcServerThread::genZBAttrCuiquLevel(ZhuangbeiType zb_type, unsigned int zb_level
    , AttrType attr_type)
{
    if(attr_type == AttrType_baoji
        || attr_type == AttrType_baoshang
        || attr_type == AttrType_gedanglv)
    {
        //这几个只有1级
        return 1;
    }
    
    unsigned int level_1_ratio = 0;
    unsigned int level_2_ratio = 0;
    unsigned int level_3_ratio = 0;
    unsigned int level_4_ratio = 0;

    getZBAttrCuiquLevelRatio(zb_level,level_1_ratio,level_2_ratio,level_3_ratio,level_4_ratio);
    int ratio = Utl::auto_random()%100;
    if((ratio -= level_4_ratio) < 0)
    {
        return 4;
    }
    if((ratio -= level_3_ratio) < 0)
    {
        return 3;
    }
    if((ratio -= level_2_ratio) < 0)
    {
        return 2;
    }
    return 1;
}
unsigned int ProcServerThread::genZBAttrValueFumo(ZhuangbeiType zb_type, unsigned int zb_level
    , AttrType attr_type, unsigned int jinghua_level)
{
    unsigned int value_min, value_max;
    CS::getMofaJinghuaAttrValue(zb_type, attr_type,jinghua_level,value_min,value_max);

    if(value_min == 0 || value_max == 0 || (value_max < value_min))
    {
        return 0;
    }

    //以1/4为数学期望
    unsigned int miu = (value_max - value_min)/4 + value_min;
    
//正太分布方差
#define fumo_sigma 20

    return Utl::NormalRandom(miu,fumo_sigma,value_min,value_max);
}


//查询英雄是否第一次通关特殊关卡，需要掉落指定装备
//如果返回true，则表示是有指定掉落的
bool ProcServerThread::checkDiaoluoZBSpecialTaskFirstPass(unsigned int hero_id, unsigned int task_id
 , unsigned int& diaoluo_name_id, unsigned int& diaoluo_group_id)
{
    diaoluo_name_id = 0;
    diaoluo_group_id = 0;
    
    //只有固定的几个task有指定
    if(task_id!=1 && task_id!=3 && task_id!=4 && task_id!=5 && task_id!=8)
    {
        return false;
    }

    //查询，为true表示还没有掉 
    bool task_1_zb_diaoluo = false;
    bool task_3_zb_diaoluo = false;
    bool task_4_zb_diaoluo = false;
    bool task_5_zb_diaoluo = false;
    bool task_8_zb_diaoluo = false;
    bool has_record = true;
    {
        char sql[1024];
        sprintf(sql, "select task_1_zb_diaoluo, "
            " task_3_zb_diaoluo, task_4_zb_diaoluo, "
            " task_5_zb_diaoluo, task_8_zb_diaoluo "
            " from hellgate.hero_special_fuben_status "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                task_1_zb_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_1_zb_diaoluo"));
                task_3_zb_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_3_zb_diaoluo"));
                task_4_zb_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_4_zb_diaoluo"));
                task_5_zb_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_5_zb_diaoluo"));
                task_8_zb_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_8_zb_diaoluo"));
            }
            else
            {
                has_record = false;

                task_1_zb_diaoluo = true;
                task_3_zb_diaoluo = true;
                task_4_zb_diaoluo = true;
                task_5_zb_diaoluo = true;
                task_8_zb_diaoluo = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!has_record)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_special_fuben_status "
            " set hero_id=%u, task_1_zb_diaoluo=1, task_3_zb_diaoluo=1, task_4_zb_diaoluo=1, task_4_item_diaoluo=1, "
            " task_4_silver_diaoluo=1, task_5_zb_diaoluo=1, task_5_item_diaoluo=1, task_8_zb_diaoluo=1"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(task_id==1 && task_1_zb_diaoluo)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id,hero_info);

        if(hero_info.profession_id == Profession_Chike
            || hero_info.profession_id == Profession_Yemanren)
        {
            diaoluo_name_id = ZhuangBei_FirstDiaoluo_NameId_zhongkuijia;
            diaoluo_group_id = ZhuangBei_FirstDiaoluo_GroupId_zhongkuijia;
        }
        else if(hero_info.profession_id == Profession_Fashi)
        {
            diaoluo_name_id = ZhuangBei_FirstDiaoluo_NameId_qingkuijia;
            diaoluo_group_id = ZhuangBei_FirstDiaoluo_GroupId_qingkuijia;
        }
        else
        {
            LogMsg("%s, line %d, fuck hero_id[%d] prof[%d]."
                        , __FILE__, __LINE__, hero_id, hero_info.profession_id);
            return false;
        }

        task_1_zb_diaoluo = false;
    }
    else if(task_id==3 && task_3_zb_diaoluo)
    {
        diaoluo_name_id = ZhuangBei_Task3_NameId_zhongkuijia;
        diaoluo_group_id = ZhuangBei_Task3_GroupId_zhongkuijia;
        task_3_zb_diaoluo = false;
    }
    else if(task_id==4 && task_4_zb_diaoluo)
    {
        diaoluo_name_id = ZhuangBei_Task4_NameId_jian;
        diaoluo_group_id = ZhuangBei_Task4_GroupId_jian;
        task_4_zb_diaoluo = false;
    }
    /*else if(task_id==5 && task_5_zb_diaoluo)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id,hero_info);

        if(hero_info.profession_id == Profession_Chike
            || hero_info.profession_id == Profession_Yemanren)
        {
            diaoluo_name_id = ZhuangBei_FirstDaikong_NameId_zhongkuijia;
            diaoluo_group_id = ZhuangBei_FirstDaikong_GroupId_zhongkuijia;
        }
        else if(hero_info.profession_id == Profession_Fashi)
        {
            diaoluo_name_id = ZhuangBei_FirstDaikong_NameId_qingkuijia;
            diaoluo_group_id = ZhuangBei_FirstDaikong_GroupId_qingkuijia;
        }
        else
        {
            LogMsg("%s, line %d, fuck hero_id[%d] prof[%d]."
                        , __FILE__, __LINE__, hero_id, hero_info.profession_id);
            return false;
        }

        task_5_zb_diaoluo = false;
    }
    else if(task_id==8 && task_8_zb_diaoluo)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id,hero_info);

        if(hero_info.profession_id == Profession_Chike
            || hero_info.profession_id == Profession_Yemanren
            || hero_info.profession_id == Profession_Fashi)
        {
            diaoluo_name_id = ZhuangBei_FirstCuiqu_NameId_jian;
            diaoluo_group_id = ZhuangBei_FirstCuiqu_GroupId_jian;
        }
        else
        {
            LogMsg("%s, line %d, fuck hero_id[%d] prof[%d]."
                        , __FILE__, __LINE__, hero_id, hero_info.profession_id);
            return false;
        }

        task_8_zb_diaoluo = false;
    }*/
    else
    {
        return false;
    }

    //修改数据库状态
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_special_fuben_status set task_1_zb_diaoluo=%u, "
            " task_3_zb_diaoluo=%u, task_4_zb_diaoluo=%u, "
            " task_5_zb_diaoluo=%u, task_8_zb_diaoluo=%u "
            " where hero_id=%u"
            , (unsigned int)task_1_zb_diaoluo
            , (unsigned int)task_3_zb_diaoluo, (unsigned int)task_4_zb_diaoluo 
            , (unsigned int)task_5_zb_diaoluo, (unsigned int)task_8_zb_diaoluo 
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

//查询英雄是否第一次通关特殊关卡，需要掉落指定道具
//如果返回true，则表示是有指定掉落的
bool ProcServerThread::checkDiaoluoItemSpecialTaskFirstPass(unsigned int hero_id, unsigned int task_id
 , std::vector<ItemInfo>& item_vec)
{
    //只有固定的几个task有指定
    if(task_id!=4 && task_id!=5 && task_id!=7 && task_id!=12)
    {
        return false;
    }

    //查询，为true表示还没有掉 
    bool task_4_item_diaoluo = false;
    bool task_5_item_diaoluo = false;
    bool task_7_item_diaoluo = false;
    bool task_12_item_diaoluo = false;
    bool has_record = true;
    {
        char sql[1024];
        sprintf(sql, "select task_4_item_diaoluo, "
            " task_5_item_diaoluo, task_7_item_diaoluo, task_12_skillbook_diaoluo "
            " from hellgate.hero_special_fuben_status "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                task_4_item_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_4_item_diaoluo"));
                task_5_item_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_5_item_diaoluo"));
                task_7_item_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_7_item_diaoluo"));
                task_12_item_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_12_skillbook_diaoluo"));
            }
            else
            {
                has_record = false;

                task_4_item_diaoluo = true;
                task_5_item_diaoluo = true;
                task_7_item_diaoluo = true;
                task_12_item_diaoluo= true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!has_record)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_special_fuben_status "
            " set hero_id=%u, task_1_zb_diaoluo=1, task_3_zb_diaoluo=1, task_4_zb_diaoluo=1, task_4_item_diaoluo=1, "
            " task_4_silver_diaoluo=1, task_5_zb_diaoluo=1, task_5_item_diaoluo=1, task_7_item_diaoluo=1, "
            " task_8_zb_diaoluo=1, task_12_skillbook_diaoluo=1"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(task_id==4 && task_4_item_diaoluo)
    {
        ItemInfo item;
        
        item.type = ItemsType_QianghuaNormal;
        item.count = 60;
        item_vec.push_back(item);

        //item.type = ItemsType_QianghuaXiyou;
        //item.count = 30;
        //item_vec.push_back(item);
        
        
        /******************************************************************************
         ******************************* 剧情道具发放 *********************************
         ******************************************************************************/
        /* 2014.05.28 加入剧情道具工匠铁锤 暂时放入到背包不删除 
           以后把剧情道具的逻辑 独立出来的时候需要移除 */
        
        { //还未拿到铁锤 发一个
            ItemInfo item;
            item.type = ItemsType_Hammer;
            item.count = 1;
            item_vec.push_back(item);
        }
        
            
        /******************************************************************************
         ***************************** 剧情道具发放结束 *******************************
         ******************************************************************************/

        task_4_item_diaoluo = false;
    }
    /* 2014.03.20 去掉掉落宝石
    else if(task_id==5 && task_5_item_diaoluo)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id,hero_info);

        ItemInfo item;
        item.count = 1;

        if(hero_info.profession_id == Profession_Chike)
        {
            item.type = ItemsType_Baoshi_lv_1;
        }
        else if(hero_info.profession_id == Profession_Fashi)
        {
            item.type = ItemsType_Baoshi_huang_1;
        }
        else if(hero_info.profession_id == Profession_Yemanren)
        {
            item.type = ItemsType_Baoshi_hong_1;
        }
        else
        {
            LogMsg("%s, line %d, fuck hero_id[%d] prof[%d]."
                        , __FILE__, __LINE__, hero_id, hero_info.profession_id);
            return false;
        }

        //
        item_vec.push_back(item);

        task_5_item_diaoluo = false;
    }
    else if(task_id==7 && task_7_item_diaoluo)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id,hero_info);

        ItemInfo item;
        item.count = 3;

        if(hero_info.profession_id == Profession_Chike)
        {
            item.type = ItemsType_Baoshi_lv_1;
        }
        else if(hero_info.profession_id == Profession_Fashi)
        {
            item.type = ItemsType_Baoshi_huang_1;
        }
        else if(hero_info.profession_id == Profession_Yemanren)
        {
            item.type = ItemsType_Baoshi_hong_1;
        }
        else
        {
            LogMsg("%s, line %d, fuck hero_id[%d] prof[%d]."
                        , __FILE__, __LINE__, hero_id, hero_info.profession_id);
            return false;
        }

        //
        item_vec.push_back(item);

        task_7_item_diaoluo = false;
    }
    */
    /* 2014.03.15 当前版本去掉掉落技能书
    else if(task_id==12 && task_12_item_diaoluo)
    {
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id,hero_info);

        ItemInfo item;
        item.count = 1;

        
        if(hero_info.profession_id == Profession_Chike)
        {
            //stub
            return false;
            
            item.type = ItemsType_SkillBook_CiSha;
        }
        else if(hero_info.profession_id == Profession_Fashi)
        {
            item.type = ItemsType_SkillBook_LeiBao;
        }
        else if(hero_info.profession_id == Profession_Yemanren)
        {
            //stub
            return false;
            
            item.type = ItemsType_SkillBook_BanYueZhan;
        }
        else
        {
            LogMsg("%s, line %d, fuck hero_id[%d] prof[%d]."
                        , __FILE__, __LINE__, hero_id, hero_info.profession_id);
            return false;
        }

        //
        item_vec.push_back(item);

        task_12_item_diaoluo = false;
    }
    */
    else
    {
        return false;
    }

    //修改数据库状态
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_special_fuben_status "
            " set task_4_item_diaoluo=%u, task_5_item_diaoluo=%u, "
            " task_7_item_diaoluo=%u, task_12_skillbook_diaoluo=%u "
            " where hero_id=%u"
            ,(unsigned int)task_4_item_diaoluo,(unsigned int)task_5_item_diaoluo 
            , (unsigned int)task_7_item_diaoluo, (unsigned int)task_12_item_diaoluo 
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}

//查询英雄是否第一次通关特殊关卡，需要掉落指定银币
//如果返回true，则表示是有指定掉落的
bool ProcServerThread::checkDiaoluoSilverSpecialTaskFirstPass(unsigned int hero_id, unsigned int task_id
 , unsigned int& silver)
{
    silver = 0;
    
    //只有固定的几个task有指定
    if(task_id!=4)
    {
        return false;
    }

    //查询，为true表示还没有掉 
    bool task_4_silver_diaoluo = false;
    bool has_record = true;
    {
        char sql[1024];
        sprintf(sql, "select task_4_silver_diaoluo "
            " from hellgate.hero_special_fuben_status "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                task_4_silver_diaoluo = (bool)atoi(Mysql_Thread_Conn->GetField("task_4_silver_diaoluo"));
            }
            else
            {
                has_record = false;

                task_4_silver_diaoluo = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(!has_record)
    {
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_special_fuben_status "
            " set hero_id=%u, task_1_zb_diaoluo=1, task_3_zb_diaoluo=1, task_4_zb_diaoluo=1, task_4_item_diaoluo=1, "
            " task_4_silver_diaoluo=1, task_5_zb_diaoluo=1, task_5_item_diaoluo=1, task_8_zb_diaoluo=1"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(task_id==4 && task_4_silver_diaoluo)
    {
        silver = 2000;

        task_4_silver_diaoluo = false;
    }
    else
    {
        return false;
    }

    //修改数据库状态
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_special_fuben_status "
            " set task_4_silver_diaoluo=%u "
            " where hero_id=%u"
            ,(unsigned int)task_4_silver_diaoluo
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::get_grid_type(unsigned int grid_count, std::vector<unsigned int> &normal_monster_vec, 
    std::vector<unsigned int> &elite_monster_vec, std::vector<unsigned int> &box_vec)
{
    normal_monster_vec.clear();
    elite_monster_vec.clear();
    box_vec.clear();

    if(grid_count == 0) { //只有boss
        return ;
    }
    else if(grid_count == 4) { //第一关 演示关卡
        normal_monster_vec.push_back(1);
        box_vec.push_back(2);
        normal_monster_vec.push_back(3);
        return ;
    }

    std::vector<unsigned int> total_vec;
    for(int i=1; i<(grid_count +1); ++i) { //先填入格子编号
        total_vec.push_back(i);
    }

    int normal_monster_count = 0, elite_monster_count = 0, box_count = 0;
    if(grid_count == 16) {
        normal_monster_count = 6;
        elite_monster_count = 3;
        box_count = 3;
    }
    else if(grid_count == 9) {
        normal_monster_count = 4;
        elite_monster_count = 1;
        box_count = 2;
    }

    int index;
    for(int i=0; i<normal_monster_count; ++i) { //填入普通小怪格子
        index = Utl::auto_random()%total_vec.size();
        normal_monster_vec.push_back(total_vec[index]);
        total_vec.erase(total_vec.begin() +index);
    }

    for(int i=0; i<elite_monster_count; ++i) { //填入精英怪格子
        index = Utl::auto_random()%total_vec.size();
        elite_monster_vec.push_back(total_vec[index]);
        total_vec.erase(total_vec.begin() +index);
    }

    for(int i=0; i<box_count; ++i) { //填入宝箱格子
        index = Utl::auto_random()%total_vec.size();
        box_vec.push_back(total_vec[index]);
        total_vec.erase(total_vec.begin() +index);
    }

    return ;
}


struct _GuanqiaInfo
{
    unsigned int guanqia_id;
    unsigned int type;
    int weight;
};

void ProcServerThread::refreshChessBoard(unsigned int hero_id,unsigned int task_id)
{
    
    unsigned int maintask_last_actived  = 1;
    unsigned int maintask_status = TaskStatus_NotGot;
    { //首先获取主任务进度
        char sql[1024];
        sprintf(sql, "select maintask_last_actived, status "
            " from hellgate.hero_maintask_progress "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));
                maintask_status = atoi(Mysql_Thread_Conn->GetField("status"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    bool is_chess_board_exist = false;
    TaskGridStat boss_stat = TaskGridStat_PreFlop;
    { //查询是否有棋盘记录
        char sql[1024];

        sprintf(sql, "select grid_stat_0 "
            " from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                is_chess_board_exist = true;
                boss_stat = (TaskGridStat)atoi(Mysql_Thread_Conn->GetField("grid_stat_0"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(maintask_last_actived < task_id) {
        // 现在打得关卡大于最后激活关卡 错误
        LogMsg("%s, line %d, actived task[id], task[%u] error"
            , __FILE__, __LINE__, maintask_last_actived, task_id);
        assert(false);
    }
    else if(is_chess_board_exist && maintask_last_actived == task_id && maintask_status < TaskStatus_Finished) {
        // 还未完成第一次过关 不用刷新棋盘
        return;
    }

    if(!is_chess_board_exist) { //如果没有此任务棋盘则先创建
        char sql[1024];
        sprintf(sql, "insert into hellgate.task_chessboard "
            " set hero_id=%u, task_id=%u "
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //棋盘，最大棋盘9个格子
    //unsigned int chess_board[9] = {0,0,0,0,0,0,0,0,0};
    //棋盘，最大棋盘17个格子
    const int max_grid_count = 17;
    int chess_board[max_grid_count] = {0};
    memset(chess_board, 0, max_grid_count);

    //先得到任务的格子数量
    unsigned int grid_total_count = 0;
    unsigned int grid_count_heng = 0;
    unsigned int grid_count_shu = 0;
    CS::getTaskChessboardFormat(task_id, grid_count_heng, grid_count_shu);
    grid_total_count = grid_count_heng*grid_count_shu;


    //获取各种格子的位置
    std::vector<unsigned int> _normal_monster_vec, _elite_monster_vec, _box_vec;
    get_grid_type(grid_total_count, _normal_monster_vec, _elite_monster_vec, _box_vec);


    std::vector<_GuanqiaInfo> normal_vec, elite_vec, boss_vec;
    { //先查询各种各种关卡id
        char sql[1024];
        sprintf(sql, "select guanqia_id, task_type, weight "
            " from hellgate.task_template_test "
            " where task_id=%u "
            , task_id );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                _GuanqiaInfo info;
                info.guanqia_id = atoi(Mysql_Thread_Conn->GetField("guanqia_id"));
                info.weight = 0;
                info.type = atoi(Mysql_Thread_Conn->GetField("task_type"));

                if(info.guanqia_id == 0) {
                    continue;
                }

                if(info.type == GuanQiaType_BOSS) {
                    boss_vec.push_back(info);
                }
                else if(info.type == GuanQiaType_JingYing) {
                    elite_vec.push_back(info);
                }
                else {
                    normal_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


    //当前任务 关卡不够 报错 退出
    if(boss_vec.empty() || (normal_vec.size() < _normal_monster_vec.size()) 
        || (elite_vec.size() < _elite_monster_vec.size())) {
        LogMsg("%s, line %d, task_id=[%u] has not enough guanqia"
                    , __FILE__, __LINE__, task_id);
        assert(false);
    }
    
    { //填好boss
        int index = Utl::auto_random()%boss_vec.size();
        chess_board[0] = boss_vec[index].guanqia_id;
    }

    for(int i=0; i<_elite_monster_vec.size(); ++i) { //填好精英关
        int index = Utl::auto_random()%elite_vec.size();
        chess_board[_elite_monster_vec[i]] = elite_vec[index].guanqia_id;

        elite_vec.erase(elite_vec.begin() +index);
    }
    
    for(int i=0; i<_normal_monster_vec.size(); ++i) { //填好普通关
        int index = Utl::auto_random()%normal_vec.size();
        chess_board[_normal_monster_vec[i]] = normal_vec[index].guanqia_id;

        normal_vec.erase(normal_vec.begin() +index);
    }

    for(int i=0; i<_box_vec.size(); ++i) { //填好宝箱关
        chess_board[_box_vec[i]] = -1;
    }

    int chess_board_stat[max_grid_count] = {0};
    memset(chess_board_stat, 0, max_grid_count);
     //如果关卡存在或者只有boss 刷新的时候把boss位置为翻牌状态
    if(grid_total_count == 0) {
        chess_board_stat[0] = TaskGridStat_Floped;
    }
    else if(is_chess_board_exist && boss_stat != TaskGridStat_PreFlop) {
        chess_board_stat[0] = TaskGridStat_Floped;
    }
    
    { //将生成的棋盘入库
        char sql[1024], tmp[32];
        std::string str;
        sprintf(tmp, " grid_id_0=%d, grid_stat_0=%u", chess_board[0], chess_board_stat[0]);
        str += std::string(tmp);
        
        for(int i=1; i<max_grid_count; ++i) {
            sprintf(tmp, ", grid_id_%d=%d, grid_stat_%d=%d", 
                i, chess_board[i], i, chess_board_stat[i]);
            str += std::string(tmp);
        }

        sprintf(sql, "update hellgate.task_chessboard set %s "
            " where hero_id=%u and task_id=%u "
            , str.c_str()
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
}

void ProcServerThread::setChessBoardGridDiscovered(
    unsigned int hero_id,unsigned int task_id,unsigned int grid_id)
{
    { //置装态
        char sql[1024];
        char grid_str[32];
        sprintf(grid_str, "grid_stat_%u", grid_id);
        sprintf(sql, "update hellgate.task_chessboard set %s=2 "
            " where hero_id=%u and task_id=%u "
            , grid_str, hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


    //更改boss状态
    //棋盘，最大棋盘17个格子
    //首先获取棋盘的布局
    unsigned int grid_count_heng = 0;
    unsigned int grid_count_shu = 0;
    CS::getTaskChessboardFormat(task_id, grid_count_heng, grid_count_shu);
    unsigned int grid_count_total = grid_count_heng *grid_count_shu;
    
    const int max_grid_count = 17;
    unsigned int grid_stat_arr[max_grid_count];
    memset(grid_stat_arr, 0, max_grid_count);
    
    { //查询当前grid的状态
        char sql[1024], stat_field[32];
        sprintf(sql, "select * "
            " from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                for(int i=0; i<(grid_count_total+1); ++i) {
                    sprintf(stat_field, "grid_stat_%u", i);
                    grid_stat_arr[i] = atoi(Mysql_Thread_Conn->GetField(stat_field));
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
   
    //更新boss状态
    bool is_update_boss_stat = false;
    if(grid_id > 0 && grid_stat_arr[0] == TaskGridStat_PreFlop) {
        
        is_update_boss_stat = true;
        for(int i=1; i<grid_count_total+1; ++i) {
            if(grid_stat_arr[i] != TaskGridStat_Folded) {
                is_update_boss_stat = false;
                break;
            }
        }
    }

    if(is_update_boss_stat) {
        char sql[1024];
        sprintf(sql, "update hellgate.task_chessboard set  "
            " grid_stat_0=1 "
            " where hero_id=%u and task_id=%u"
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


bool ProcServerThread::subVitality(unsigned int hero_id,unsigned int vit)
{
    //先查
    int vit_current = 0;
    {
        char sql[1024];
        sprintf(sql, "select vit_current from hellgate.hero_infor where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);

            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                
                vit_current = atoi(Mysql_Thread_Conn->GetField("vit_current"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    if(vit_current < vit)
    {
        return false;
    }

    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set vit_current=%d where hero_id=%u "
            , vit_current-vit, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


bool ProcServerThread::addVitality(unsigned int hero_id, unsigned int vit)
{
    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set vit_current=vit_current+%u where hero_id=%u "
            , vit, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::Str2MinMax( std::string str,unsigned int & min,unsigned int & max)
{
    min = 0;
    max = 0;
    
    char* buf = new char[str.length()+1];
    CMemGuard guardp_str(buf);
    strcpy(buf, str.c_str());
    
    char *p_tmp = strchr(buf, '~');
    if(p_tmp)
    {
        *p_tmp = '\0';

        min = atoi(buf);
        p_tmp++;
        max = atoi(p_tmp);
    }
    else
    {
        min = atoi(buf);
        max = min;
    }
}


void ProcServerThread::adjustMainTaskMonsterDifficulty(unsigned int main_hero_id, unsigned int task_id, GuaiWuData & guaiwu_data)
{
    if(task_id <= 1)
    {
        guaiwu_data.gongJiLi *= 0.4;
        guaiwu_data.xueLiang *= 0.2;
    }
    else if(task_id <= 3)
    {
        guaiwu_data.gongJiLi *= 0.5;
        guaiwu_data.xueLiang *= 0.4;
    }
    else if(task_id <= 5)
    {
        guaiwu_data.gongJiLi *= 0.5;
        guaiwu_data.xueLiang *= 0.4;
    }
    else if(task_id <= 6)
    {
        guaiwu_data.gongJiLi *= 0.6;
        guaiwu_data.xueLiang *= 0.5;
    }
    else if(task_id <= 8)
    {
        guaiwu_data.gongJiLi *= 0.7;
        guaiwu_data.xueLiang *= 0.7;
    }
    else if(task_id <= 9)
    {
        guaiwu_data.gongJiLi *= 0.8;
        guaiwu_data.xueLiang *= 0.8;
    }
    else if(task_id <= 14)
    {
        guaiwu_data.gongJiLi *= 1.0;
        guaiwu_data.xueLiang *= 1.0;
    }
    else if(task_id <= 19)
    {
        guaiwu_data.gongJiLi *= 1.2;
        guaiwu_data.xueLiang *= 1.2;
    }
    else if(task_id <= 24)
    {
        guaiwu_data.gongJiLi *= 1.3;
        guaiwu_data.xueLiang *= 1.3;
    }
    else if(task_id <= 29)
    {
        guaiwu_data.gongJiLi *= 1.4;
        guaiwu_data.xueLiang *= 1.4;
    }
    else if(task_id <= 34)
    {
        guaiwu_data.gongJiLi *= 1.6;
        guaiwu_data.xueLiang *= 1.6;
    }
    else if(task_id <= 100)
    {
        guaiwu_data.gongJiLi *= 2;
        guaiwu_data.xueLiang *= 2;
    }
    else if(task_id == 101)
    {
        bool b_first = false;
        bool b_record = true;
        {//查询是否是第一次打地狱副本
            char sql[1024];
            sprintf(sql, "select first_hell from hellgate.hero_first_status "
                " where hero_id=%u "
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    b_first = !(bool)atoi(Mysql_Thread_Conn->GetField("first_hell"));
                } 
                else {
                    b_record = false;
                }
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(!b_record) { // 没有记录则插入记录
            b_first = true;
            char sql[1024];
            sprintf(sql, "insert into hellgate.hero_first_status set "
                " hero_id=%u, first_hell=0 "
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
            
        if(!b_first) {
            guaiwu_data.gongJiLi *= 0.6;
            guaiwu_data.xueLiang *= 0.6;
        }
        else {
            guaiwu_data.gongJiJuLi = 1;
            guaiwu_data.xueLiang = 1;
        }
    }
    else
    {
        guaiwu_data.gongJiLi *= 1;
        guaiwu_data.xueLiang *= 1;
    }
}

BaseHero* ProcServerThread::getBaseHero(unsigned int _heroId,ScriptBuilderUserData data)
{
    if(_heroId == 0)
    {
        return NULL;
    }

    short cdTime;
	getHeroCDTime(cdTime, _heroId, data);
    
    BaseHero* baseHeroRet = NULL;

    FightSUD *f_data = (FightSUD*)data.data;

    if(data.teamTag < 0
        && (f_data->battle_type == BattleType_MainTask || f_data->battle_type == BattleType_CityGuard
            || f_data->battle_type == BattleType_LegendNote || f_data->battle_type == BattleType_SelfChallenge
            || (f_data->battle_type==BattleType_ProtectSpirit && f_data->battle_kind==1)))
    {//怪物

        if(f_data->battle_type == BattleType_MainTask)
        {
            GuaiWuData guaiWu;
            unsigned int skill_type;
            GetMonsterDetail(_heroId, guaiWu, skill_type);
            //调整一下怪物难度
            adjustMainTaskMonsterDifficulty(f_data->heroId, f_data->taskId, guaiWu);

            Guaiwu* monsterRet = new Guaiwu();
            baseHeroRet = monsterRet;

            monsterRet->initWithGuaiwuData(guaiWu);
            monsterRet->setDefaultCdTime(cdTime);
            if(skill_type > 0)
            {
                SkillDataForFight skill_data((SkillType)skill_type, 1);
                monsterRet->skilVec.push_back(skill_data);
            }

            
            
        }
        else if(f_data->battle_type == BattleType_CityGuard)
        {
            GuaiWuData guaiWu;
            //stub
            unsigned int skill_type;
            GetMonsterDetail(SMID_CityGuard, guaiWu, skill_type);
            guaiWu.xueLiang = 700000;
            guaiWu.gongJiLi = 100000;
            {
                char sql[1024];
                sprintf(sql, "select boss_hp_remainder, gongji "
                    " from hellgate.cityguard_info, hellgate.cityguard_boss_template "
                    " where hellgate.cityguard_info.boss_level=hellgate.cityguard_boss_template.boss_level");
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL)
                    {
                        guaiWu.xueLiang = atoi(Mysql_Thread_Conn->GetField("boss_hp_remainder"));
                        guaiWu.gongJiLi = atoi(Mysql_Thread_Conn->GetField("gongji"));
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
            
            

            Guaiwu* monsterRet = new Guaiwu();
            baseHeroRet = monsterRet;

            monsterRet->initWithGuaiwuData(guaiWu);
            monsterRet->setDefaultCdTime(cdTime);
        }
        else if(f_data->battle_type == BattleType_LegendNote) 
        {
            GuaiWuData guaiWu;
            //stub
            unsigned int skill_type;
            GetMonsterDetail(_heroId, guaiWu, skill_type);
            guaiWu.xueLiang = 7;
            guaiWu.gongJiLi = 1000000;
            

            Guaiwu* monsterRet = new Guaiwu();
            baseHeroRet = monsterRet;

            monsterRet->initWithGuaiwuData(guaiWu);
            monsterRet->setDefaultCdTime(cdTime);
        }
        else if(f_data->battle_type == BattleType_SelfChallenge) 
        {
            GuaiWuData guaiWu;
            //stub
            unsigned int skill_type;
            GetMonsterDetail(_heroId, guaiWu, skill_type, f_data->hero_b_level);

            unsigned int n_buff = 0;
            switch(f_data->battle_kind) {
                case SelfChlgDiffType_Difficult:
                    n_buff = 50;
                    break;
                case SelfChlgDiffType_Hell:
                    n_buff = 100;
                    break;
                case SelfChlgDiffType_Nightmare:
                    n_buff = 200;
                    break;
            }
            
            guaiWu.xueLiang += guaiWu.xueLiang * n_buff /100;
            guaiWu.gongJiLi += guaiWu.gongJiLi * n_buff /100;

            Guaiwu* monsterRet = new Guaiwu();
            baseHeroRet = monsterRet;

            monsterRet->initWithGuaiwuData(guaiWu);
            monsterRet->setDefaultCdTime(cdTime);
            if(skill_type > 0)
            {
                SkillDataForFight skill_data((SkillType)skill_type, 1);
                monsterRet->skilVec.push_back(skill_data);
            }
        }
        else if(f_data->battle_type == BattleType_ProtectSpirit) 
        {
            GuaiWuData guaiWu;
            //stub
            unsigned int skill_type;
            GetMonsterDetail(_heroId, guaiWu, skill_type);
            guaiWu.xueLiang += (guaiWu.xueLiang *0.3);
            guaiWu.gongJiLi += (guaiWu.gongJiLi *0.3);

            Guaiwu* monsterRet = new Guaiwu();
            baseHeroRet = monsterRet;

            monsterRet->initWithGuaiwuData(guaiWu);
            monsterRet->setDefaultCdTime(cdTime);
        }

        if(f_data->boss_freezy) { //boss不动的时候 眩晕效果
			GameBuffEffect effect(-1);
			effect.xuanyun = true;
			effect.remove_pos = Pos_None;
			GameBuff buff(BuffState_Controller,0,0); 
			buff.effect_vec.push_back(effect);
			baseHeroRet->attachBuff(buff);
		}
    }
    else
    {//英雄
    
        //装备
        std::vector<__ZhuangbeiDetail> zhuangbei_vec;
        
        Hero* heroRet = getBattleScriptHero(*f_data, _heroId, cdTime);
        baseHeroRet = heroRet;

        bool b_debuff = false;
        int n_debuff = 0;
        if(data.teamTag < 0 && f_data->battle_kind==0
            && f_data->battle_type == BattleType_ProtectSpirit) {
            //守护之灵为英雄 根据时间来调节削减
            b_debuff = true;
            n_debuff = debuff_protect_spirit(_heroId);
        }
        
        //hp
        if(f_data->fightIndex > 1)
        {
            float hp = heroRet->getHp();
            hp *= 0.15f;
            unsigned hp_arr_index = 0;
            for(; hp_arr_index<FormationHeroAcountMax; ++hp_arr_index)
            {
                if(f_data->heroHpAfterLastFight.A_teamHeroId[hp_arr_index] == _heroId)
                {
                    break;
                }
            }
            hp += f_data->heroHpAfterLastFight.currentHp_A[hp_arr_index];
            if(hp > heroRet->getHp())
            {
                hp = heroRet->getHp();
            }
            heroRet->subHp(heroRet->getHp() - hp);

            if(b_debuff) {
                heroRet->subHp(heroRet->getHp() * n_debuff/100);
            }
        }
        

        //skill
        {
            SkillType skill_type;
            unsigned int skill_level;
            getHeroSkill(_heroId, skill_type, skill_level);
            SkillDataForFight skill_data(skill_type, skill_level);
            baseHeroRet->skilVec.push_back(skill_data);
        }

        
        //极限守城花钱跳过cd 攻击力翻倍
        if(f_data->battle_type == BattleType_CityGuard && f_data->battle_kind == 1) {
            GameBuffEffect effect(-1);
            effect.gongjili_add_lv = 100;
            effect.remove_pos = Pos_None;
            GameBuff buff(BuffState_Controller,0,0); 
            buff.effect_vec.push_back(effect);
            baseHeroRet->attachBuff(buff);
        }
        
        //如果是PVP则把攻击力提升
        if(f_data->battle_type == BattleType_Arena 
            || f_data->battle_type == BattleType_TopArena 
            || f_data->battle_type == BattleType_TopHeroChallenge
            || (f_data->battle_type==BattleType_ProtectSpirit && f_data->battle_kind==0))
        {
            
            GameBuffEffect effect(-1);
            effect.gongjili_add_lv = 50;
            effect.remove_pos = Pos_None;
            GameBuff buff(BuffState_Controller,0,0); 
            buff.effect_vec.push_back(effect);
            baseHeroRet->attachBuff(buff);
        }

        if(b_debuff) {
            GameBuffEffect effect(-1);
            effect.gongjili_add_lv = -n_debuff;
            effect.remove_pos = Pos_None;
            GameBuff buff(BuffState_Controller,0,0); 
            buff.effect_vec.push_back(effect);
            baseHeroRet->attachBuff(buff);
        }

        if(f_data->battle_type == BattleType_SelfChallenge) { //计算血战的加成
            unsigned int hp_gain=0, attack_gain=0, defense_gain=0, 
                checkpoints=0, died_point=0;
            
            { //查询血战的加成
                char sql[1024];
                sprintf(sql, "select hp_gain, attack_gain, defense_gain, checkpoints, died_point "
                    " from hellgate.self_challenge_hero, hellgate.hero_infor "
                    " where "
                    " (hellgate.self_challenge_hero.hero_id=hellgate.hero_infor.hero_id "
                    " and hellgate.hero_infor.hero_id=%u and hellgate.hero_infor.parent_hero_id=0) "
                    " or "
                    " (hellgate.self_challenge_hero.hero_id=hellgate.hero_infor.parent_hero_id "
                    " and hellgate.hero_infor.hero_id=%u and hellgate.hero_infor.parent_hero_id!=0) "
                    , f_data->heroId
                    , f_data->heroId);
                try {
                    Mysql_Thread_Conn->Query(sql);
                    if(Mysql_Thread_Conn->FetchRow() != NULL) {
                        hp_gain = atoi(Mysql_Thread_Conn->GetField("hp_gain"));
                        attack_gain = atoi(Mysql_Thread_Conn->GetField("attack_gain"));
                        defense_gain = atoi(Mysql_Thread_Conn->GetField("defense_gain"));
                        checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));
                        died_point = atoi(Mysql_Thread_Conn->GetField("died_point"));
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e) {
                    LogMsg("%s, line %d, mysql exception. [%s]", __FILE__, __LINE__, e.GetErrMsg());
                    exit(1);
                }
            }

            PropertyCalculator m_pc;
            float cur_defense = m_pc.calculateHuJiaZhi(baseHeroRet->getCalculateData());

            baseHeroRet->addHp(baseHeroRet->getHp() * hp_gain/100);
            GameBuffEffect effect(-1);
            effect.gongjili_add_lv = attack_gain;
            if(died_point > 0) {
                unsigned int n_gain = checkpoints +1 -died_point;
                if(n_gain == 1)
                    effect.jianshang_lv = 30;
                else if(n_gain == 2)
                    effect.jianshang_lv = 15;
            }
            effect.hujia_add = cur_defense*defense_gain/100;
            effect.remove_pos = Pos_None;
            GameBuff buff(BuffState_Controller,0,0); 
            buff.effect_vec.push_back(effect);
            baseHeroRet->attachBuff(buff);
        }
        
    }


    return baseHeroRet;
}

Hero* ProcServerThread::getBattleScriptHero(FightSUD user_data
    , unsigned int hero_id, unsigned int cdTime)
{
    //
    HeroDetail hero_detail;
    GetHeroDetail(hero_id,hero_detail);

    //如果是PVP，则需要把双方等级差距抹平
    unsigned int floating_level = 1;
    if(user_data.battle_type == BattleType_Arena || user_data.battle_type == BattleType_TopArena 
        || user_data.battle_type == BattleType_TopHeroChallenge) {
        
        floating_level = (user_data.hero_a_level+user_data.hero_b_level)/2;
        if(floating_level == 0) {
            assert(false);
        }
    }
    else {
        floating_level = hero_detail.basic_info.level;
    }
    
    //装备
    std::vector<__ZhuangbeiDetail> zhuangbei_vec;

    
    
    Hero* heroRet = new Hero();

    //获取装备列表
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_id "
            " from hellgate.zhuangbei_list "
            " where zhuangbei_hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __ZhuangbeiDetail detail;
                
                detail.zhuangbei_id = atoll(Mysql_Thread_Conn->GetField("zhuangbei_id"));
                zhuangbei_vec.insert(zhuangbei_vec.end(), detail);

            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned short resonance_star = 0;  //强化共鸣星级
    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int owner_id;
        getZhuangbeiDetail(zhuangbei_vec[i].zhuangbei_id, owner_id,zhuangbei_vec[i]);

        QianghuaData qh = zhuangbei_vec[i].qianghua_data;
        for(int j=0; j<qh.qianghua_count; ++j) {
            if(qh.info_arr[j].level == QianghuaLevel_yin)
                resonance_star += 1;
            else if(qh.info_arr[j].level == QianghuaLevel_jin 
                || qh.info_arr[j].level == QianghuaLevel_jin_special)
                resonance_star += 3;
        }
    }

    HeroBaseProperty property;
    property.hero_id= hero_id;
    property.profession = (Profession)hero_detail.basic_info.profession_id;
    
    if(hero_detail.basic_info.is_yuanshen) {
        property.level = hero_detail.basic_info.level;
        property.currentEffectPercent = CS::transferRatioOfYuanshenLevel(hero_detail.basic_info.level);
    }
    else {
        property.level = floating_level;
        property.currentEffectPercent = 100;
    }
    property.isYuanShen = hero_detail.basic_info.is_yuanshen;

    property.exp_current = hero_detail.exp_current;
    property.exp_need = hero_detail.exp_need;
    property.parent_hero_id = hero_detail.parent_hero_id;
    property.postion = hero_detail.postion;
    property.vit_current = hero_detail.vit_current;

    property.mLiLiang = hero_detail.hero_attr_without_zhuangbei.liliang;
    property.mMinJie = hero_detail.hero_attr_without_zhuangbei.mingjie;
    property.mZhiLi = hero_detail.hero_attr_without_zhuangbei.zhili;
    property.mTiNeng = hero_detail.hero_attr_without_zhuangbei.tineng;
    property.mHP = hero_detail.hero_attr_without_zhuangbei.xueliang;
    property.mGongJiJuLi = CS::getHeroGongjiJuLiByProfession(hero_detail.basic_info.profession_id);
    property.mBaoJiLv = hero_detail.hero_attr_without_zhuangbei.baoji;
    //property.mBaoJiShangHaiYinZi = hero_detail.hero_attr_without_zhuangbei.baoshang;
    property.mBaoJiShangHaiYinZi = hero_detail.hero_attr_without_zhuangbei.baoshang;
    property.mJiNengFaChuLv = hero_detail.hero_attr_without_zhuangbei.jinengchufa;
    property.mShangHaiLeiXing = getShangHaiType((Profession)hero_detail.basic_info.profession_id);
    //stub
    property.currentStage = hero_detail.basic_info.stage;
    property.resonance_star = resonance_star;
    heroRet->init(property);
    heroRet->setDefaultCdTime(cdTime);

    //如果是满级英雄，则需要查询出他的元神
    if(!hero_detail.basic_info.is_yuanshen
        && hero_detail.basic_info.level == HERO_MAX_LEVEL)
    {
        //获取元神
        unsigned int yuanshen_id = 0;
        {
            char sql[1024];
            sprintf(sql, "select hero_id "
                " from hellgate.hero_infor where is_yuanshen=1 and zhenshen_id=%u"
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    yuanshen_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                }
                else
                {
                    LogMsg("%s, line %d, hero_id[%u] has no yuanshen."
                            , __FILE__, __LINE__, hero_id);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(yuanshen_id > 0)
        {
            //递归
            heroRet->setYuanShen_AutoDeleted(getBattleScriptHero(user_data, yuanshen_id, cdTime));
        }
        
    }

    for(int i=0; i<zhuangbei_vec.size(); ++i)
    {
        unsigned int tmp_detail_data_len = 0;
        ZhuangbeiDetail* tmp_detail 
            = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];
        CMemGuard guard_1((char*)tmp_detail);
        zhuangbei_vec[i].convert2ZhuangbeiDetailAndHton(tmp_detail, tmp_detail_data_len);
        ZhuangbeiDetail* out_detail 
            = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];;
        CMemGuard guard_2((char*)out_detail);
        ntoh_zhuangbei_detail(*tmp_detail,*out_detail);
                    
        EquipData data;
        data.initWithZhungbeiDetail(out_detail);
        data.equipDicrib = zhuangbei_vec[i].desc;

        (heroRet)->equipVec.push_back(data);
    }

    heroRet->zhuangbeiOpEnd();

    return heroRet;
}


void ProcServerThread::getHeroDetail(HeroDetail& outData,unsigned int _heroId,ScriptBuilderUserData data)
{
    if(_heroId == 0)
    {
        outData.basic_info.hero_id = 0;
        return;
    }
    
    FightSUD *f_data = (FightSUD*)data.data;

    if(f_data->battle_type != BattleType_MainTask)
    {
        return;
    }
    
    if(data.teamTag < 0)
    {
        //怪物方
        return;
    }

    
    HeroDetail hero_detail;
    GetHeroDetail(_heroId,hero_detail);


	outData.basic_info.hero_id = _heroId;
	outData.basic_info.level = hero_detail.basic_info.level;
	strcpy(outData.basic_info.name,hero_detail.basic_info.name);
	outData.basic_info.profession_id = hero_detail.basic_info.profession_id;

	outData.parent_hero_id = hero_detail.parent_hero_id;
	outData.postion = hero_detail.postion;
	outData.exp_current = hero_detail.exp_current;
	outData.exp_need = hero_detail.exp_need;
	outData.vit_current = hero_detail.vit_current;

	outData.hero_attr_without_zhuangbei.mingjie = hero_detail.hero_attr_without_zhuangbei.mingjie;
	outData.hero_attr_without_zhuangbei.liliang = hero_detail.hero_attr_without_zhuangbei.liliang;
	outData.hero_attr_without_zhuangbei.zhili = hero_detail.hero_attr_without_zhuangbei.zhili;
	outData.hero_attr_without_zhuangbei.tineng = hero_detail.hero_attr_without_zhuangbei.tineng;

	outData.hero_attr_without_zhuangbei.xueliang = hero_detail.hero_attr_without_zhuangbei.xueliang;
	outData.hero_attr_without_zhuangbei.baoji = hero_detail.hero_attr_without_zhuangbei.baoji;
	outData.hero_attr_without_zhuangbei.baoshang = hero_detail.hero_attr_without_zhuangbei.baoshang;
	outData.hero_attr_without_zhuangbei.jinengchufa = hero_detail.hero_attr_without_zhuangbei.jinengchufa;

}
bool ProcServerThread::canTaskStat1ChangeToStat2ByClient(unsigned int stat1, unsigned int stat2)
{
    //客户端能触发的状态改变只能是从未领取到领取，从完成到提交。
    //其他状态变迁只能由服务器来触发
    if(stat1 == TaskStatus_NotGot && stat2 == TaskStatus_Got)
    {
        //领取任务
        return true;
    }
    if(stat1 == TaskStatus_Finished && stat2 == TaskStatus_Submitted)
    {
        //提交任务
        return true;
    }

    return false;
}

void ProcServerThread::ChangeTaskStat(unsigned int hero_id, unsigned int task_id, unsigned int stat)
{
    if(task_id >= MainTaskId_max)
    {
        LogMsg("%s, line %d, not implement yet."
                        , __FILE__, __LINE__);
        return;
    }


    //验证当前主任务id
    
    if(stat != TaskStatus_Submitted)
    {
        //修改状态
        char sql[1024];
        sprintf(sql, "update hellgate.hero_maintask_progress "
            " set status=%u"
            " where hero_id=%u"
            , stat, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else
    {
        if(task_id == MainTaskId_Implemented_Max)
        {
            //最后一关
            char sql[1024];
            sprintf(sql, "update hellgate.hero_maintask_progress "
                " set status=%u"
                " where hero_id=%u"
                , TaskStatus_Submitted, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        else
        {
            //激活下一关
            char sql[1024];
            sprintf(sql, "update hellgate.hero_maintask_progress "
                " set maintask_last_actived=maintask_last_actived+1, status=%u"
                " where hero_id=%u"
                , TaskStatus_NotGot, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
    }
    
}


//查询各等级升级所需的经验
unsigned int ProcServerThread::getProfessionLevelNeedExp(unsigned int level)
{
    return 0xffffffff;
    if(level==1 ) return 0      ;
    if(level==2 ) return 300    ;
    if(level==3 ) return 400   ;
    if(level==4 ) return 500   ;
    if(level==5 ) return 700   ;
    if(level==6 ) return 2000   ;
    if(level==7 ) return 2200  ;
    if(level==8 ) return 4800  ;
    if(level==9 ) return 5800  ;
    if(level==10) return 7800  ;
    if(level==11) return 10000 ;
    if(level==12) return 12000 ;
    if(level==13) return 24000  ;
    if(level==14) return 28000  ;
    if(level==15) return 30000  ;
    if(level==16) return 36000  ;
    if(level==17) return 60000  ;
    if(level==18) return 65000  ;
    if(level==19) return 70000  ;
    if(level==20) return 120000 ;
    if(level==21) return 160000 ;
    if(level==22) return 200000 ;
    if(level==23) return 210000 ;
    if(level==24) return 230000 ;
    if(level==25) return 240000 ;
    if(level==26) return 250000 ;
    if(level==27) return 250000;
    if(level==28) return 260000;
    if(level==29) return 285000;
    if(level==30) return 300000;
                         
    return 0xffffffff;
}


unsigned int ProcServerThread::getYuanshenLevelNeedExp(unsigned int level)
{
    return 0xffffffff;
    if(level==1 ) return 0      ;
    if(level==2 ) return 320000  ;
    if(level==3 ) return 320000 ;
    if(level==4 ) return 320000 ;
    if(level==5 ) return 320000 ;
    if(level==6 ) return 320000 ;
    if(level==7 ) return 320000;
    if(level==8 ) return 320000;
    if(level==9 ) return 320000;
    if(level==10) return 320000;
    if(level==11) return 320000;
    if(level==12) return 320000;
    if(level==13) return 320000;
    if(level==14) return 320000;
    if(level==15) return 320000;
    if(level==16) return 320000;
    if(level==17) return 320000;
    if(level==18) return 320000;
    if(level==19) return 320000;
    if(level==20) return 320000;
    if(level==21) return 320000;
    if(level==22) return 320000;
    if(level==23) return 320000;
    if(level==24) return 320000;
    if(level==25) return 320000;

    return 0xffffffff;
}


//查询各等级升级所需的经验
unsigned int ProcServerThread::get_levelup_need_exp(unsigned int type, unsigned int level)
{
    if(type!=HeroType_Hero && type!=HeroType_Soul)
        return 0xffffffff;

    std::map<unsigned int, unsigned int> *p_exp_map;
    std::map<unsigned int, unsigned int>::iterator p;
    if(type == HeroType_Hero) {
        p_exp_map = &m_exp_map[0];
    }
    else if(type == HeroType_Soul) {
        p_exp_map = &m_exp_map[1];
    }
    else {
        return 0xffffffff;
    }

    p = p_exp_map->find(level);
    if(p != p_exp_map->end()) {
        return p->second;;
    }
   
    return 0xffffffff;
}



//各职业各等级所对应的基础属性。
void ProcServerThread::getProfessionLevelAttr(Profession prof
        , unsigned int level
        , unsigned int& liliang, unsigned int& minjie, unsigned int& zhili, unsigned int& tineng
        , unsigned int& xueliang, unsigned int& baoji, unsigned int& baoshang, unsigned int& jinengchufa)
{
    liliang = 0;
    minjie = 0;
    zhili = 0;
    tineng = 0;
    xueliang = 0;
    baoji = 0;
    baoshang = 0;
    jinengchufa = 0;

    //初始值
    switch(prof)
    {
        case Profession_Yemanren:
        case Profession_Qishi:
        case Profession_WuSeng:
            liliang = 10;
            minjie = 4;
            zhili = 4;
            tineng = 4;
            break;
        case Profession_Chike:
        case Profession_ShenJianShou:
        case Profession_YouXia:
        case Profession_LieShou:
            liliang = 4;
            minjie = 10;
            zhili = 4;
            tineng = 4;
            break;
        case Profession_Fashi:
        case Profession_MiShu:
        case Profession_WuShi:
            liliang = 4;
            minjie = 4;
            zhili = 10;
            tineng = 4;
            break;
        default:
            assert(false);
        break;
    }

    //成长
    switch(prof)
    {
        case Profession_Yemanren:
        case Profession_Qishi:
        case Profession_WuSeng:
            liliang += (level-1)*2;
            minjie += (level-1);
            zhili += (level-1);
            tineng += (level-1)*4;
            break;
        case Profession_Chike:
        case Profession_ShenJianShou:
        case Profession_YouXia:
        case Profession_LieShou:
            liliang += (level-1);
            minjie += (level-1)*2;
            zhili += (level-1);
            tineng += (level-1)*4;
            break;
        case Profession_Fashi:
        case Profession_MiShu:
        case Profession_WuShi:
            liliang += (level-1);
            minjie += (level-1);
            zhili += (level-1)*2;
            tineng += (level-1)*4;
            break;
        default:
            assert(false);
        break;
    }

    //
    xueliang = 180;
    baoji = 10;
    baoshang = 150;
    jinengchufa = 20;

    return;
}



unsigned int ProcServerThread::fightEndCallback(ScriptBuilderUserData data,bool win)
{
    if(data.teamTag < 0 || !win)
    {
        return 0;
    }
    FightSUD *f_data = (FightSUD*)data.data;

    if(f_data->battle_type != BattleType_MainTask)
    {
        //只有主线任务得经验
        return 0;
    }

    //只有最后一波才能得经验
    if(f_data->fightIndex != getGuaiwuAttackCountOfTask(f_data->taskId,f_data->gridId))
    {
        return 0;
    }

    //查询关卡能多少经验
    int exper = 0;
    {
        unsigned int guanqia_id = 0;
        {
            char sql[1024];
            char grid_str[32];
            sprintf(grid_str, "grid_id_%u", f_data->gridId);
            sprintf(sql, "select %s  from hellgate.task_chessboard "
                " where hero_id=%u and task_id=%u"
                , grid_str, f_data->heroId, f_data->taskId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    guanqia_id = atoi(Mysql_Thread_Conn->GetField(grid_str));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        {
            char sql[1024];
            sprintf(sql, "select experience"
	            " from hellgate.task_template_test "
                " where task_id=%u and guanqia_id=%u"
                , f_data->taskId, guanqia_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    exper = atoi(Mysql_Thread_Conn->GetField("experience"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    
    //查询所有上阵英雄
    unsigned int team_pos_vec[4] = {0, 0, 0, 0};
    {
        std::vector<int> arr;
        
        char sql[1024];
        sprintf(sql, "select hero_id, position from hellgate.hero_infor "
            " where (parent_hero_id=%u or hero_id=%u) and position>0"
            , f_data->heroId, f_data->heroId);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                if(pos <= 0 || pos > 4)
                {
                    LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                        , __FILE__, __LINE__, f_data->heroId, pos);
                }
                else
                {
                    team_pos_vec[pos-1] = hero_id;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //所有上阵英雄获得经验
    for(int i=0; i<4; ++i)
    {
        if(team_pos_vec[i] > 0)
        {
            obtainExp(team_pos_vec[i], exper);
        }
    }
    
    return exper;
}



struct _ZB_diaoluo_limit
{
    unsigned int sel_zb_level_min;
    unsigned int sel_zb_level_max;
    unsigned int sel_zb_type_filter;
    unsigned int sel_zb_color;
    unsigned int ratio;
};

// 获取掉的装备
// 服务器必须得填
// 还得把数据持久化到数据库
vector<EquipData> ProcServerThread::getFightEndEquips(ScriptBuilderUserData data,bool win)
{
	vector<EquipData> eq_vec;

    
    if(data.teamTag < 0 || !win)
    {
        return eq_vec;
    }
    FightSUD *f_data = (FightSUD*)data.data;

    //只有最后一波才掉装
    if(f_data->fightIndex != getGuaiwuAttackCountOfTask(f_data->taskId,f_data->gridId))
    {
        return eq_vec;
    }

    if(f_data->battle_type != BattleType_MainTask)
    {
        //只有主线任务掉装备
        return eq_vec;
    }

    //第一个任务只有boss才掉装
    if(f_data->taskId==1 && (!isBOSS(f_data->taskId,f_data->gridId)))
    {
        //只有主线任务掉装备
        return eq_vec;
    }

    unsigned int guanqia_id = 0;
    {
        char sql[1024];
        char grid_str[32];
        sprintf(grid_str, "grid_id_%u", f_data->gridId);
        sprintf(sql, "select %s  from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , grid_str, f_data->heroId, f_data->taskId);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                guanqia_id = atoi(Mysql_Thread_Conn->GetField(grid_str));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    unsigned int diaoluo_group_id = 0;
    unsigned int diaoluo_name_id = 0;
    if(isBOSS(f_data->taskId,f_data->gridId))
    {
        if(!checkDiaoluoZBSpecialTaskFirstPass(f_data->heroId, f_data->taskId,diaoluo_name_id,diaoluo_group_id))
        {
            diaoluo_group_id = 0;
            diaoluo_name_id = 0;
        }
    }
    
    
    //如果是BOSS关卡，则查询BOSS掉落。并过滤掉其他主角职业的装备以及套装
    //根据概率决定掉落BOSS装备
    if((diaoluo_group_id == 0) && isBOSS(f_data->taskId, f_data->gridId))
    {
        //查询boss掉落以及概率
        std::vector<unsigned int> tmp_group_vec;
        std::vector<float> tmp_ratio_vec;
        {
            char sql[1024];
            sprintf(sql, "select "
                " special_zb_group_id_1, special_zb_ratio_1, "
                " special_zb_group_id_2, special_zb_ratio_2, "
                " special_zb_group_id_3, special_zb_ratio_3, "
                " special_zb_group_id_4, special_zb_ratio_4, "
                " special_zb_group_id_5, special_zb_ratio_5, "
                " special_zb_group_id_6, special_zb_ratio_6, "
                " special_zb_group_id_7, special_zb_ratio_7, "
                " special_zb_group_id_8, special_zb_ratio_8, "
                " special_zb_group_id_9, special_zb_ratio_9, "
                " special_zb_group_id_10, special_zb_ratio_10 "
                " from hellgate.task_template_test "
                " where guanqia_id=%u and task_id=%u"
                , guanqia_id, f_data->taskId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    char str[64];
                    for(int i=1; i<11; ++i)
                    {
                        sprintf(str, "special_zb_group_id_%d", i);
                        unsigned int group_id = atoi(Mysql_Thread_Conn->GetField(str));

                        sprintf(str, "special_zb_ratio_%d", i);
                        float ratio = atof(Mysql_Thread_Conn->GetField(str));

                        if(group_id > 0 && ratio > 0)
                        {
                            tmp_group_vec.push_back(group_id);
                            tmp_ratio_vec.push_back(ratio);
                        }
                    }
                    
                }
                else
                {
                    LogMsg("%s, line %d, guanqia_id[%u] task_id[%u]"
                            , __FILE__, __LINE__, guanqia_id, f_data->taskId);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //先过滤掉本团队无用的装
        HeroInfo main_hero_info;
        GetHeroBasicInfo(f_data->heroId, main_hero_info);
        std::vector<unsigned int> group_id_vec = filterZBGroupCannotUse((Profession)main_hero_info.profession_id, tmp_group_vec);

        if(group_id_vec.empty()) {//没有本团队英雄可用的
            LogMsg("%s, line %d, shit. hero_id[%u] not used zhuangbei."
                , __FILE__, __LINE__, f_data->heroId);
            return eq_vec;
        }

        
        int val = Utl::auto_random()%10000;
        int one_ratio = DROP_ZHUANGBEI_RATIO*100/group_id_vec.size();

        for(int i=0; i<group_id_vec.size(); i++){
            if((val -= one_ratio) < 0) {
                //就是他了
                diaoluo_group_id = group_id_vec[i];
                break;
            }
        }

        //计算掉落group中那个装
        if(diaoluo_group_id > 0)
        {
            diaoluo_name_id = chooseZhuangbeiNameIdFromGroupId(diaoluo_group_id);
            if(diaoluo_name_id == 0)
            {
                LogMsg("%s, line %d, shit. zhuangbei_group_id[%u] choose zhuangbei failed."
                                        , __FILE__, __LINE__, diaoluo_group_id);
                assert(false);
                return eq_vec;
            }
        }      

        /* 2014.03.20 修改BOSS关掉率 直接固化到程序中
        std::vector<float> ratio_id_vec;
        int index = 0;
        for(int i=0; i<tmp_group_vec.size(); ++i)
        {
            if(group_id_vec[index] == tmp_group_vec[i])
            {
                ratio_id_vec.push_back(tmp_ratio_vec[i]);

                index++;
            }
        }
        
        //计算掉哪一个group
        {
            int val = Utl::auto_random()%10000;
            for(int i=0; i<group_id_vec.size(); ++i)
            {
                //stub
                //if(ratio_id_vec[i] < 0 || ratio_id_vec[i] > 10)
                if(ratio_id_vec[i] < 0 || ratio_id_vec[i] > 100)
                {
                    LogMsg("%s, line %d, guanqia_id[%u] task_id[%u] ratio[%f] boss diaoluo ratio invalide"
                            , __FILE__, __LINE__, guanqia_id, data.taskId, ratio_id_vec[i]);
                    break;
                }

                int ratio_haha = (int)(ratio_id_vec[i]*100);
                if((val -= ratio_haha) < 0)
                {
                    //就是他了
                    diaoluo_group_id = group_id_vec[i];
                    break;
                }
            }
        }
        */
    }

    //如果无BOSS装备掉落，则查询普通掉落。
    std::vector<unsigned int> monster_id_vec;
    if(diaoluo_group_id == 0)
    {
        //先查询出普通掉落的范围
        std::vector<_ZB_diaoluo_limit> zb_diaoluo_limit_vec;
        {
            char sql[1024];
            sprintf(sql, "select "
                " sel_zb_level_min_1, sel_zb_level_max_1, sel_zb_type_filter_1, sel_zb_color_1, ratio_1, "
                " sel_zb_level_min_2, sel_zb_level_max_2, sel_zb_type_filter_2, sel_zb_color_2, ratio_2, "
                " sel_zb_level_min_3, sel_zb_level_max_3, sel_zb_type_filter_3, sel_zb_color_3, ratio_3, "
                " sel_zb_level_min_4, sel_zb_level_max_4, sel_zb_type_filter_4, sel_zb_color_4, ratio_4, "
                " sel_zb_level_min_5, sel_zb_level_max_5, sel_zb_type_filter_5, sel_zb_color_5, ratio_5, "
                " monster_id_3_1, monster_id_3_2, monster_id_3_3, monster_id_3_4 "
                " from hellgate.task_template_test "
                " where task_id=%u and guanqia_id=%u"
                , f_data->taskId, guanqia_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    for(int i=1; i<=5; ++i)
                    {
                        char str[64];

                        _ZB_diaoluo_limit diaoluo;

                        sprintf(str, "sel_zb_level_min_%d", i);
                        diaoluo.sel_zb_level_min = atoi(Mysql_Thread_Conn->GetField(str));

                        sprintf(str, "sel_zb_level_max_%d", i);
                        diaoluo.sel_zb_level_max = atoi(Mysql_Thread_Conn->GetField(str));

                        sprintf(str, "sel_zb_type_filter_%d", i);
                        diaoluo.sel_zb_type_filter = atoi(Mysql_Thread_Conn->GetField(str));

                        sprintf(str, "sel_zb_color_%d", i);
                        diaoluo.sel_zb_color = atoi(Mysql_Thread_Conn->GetField(str));

                        sprintf(str, "ratio_%d", i);
                        diaoluo.ratio = atoi(Mysql_Thread_Conn->GetField(str));

                        if(diaoluo.ratio > 0)
                        {
                            zb_diaoluo_limit_vec.push_back(diaoluo);
                        }
                        
                    }

                    {
                        unsigned int monster_id = atoi(Mysql_Thread_Conn->GetField("monster_id_3_1"));
                        if(monster_id > 0)
                        {
                            monster_id_vec.push_back(monster_id);
                        }
                    }
                    {
                        unsigned int monster_id = atoi(Mysql_Thread_Conn->GetField("monster_id_3_2"));
                        if(monster_id > 0)
                        {
                            monster_id_vec.push_back(monster_id);
                        }
                    }
                    {
                        unsigned int monster_id = atoi(Mysql_Thread_Conn->GetField("monster_id_3_3"));
                        if(monster_id > 0)
                        {
                            monster_id_vec.push_back(monster_id);
                        }
                    }
                    {
                        unsigned int monster_id = atoi(Mysql_Thread_Conn->GetField("monster_id_3_4"));
                        if(monster_id > 0)
                        {
                            monster_id_vec.push_back(monster_id);
                        }
                    }
                    
                    
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //判断是否是精英关卡
        bool is_jingying_guan = false;
        for(int i=0; i<monster_id_vec.size(); ++i)
        {
            GuaiWuData guaiwu;
            unsigned int skill_type;
            GetMonsterDetail(monster_id_vec[i],guaiwu, skill_type);
            if(guaiwu.type ==Type_Guaiwu_jingying)
            {
                is_jingying_guan = true;
            }
        }

        //根据概率决定掉哪个范围
        int vec_index = 0;
        {
            int ratio_total = 0;
            for(int i=0; i<zb_diaoluo_limit_vec.size(); ++i)
            {
                ratio_total += zb_diaoluo_limit_vec[i].ratio;
            }

            if(ratio_total > 100)
            {
                LogMsg("%s, line %d, task[%u]guanqia[%u] zhuangbei ratio_total > 100"
                                , __FILE__, __LINE__, f_data->taskId, guanqia_id);
                assert(false);
            }

            //精英关掉落率更大些
            float jingying_ratio_factor = 1;
            if(is_jingying_guan)
            {
                jingying_ratio_factor = 100.0/(float)ratio_total;
                if(jingying_ratio_factor > Jingying_Diaoluo_Factor)
                {
                    jingying_ratio_factor = Jingying_Diaoluo_Factor;
                }
            }
            int rand_num = Utl::auto_random()%100;
            for(vec_index=0; vec_index<zb_diaoluo_limit_vec.size(); ++vec_index)
            {
                rand_num -= jingying_ratio_factor * zb_diaoluo_limit_vec[vec_index].ratio;
                if(rand_num <= 0)
                {
                    break;
                }
            }
        }
        if(vec_index == zb_diaoluo_limit_vec.size())
        {
            LogMsg("%s, line %d, task[%u]guanqia[%u] no zb diaoluo"
                                            , __FILE__, __LINE__, f_data->taskId, guanqia_id);

            //一个都没选中
            return eq_vec;
        }

        //
        HeroInfo main_hero_info;
        GetHeroBasicInfo(f_data->heroId,main_hero_info);

        //查询出满足条件的所有的group
        std::map<unsigned int, std::vector<unsigned int> > zb_type_to_group_id_map;
        {

            std::vector<unsigned int> zb_type_vec;
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_DanshouJian) != 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_DanshouJian);
            }
            if(((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_ShuangShouBiShou) != 0)
                && (main_hero_info.profession_id == Profession_Chike))
            {
                zb_type_vec.push_back(ZhuangbeiType_ShuangshouBishou);
            }
            if(((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_ShuangshouFu) != 0)
                && (main_hero_info.profession_id == Profession_Yemanren))
            {
                zb_type_vec.push_back(ZhuangbeiType_ShuangshouFu );
            }
            if(((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_DanshouFazhang) != 0)
                && (main_hero_info.profession_id == Profession_Fashi))
            {
                zb_type_vec.push_back(ZhuangbeiType_DanshouFazhang);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_Gong)!= 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_Gong);
            }
            if(((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_Faqi) != 0)
                && (main_hero_info.profession_id == Profession_Fashi))
            {
                zb_type_vec.push_back(ZhuangbeiType_Faqi);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_Hushenfu) != 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_Hushenfu);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_KuijiaZhong)!= 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_KuijiaZhong);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_KuijiaQin) != 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_KuijiaQin);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_Jiezhi) != 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_Jiezhi);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_ShuangshouFazhang) != 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_ShuangshouFazhang);
            }
            if((zb_diaoluo_limit_vec[vec_index].sel_zb_type_filter & ZBT_Filter_Dunpai) != 0)
            {
                zb_type_vec.push_back(ZhuangbeiType_Dunpai);
            }
            
            if(zb_type_vec.size() == 0)
            {
                LogMsg("%s, line %d, task[%u]guanqia[%u] sel_zb_type_filter none"
                                            , __FILE__, __LINE__, f_data->taskId, guanqia_id);
                return eq_vec;
            }

            std::string type_str = "and (";
            {
                char buf[32];
                sprintf(buf, "zhuangbei_type=%u ", zb_type_vec[0]);
                type_str += buf;
            }
            for(int i=1; i<zb_type_vec.size(); ++i)
            {
                char buf[32];
                sprintf(buf, " or zhuangbei_type=%u", zb_type_vec[i]);
                type_str += buf;
            }
            type_str += ")";
            
            //成色
            if(zb_diaoluo_limit_vec[vec_index].sel_zb_color == ZhuangbeiColour_Xiyou
                || zb_diaoluo_limit_vec[vec_index].sel_zb_color == ZhuangbeiColour_Chuanqi)
            {
                //普通关卡不掉稀有和传奇
                return eq_vec;
            }
            unsigned int colour_1 = zb_diaoluo_limit_vec[vec_index].sel_zb_color;
            unsigned int colour_2 = zb_diaoluo_limit_vec[vec_index].sel_zb_color;
            if(zb_diaoluo_limit_vec[vec_index].sel_zb_color == ZhuangbeiColour_BaiZhuang_Fumo)
            {
                colour_1 = ZhuangbeiColour_Baizhuang;
                colour_2 = ZhuangbeiColour_Fumo;
            }
            char sql[2048];
            sprintf(sql, "select "
                " distinct(group_id), zhuangbei_type "
                " from hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_level>=%u and zhuangbei_level<=%u and "
                " (zhuangbei_colour=%u or zhuangbei_colour=%u) %s"
                , zb_diaoluo_limit_vec[vec_index].sel_zb_level_min, zb_diaoluo_limit_vec[vec_index].sel_zb_level_max
                , colour_1, colour_2
                , type_str.c_str());
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    unsigned int group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    unsigned int type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));

                    //去掉初始装
                    if(group_id > ZhuangBeiInitGroupId_Max)
                    {
                        std::map<unsigned int, std::vector<unsigned int> >::iterator pos 
                            = zb_type_to_group_id_map.find(type);
                        if(pos == zb_type_to_group_id_map.end())
                        {
                            std::vector<unsigned int> group_vec;
                            group_vec.push_back(group_id);
                            
                            zb_type_to_group_id_map.insert(make_pair(type, group_vec));
                        }
                        else
                        {
                            pos->second.push_back(group_id);
                        }
                    }

                    
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(zb_type_to_group_id_map.size() == 0)
        {
            LogMsg("%s, line %d, task[%u]guanqia[%u] zb_type_to_group_id_map none"
                                            , __FILE__, __LINE__, f_data->taskId, guanqia_id);
            return eq_vec;
        }

        //选择掉落的装备类型
        std::vector<unsigned int> group_id_vec;
        if(f_data->taskId > MAX_POLL_DROP_EQUIP_TASK){
            int index = Utl::auto_random()%zb_type_to_group_id_map.size();
            std::map<unsigned int, std::vector<unsigned int> >::iterator pos = zb_type_to_group_id_map.begin();
            for(int i=0; i<index; ++i)
            {
                pos++;
            }
            group_id_vec = pos->second;
        } 
        else {
            unsigned int type = poll_drop_equip(f_data->heroId, &zb_type_to_group_id_map);
            std::map<unsigned int, std::vector<unsigned int> >::iterator pos 
                = zb_type_to_group_id_map.find(type);
            if(pos != zb_type_to_group_id_map.end())
                group_id_vec = pos->second;
        }
        

        if(group_id_vec.size() == 0)
        {
            LogMsg("%s, line %d, task[%u]guanqia[%u] none group selected"
                                            , __FILE__, __LINE__, f_data->taskId, guanqia_id);

            //一个都没选中
            return eq_vec;
        }

        //根据各装备概率选择应该掉哪个具体装备 
        while(group_id_vec.size() > 0)
        {
            //随机选择一个group
            int group_index = Utl::auto_random()%group_id_vec.size();
            diaoluo_group_id = group_id_vec[group_index];
            
            diaoluo_name_id = chooseZhuangbeiNameIdFromGroupId(diaoluo_group_id);
            //
            if(diaoluo_name_id == 0)
            {
                LogMsg("%s, line %d, shit. zhuangbei_group_id[%u] choose zhuangbei failed."
                                    , __FILE__, __LINE__, diaoluo_group_id);

                
                //从vec中删去
                std::vector<unsigned int>::iterator pos=group_id_vec.begin();
                pos += group_index;
                group_id_vec.erase(pos);
            }
            else
            {
                break;
            }
        }
        if(group_id_vec.size() == 0)
        {
            LogMsg("%s, line %d, shit. ."
                                    , __FILE__, __LINE__);
            assert(false);
            return eq_vec;
        }
    }

    __ZhuangbeiDetail detail;
    if(!createZhuangbei(diaoluo_name_id, diaoluo_group_id,f_data->heroId,detail, f_data->b_check_count, true))
    {
        LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                , __FILE__, __LINE__, diaoluo_name_id);
        return eq_vec;
    }
    //入库
    detail.zhuangbei_id = ObtainZhuangbei(f_data->heroId, diaoluo_name_id,detail);

    {
        unsigned int tmp_detail_data_len = 0;
        ZhuangbeiDetail* tmp_detail 
            = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];
        CMemGuard guard_1((char*)tmp_detail);
        
        detail.convert2ZhuangbeiDetailAndHton(tmp_detail, tmp_detail_data_len);
        
        ZhuangbeiDetail* out_detail 
            = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];
        CMemGuard guard_2((char*)out_detail);
        ntoh_zhuangbei_detail(*tmp_detail,*out_detail);
        
        EquipData eq_data;
        eq_data.initWithZhungbeiDetail(out_detail);
        eq_data.equipDicrib = detail.desc;
        eq_vec.push_back(eq_data);
    }
/*
    //在掉落萃取附魔教学装时特殊处理一下。一旦掉落萃取装，则再额外加一件附魔装
    if(diaoluo_group_id == ZhuangBei_FirstCuiqu_GroupId_jian)
    {
        diaoluo_group_id = ZhuangBei_FirstFumo_GroupId_jian;
        diaoluo_name_id = ZhuangBei_FirstFumo_NameId_jian;
        
        __ZhuangbeiDetail detail;
        if(!createZhuangbei(diaoluo_name_id, diaoluo_group_id,data.heroId,detail))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, diaoluo_name_id);
            return eq_vec;
        }
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(data.heroId, diaoluo_name_id,detail);

        {
            unsigned int tmp_detail_data_len = 0;
            ZhuangbeiDetail* tmp_detail 
                = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];
            CMemGuard guard_1((char*)tmp_detail);
            
            detail.convert2ZhuangbeiDetailAndHton(tmp_detail, tmp_detail_data_len);
            
            ZhuangbeiDetail* out_detail 
                = (ZhuangbeiDetail*)new char[ZhuangbeiDetail::max_length()];
            CMemGuard guard_2((char*)out_detail);
            ntoh_zhuangbei_detail(*tmp_detail,*out_detail);
            
            EquipData eq_data;
            eq_data.initWithZhungbeiDetail(out_detail);
            eq_data.equipDicrib = detail.desc;
            eq_vec.push_back(eq_data);
        }
    }
    */

    return eq_vec;
}

//是否是boss关卡
bool ProcServerThread::isBOSS(unsigned int task_id, unsigned int grid_id)
{
    //unsigned int heng=0; 
    //unsigned int shu=0;

    //CS::getTaskChessboardFormat(task_id,heng,shu);
    if(grid_id == 0)
    {
        return true;
    }
    return false;
}



unsigned int ProcServerThread::getGuaiwuAttackCountOfTask(unsigned int task_id, unsigned int grid_id)
{
    if(task_id == 15)
    {
        return 6;
    }
    else if(task_id == 25)
    {
        return 6;
    }
    else if(task_id == 35)
    {
        return 6;
    }
    else if(task_id >= HellTaskId_Min && task_id <= HellTaskId_Max)
    {
        return 1;
    }
    

    return 1;
}

//剔除别的主角职业的专属装备
std::vector<unsigned int> ProcServerThread::filterZBGroupCannotUse(
    Profession main_hero_prof, std::vector<unsigned int> zb_group_id_vec)
{
    std::vector<unsigned int> ret_vec;
    
    for(int i=0; i<zb_group_id_vec.size(); ++i)
    {
        unsigned int zb_type = 0;
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_type  from hellgate.zhuangbei_name_list_copy "
                " where group_id=%u limit 1"
                , zb_group_id_vec[i]);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zb_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                }
                else
                {
                    LogMsg("%s, line %d, shit. group_id[%u]"
                            , __FILE__, __LINE__, zb_group_id_vec[i]);
                    continue;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(zb_type==(unsigned int)ZhuangbeiType_DanshouFazhang && main_hero_prof!=Profession_Fashi)
        {
            continue;
        }
        if(zb_type==(unsigned int)ZhuangbeiType_Faqi && main_hero_prof!=Profession_Fashi)
        {
            continue;
        }
        if(zb_type==(unsigned int)ZhuangbeiType_ShuangshouFu && main_hero_prof!=Profession_Yemanren)
        {
            continue;
        }
        if(zb_type==(unsigned int)ZhuangbeiType_ShuangshouBishou && main_hero_prof!=Profession_Chike)
        {
            continue;
        }


        //然后再过滤掉主角专属套装
        //stub 最好不要用在代码中写死装备ID的方式
        if(main_hero_prof!=Profession_Fashi)
        {
            if(zb_group_id_vec[i] == SUIT_fashi_level15_faqi_group_id
                || zb_group_id_vec[i] == SUIT_fashi_level30_faqi_group_id
                || zb_group_id_vec[i]== SUIT_fashi_level30_kuijia_group_id)
            {
                continue;
            }
        }
        if(main_hero_prof!=Profession_Chike)
        {
            if(zb_group_id_vec[i] == SUIT_cike_level15_kuijia_group_id
                || zb_group_id_vec[i] == SUIT_cike_level30_jiezhi_group_id
                || zb_group_id_vec[i]== SUIT_cike_level30_kuijia_group_id)
            {
                continue;
            }
        }
        if(main_hero_prof!=Profession_Yemanren)
        {
            if(zb_group_id_vec[i] == SUIT_yemanren_level15_kuijia_group_id
                || zb_group_id_vec[i] == SUIT_yemanren_level30_jiezhi_group_id
                || zb_group_id_vec[i]== SUIT_yemanren_level30_kuijia_group_id)
            {
                continue;
            }
        }

        ret_vec.push_back(zb_group_id_vec[i]);
    }

    return ret_vec;
    
}


bool ProcServerThread::isNeedSystemDailyRefresh(unsigned int last_refresh_time,unsigned int daily_refresh_hour_point)
{
    time_t cur_time = time(0);
    tm* p_tm = localtime(&cur_time);
    int wek_day = p_tm->tm_wday;
    int hour = p_tm->tm_hour;
    //int minutes = p_tm->tm_min;
    //int sec = p_tm->tm_sec;
    
    if(cur_time - last_refresh_time >= 86400)
    {
        //超过一天了，一定要做
        return true;
    }
    else
    {
        time_t last_time = last_refresh_time;
        tm* p_tm = localtime(&last_time);
        int last_wek_day = p_tm->tm_wday;
        int last_hour = p_tm->tm_hour;
        if((last_wek_day != wek_day || last_hour < daily_refresh_hour_point)
            && hour >= daily_refresh_hour_point)
        {
            //当前已经到时间，并且上次执行的时间是今日时间线之前 
            return true;
        }
        else if((last_wek_day != wek_day)  //当前时间在系统刷新时间之前
            && (hour < daily_refresh_hour_point)
            && (last_hour < daily_refresh_hour_point))
        {
            return true;
        }
    }

    return false;
}
 

int ProcServerThread::pastSystemDays(unsigned int last_time, 
    unsigned int daily_refresh_hour_point/*=SystemDailyTask_Hour*/)
{   
    time_t cur_time = time(NULL);
    if(last_time > (unsigned int)cur_time) {
        LogMsg("%s, last time[%u] over current time[%u]"
            , __FILE__, __LINE__, last_time, (unsigned int)cur_time);
        return -1;
    }
    
    //tm t_old;
    time_t old_time = (time_t)last_time;
    tm *p_old = localtime(&old_time);
    //memcpy(p_old, localtime((time_t *)(&last_time)), sizeof(tm));

    int old_hour = p_old->tm_hour;
    
    tm *p_now = localtime(&cur_time);
    //int days = p_now->tm_yday - p_old->tm_yday ;
    int days = ((unsigned int)cur_time - last_time) / (24 *3600);

    if(old_hour > p_now->tm_hour) //过去时间的小时数比当前时间小时数大 时间加1天
        days ++;
    
    if(old_hour < daily_refresh_hour_point && p_now->tm_hour >= daily_refresh_hour_point) {
        //过去时间小时数比系统刷新时间点小 而现在时间小时数比系统刷新时间点大 
        //则在计算的天数上加1天
        days ++;
    }
    else if(old_hour >= daily_refresh_hour_point && p_now->tm_hour < daily_refresh_hour_point) {
        //过去时间小时数比系统刷新时间点大 而现在时间小时数比系统刷新时间点小 
        //则在计算的天数上减1天
        days --;
    }

    return days;
}


// 获取掉的物品
// 服务器必须得填
// 还得把数据持久化到数据库
vector<ItemInfo> ProcServerThread::getFightEndItems(ScriptBuilderUserData data,bool win)
{
	vector<ItemInfo> item_vec;

    if(data.teamTag < 0 || !win)
    {
        return item_vec;
    }
    FightSUD *f_data = (FightSUD*)data.data;

    if(f_data->battle_type != BattleType_MainTask)
    {
        //只有主线任务掉物品
        return item_vec;
    }

    //只有最后一波才掉
    if(f_data->fightIndex != getGuaiwuAttackCountOfTask(f_data->taskId,f_data->gridId))
    {
        return item_vec;
    }

    //得到关卡道具掉落
    mainTaskDaojuDiaoluo(f_data->heroId, f_data->taskId, f_data->gridId, item_vec);
    
    

    //查询关卡能得多少银币
    unsigned int silver = 0;
    if(isBOSS(f_data->taskId,f_data->gridId))
    {
        char sql[1024];
        sprintf(sql, "select silver from hellgate.task_chessboard, hellgate.task_template_test "
            " where hero_id=%u and hellgate.task_chessboard.task_id=%u and "
            " hellgate.task_chessboard.task_id=hellgate.task_template_test.task_id and "
            " hellgate.task_chessboard.grid_id_0=hellgate.task_template_test.guanqia_id "
            , f_data->heroId, f_data->taskId);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                silver = atoi(Mysql_Thread_Conn->GetField(silver));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(silver > 0) {
        ItemInfo item;
        item.type = ItemsType_Silver;
        item.count = silver;
        item_vec.push_back(item);
    }

    if(isBOSS(f_data->taskId,f_data->gridId))
    { //获取随机宝石
        if(f_data->taskId >= 9 ) { //9关以上才有宝石奖励
            int ran_num = Utl::auto_random() %100;
            int type_arr[3]= {0, 0, 0};
            
            if((ran_num-=5) < 0) { //5%的几率
                if(f_data->taskId <= 20) {
                    type_arr[0] = ItemsType_Baoshi_lv_1;
                    type_arr[1] = ItemsType_Baoshi_hong_1;
                    type_arr[2] = ItemsType_Baoshi_huang_1;
                }
                else if(f_data->taskId <= 40) {
                    type_arr[0] = ItemsType_Baoshi_lv_2;
                    type_arr[1] = ItemsType_Baoshi_hong_2;
                    type_arr[2] = ItemsType_Baoshi_huang_2;
                }
                
                int index = Utl::auto_random() %3;
            
                ItemInfo item;
                item.type = type_arr[index];
                item.count = 1;
                item_vec.push_back(item);
            }
        }
    }

    
    /* 2014.05.30 取消银币固定掉落 改为上面的读表查询掉落
    //查询关卡有无首次通关的指定银币掉落，如果没有则进行普通掉落
    if(isBOSS(f_data->taskId,f_data->gridId))
    {
        checkDiaoluoSilverSpecialTaskFirstPass(f_data->heroId, f_data->taskId, silver);
    }
    
    if(silver == 0)
    {
        unsigned int guanqia_id = 0;
        {
            char sql[1024];
            char grid_str[32];
            sprintf(grid_str, "grid_id_%u", f_data->gridId);
            sprintf(sql, "select %s  from hellgate.task_chessboard "
                " where hero_id=%u and task_id=%u"
                , grid_str, f_data->heroId, f_data->taskId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    guanqia_id = atoi(Mysql_Thread_Conn->GetField(grid_str));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        {
            char sql[1024];
            sprintf(sql, "select silver "
                " from hellgate.task_template_test "
                " where task_id=%u and guanqia_id=%u"
                , f_data->taskId, guanqia_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    silver = atoi(Mysql_Thread_Conn->GetField("silver"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //stub
        //每个关卡固定掉落200银币
        silver = 200;
    }
    */

    /* 2014.05.09 取消银币掉落
    ItemInfo item;
    item.type = ItemsType_Silver;
    item.count = silver;
    item_vec.push_back(item);
    */

    //
    for(int i=0; i<item_vec.size(); ++i)
    {
        if(item_vec[i].type == ItemsType_Hammer)
            continue;
        ObtainItem(f_data->heroId,item_vec[i].type, item_vec[i].count);
    }
    

    return item_vec;
}

// 获取掉落的Item碎片
vector<ItemSuipianInfo> ProcServerThread::getFightEndItemSuiPians(ScriptBuilderUserData data,bool win)
{
    vector<ItemSuipianInfo> suipian_vec;
    return suipian_vec;
}

// 获取掉落的神兵碎片
vector<ShenbingSuipianInfo> ProcServerThread::getFightEndShenBingSuiPians(ScriptBuilderUserData data,bool win)
{
    vector<ShenbingSuipianInfo> suipian_vec;

    if(data.teamTag < 0 || !win)
    {
        return suipian_vec;
    }
    FightSUD *f_data = (FightSUD*)data.data;

    //只有最后一波才掉装
    if(f_data->fightIndex != getGuaiwuAttackCountOfTask(f_data->taskId,f_data->gridId))
    {
        return suipian_vec;
    }
    
    if(f_data->battle_type != BattleType_MainTask)
    {
        //只有主线任务掉装备
        return suipian_vec;
    }

    unsigned int guanqia_id = 0;
    {
        char sql[1024];
        char grid_str[32];
        sprintf(grid_str, "grid_id_%u", f_data->gridId);
        sprintf(sql, "select %s  from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , grid_str, f_data->heroId, f_data->taskId);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                guanqia_id = atoi(Mysql_Thread_Conn->GetField(grid_str));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    
    //根据概率决定掉落神兵碎片
    if(isBOSS(f_data->taskId, f_data->gridId))
    {
        unsigned int profession_id = 0;
        {//查询主英雄profession_id
            char sql[1024];
            sprintf(sql, "select profession_id from hellgate.hero_infor "
                " where hero_id=%u"
                , f_data->heroId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                    if(profession_id <1 || profession_id >3) {
                        LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u] is error. "
                            , __FILE__, __LINE__, f_data->heroId, profession_id);
                        return suipian_vec;
                    }
                } 
                else {
                    LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
                        , __FILE__, __LINE__, f_data->heroId, profession_id);
                    return suipian_vec;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        unsigned int shenbing_zb_group_id = 0;
        {//查询boss掉落
            char sql[1024];
            sprintf(sql, "select diaoluo_zb_group_id from hellgate.hell_task_chuanqi_suipian "
                " where profession_id=%u and task_id=%u"
                , profession_id, f_data->taskId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    shenbing_zb_group_id = atoi(Mysql_Thread_Conn->GetField("diaoluo_zb_group_id"));
                } 
                else {
                    LogMsg("%s, line %d, task[%u], profession_id[%u], is not exist. "
                        , __FILE__, __LINE__, f_data->taskId, profession_id);
                    return suipian_vec;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        bool b_first = false;
        {//查询是否是第一次打地狱副本
            char sql[1024];
            sprintf(sql, "select first_hell from hellgate.hero_first_status "
                " where hero_id=%u "
                , f_data->heroId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    b_first = !(bool)atoi(Mysql_Thread_Conn->GetField("first_hell"));
                } 
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        unsigned int drop_times = 0;
        {//查询当天掉落次数
            char sql[1024];
            sprintf(sql, "select drop_times from hellgate.hell_task_hero_info "
                " where hero_id=%u "
                , f_data->heroId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    drop_times = atoi(Mysql_Thread_Conn->GetField("drop_times"));
                } 
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }


        bool b_droped = false; //是否掉落的标志位
        if(b_first) {//第一次打传奇副本必掉
            ShenbingSuipianInfo suipian;
            suipian.zb_group_id = shenbing_zb_group_id;
            suipian.suipian_count = 1;

            //随机掉落碎片id
            suipian.suipian_id = Utl::auto_random()%5 +1;
            
            suipian_vec.push_back(suipian);

            b_droped = true;
        }
        else {//随机决定是否掉落
            const unsigned int const_basic_ratio = 20;  //基础掉率
            int rand_v = Utl::auto_random()%100;
            int id_arr[5] = {1, 2, 3, 4, 5};
            
            std::vector<unsigned int> id_vec;
            id_vec.insert (id_vec.end(), id_arr, id_arr+5);
            
            if((rand_v -= const_basic_ratio) < 0) {//掉
                if(drop_times == 0) { //每天第一次掉落碎片
                    //查找还差的碎片id
                    char sql[1024];
                    sprintf(sql, "select suipian_id, suipian_count from hellgate.shenbing_suipian_in_team "
                        " where hero_id=%u and zb_group_id=%u order by suipian_count "
                        , f_data->heroId, shenbing_zb_group_id);
                    try
                    {
                        Mysql_Thread_Conn->Query(sql);
                        while(Mysql_Thread_Conn->FetchRow() != NULL) {
                            unsigned int id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                            unsigned int count = atoi(Mysql_Thread_Conn->GetField("suipian_count"));
                            if(count > 0) { //有此id的碎片 排除
                                for(int i=0; i<id_vec.size(); i++) {
                                    if(id_vec[i] == id) {
                                        id_vec.erase(id_vec.begin()+i);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        Mysql_Thread_Conn->FreeResult();
                    }
                    catch(CMysqlException& e)
                    {
                        LogMsg("%s, line %d, mysql exception. [%s]"
                                    , __FILE__, __LINE__, e.GetErrMsg());
                        //
                        exit(1);
                    }
                }

                ShenbingSuipianInfo suipian;
                suipian.zb_group_id = shenbing_zb_group_id;
                suipian.suipian_count = 1;

                //随机掉落碎片id
                if(id_vec.empty()) {
                    suipian.suipian_id = Utl::auto_random()%5 +1;
                } else {
                    suipian.suipian_id = id_vec[Utl::auto_random()%id_vec.size()];
                }
                
                suipian_vec.push_back(suipian);
                
                b_droped = true;
            } 
        }

        if(b_first) {//第一次更新状态
            char sql[1024];
            sprintf(sql, "update hellgate.hero_first_status set "
                " first_hell=1 where "
                " hero_id=%u  "
                , f_data->heroId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        if(b_droped){ //更新掉落次数
            char sql[1024];
            sprintf(sql, "update hellgate.hell_task_hero_info set "
                " drop_times=drop_times+1 where "
                " hero_id=%u "
                , f_data->heroId);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    for(int i=0; i<suipian_vec.size(); ++i)
    {
        ObtainZhuangbeiSuipian(f_data->heroId, suipian_vec[i].zb_group_id, suipian_vec[i].suipian_id, suipian_vec[i].suipian_count);
    }
    
    return suipian_vec;
}


void ProcServerThread::mainTaskDaojuDiaoluo(
    unsigned int hero_id, unsigned int task_id, unsigned int grid_id
    , std::vector<ItemInfo>& item_vec)
{
    item_vec.clear();

    //先查看是否有首次通关的特殊掉落
    if(isBOSS(task_id, grid_id) && checkDiaoluoItemSpecialTaskFirstPass(hero_id, task_id, item_vec))
    {
        return;
    }
    
    //如果是boss关，则先计算BOSS道具掉落
    if(isBOSS(task_id,grid_id))
    {
        unsigned int guanqia_id = 0;
        {
            char sql[1024];
            char grid_str[32];
            sprintf(grid_str, "grid_id_%u", grid_id);
            sprintf(sql, "select %s  from hellgate.task_chessboard "
                " where hero_id=%u and task_id=%u"
                , grid_str, hero_id, task_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    guanqia_id = atoi(Mysql_Thread_Conn->GetField(grid_str));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        //查询boss掉落以及概率
        std::vector<unsigned int> item_type_vec;
        std::vector<float> item_ratio_vec;
        {
            char sql[1024];
            sprintf(sql, "select "
                " special_item_type_1, special_item_ratio_1, "
                " special_item_type_2, special_item_ratio_2, "
                " special_item_type_3, special_item_ratio_3, "
                " special_item_type_4, special_item_ratio_4, "
                " special_item_type_5, special_item_ratio_5, "
                " special_item_type_6, special_item_ratio_6, "
                " special_item_type_7, special_item_ratio_7, "
                " special_item_type_8, special_item_ratio_8, "
                " special_item_type_9, special_item_ratio_9, "
                " special_item_type_10, special_item_ratio_10 "
                " from hellgate.task_template_test "
                " where guanqia_id=%u and task_id=%u"
                , guanqia_id, task_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    char str[64];
                    for(int i=1; i<11; ++i)
                    {
                        sprintf(str, "special_item_type_%d", i);
                        unsigned int item_type = atoi(Mysql_Thread_Conn->GetField(str));

                        sprintf(str, "special_item_ratio_%d", i);
                        float ratio = atof(Mysql_Thread_Conn->GetField(str));

                        if(item_type > 0 && ratio > 0)
                        {
                            item_type_vec.push_back(item_type);
                            item_ratio_vec.push_back(ratio);
                        }
                    }
                    
                }
                else
                {
                    LogMsg("%s, line %d, guanqia_id[%u] task_id[%u]"
                            , __FILE__, __LINE__, guanqia_id, task_id);
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        //计算掉哪一个item
        unsigned int diaoluo_item_type = 0;
        {
            int val = Utl::auto_random()%10000;
            for(int i=0; i<item_type_vec.size(); ++i)
            {
                //stub
                //if(ratio_id_vec[i] < 0 || ratio_id_vec[i] > 10)
                if(item_ratio_vec[i] < 0 || item_ratio_vec[i] > 100)
                {
                    LogMsg("%s, line %d, guanqia_id[%u] task_id[%u] ratio[%f] boss diaoluo ratio invalide"
                            , __FILE__, __LINE__, guanqia_id, task_id, item_ratio_vec[i]);
                    break;
                }

                int ratio_haha = (int)(item_ratio_vec[i]*100);
                if((val -= ratio_haha) < 0)
                {
                    //就是他了
                    diaoluo_item_type = item_type_vec[i];
                    break;
                }
            }
        }
        
        //
        if(diaoluo_item_type > 0)
        {
            ItemInfo item;
            item.type = diaoluo_item_type;
            item.count = 1;
            item_vec.push_back(item);
        }
        
    }

    if(item_vec.size() > 0)
    {
        return;
    }
    
    unsigned int zutiefen_ratio = 0;
    unsigned int baoshi_hong_ratio = 0;
    unsigned int baoshi_lv_ratio = 0;
    unsigned int baoshi_huang_ratio = 0;
    //unsigned int baoshi_zhi_ratio = 0;
    if(task_id >= 5)
    {
        zutiefen_ratio = 30;
    }
    if(task_id >= 15)
    {
        baoshi_hong_ratio = 5;
        baoshi_huang_ratio = 5;
        baoshi_lv_ratio = 5;
        //baoshi_zhi_ratio = 5;
    }

    //
    bool has_diaoluo = false;
    ItemInfo item;
    int ratio = Utl::auto_random()%100;
    if((ratio-=zutiefen_ratio) < 0)
    {
        has_diaoluo = true;
        
        item.type = ItemsType_QianghuaNormal;
        item.count = 10;
    }
    /* 2014.03.20 去掉掉落宝石
    else if((ratio-=baoshi_hong_ratio) < 0)
    {
        has_diaoluo = true;
        
        item.type = ItemsType_Baoshi_hong_1;
        item.count = 1;
    }
    else if((ratio-=baoshi_lv_ratio) < 0)
    {
        has_diaoluo = true;
        
        item.type = ItemsType_Baoshi_lv_1;
        item.count = 1;
    }
    else if((ratio-=baoshi_huang_ratio) < 0)
    {
        has_diaoluo = true;
        
        item.type = ItemsType_Baoshi_huang_1;
        item.count = 1;
    }
    */
    /*
    else if((ratio-=baoshi_zhi_ratio) < 0)
    {
        has_diaoluo = true;
        
        item.type = ItemsType_Baoshi_zhi_1;
        item.count = 1;
    }
    */
    
    
    if(has_diaoluo)
    {
        item_vec.push_back(item);
    }

    return;
}

void ProcServerThread::teamFightEnd(bool win,TeamEndParam parm,TeamEndOutParam& gettedItems)
{
     LogMsg("%s, line %d, waring teamFightEnd ---> in test ,not implemets!"
                    , __FILE__, __LINE__);
}

int ProcServerThread::getShangHaiType(Profession prof)
{
    switch(prof)
    {
        case Profession_Yemanren:
        case Profession_Chike:
        case Profession_Qishi:
        case Profession_WuSeng:
        case Profession_YouXia:
        case Profession_LieShou:
        case Profession_ShenJianShou:
            return SHANG_HAI_WU_LI;
            break;
            
        case Profession_Fashi:
        case Profession_WuShi:
        case Profession_MiShu:
            return SHANG_HAI_MO_FA;
            break;
        default:
            LogMsg("%s, line %d,  prof=[%d]"
                    , __FILE__, __LINE__, prof);
            return SHANG_HAI_WU_LI;
            break;
    }
}

//如果概率之和大于100则进行缩小。越大的概率缩减越多，越小的概率缩减越小
std::vector<float> ProcServerThread::ajustRatio(std::vector<int> ratio_vec)
{
    float total_ratio = 0;
    
    std::vector<float> ratio_vec_org;
    for(int i=0; i<ratio_vec.size(); ++i)
    {
        float f = ratio_vec[i];
        total_ratio += f;
        
        ratio_vec_org.push_back(f);
    }

    if(total_ratio <= 100)
    {
        return ratio_vec_org;
    }


    std::vector<float> ratio_vec_new;
    float sum = 0;
    for(int i=0; i<ratio_vec_org.size(); ++i)
    {
        float y = 100.0/total_ratio * (1.0 - ratio_vec_org[i]/total_ratio);
        sum += y;
        
        ratio_vec_new.push_back(y);
    }   
    
    //
    for(int i=0; i<ratio_vec_new.size(); ++i)
    {
        ratio_vec_new[i] *= 100.0/sum;
    }
    
    //如果有概率超出原始，则去掉。去掉部分再按比例分给未超出的
    float extra = 0;
    sum = 0;
    for(int i=0; i<ratio_vec_new.size(); ++i)
    {
        if(ratio_vec_new[i] >= ratio_vec_org[i])
        {
            extra += ratio_vec_new[i] - ratio_vec_org[i];
            ratio_vec_new[i] = ratio_vec_org[i];
        }
        else
        {
            sum += ratio_vec_org[i] - ratio_vec_new[i];
        }
    }
    for(int i=0; i<ratio_vec_new.size(); ++i)
    {
        if(ratio_vec_new[i] < ratio_vec_org[i])
        {
            ratio_vec_new[i] += extra * (ratio_vec_org[i] - ratio_vec_new[i])/sum;
        }
    }
    
    
    return ratio_vec_new;
}


void ProcServerThread::getGuanQiaGuaiWu(
    unsigned int hero_id, unsigned int task_id, unsigned int grid_id
    , unsigned int pos_vec_1[], unsigned int pos_vec_2[], unsigned int pos_vec_3[])
{
    unsigned int guanqia_id = 0;
    {
        char sql[1024];
        char grid_str[32];
        sprintf(grid_str, "grid_id_%u", grid_id);
        sprintf(sql, "select %s  from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , grid_str, hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                guanqia_id = atoi(Mysql_Thread_Conn->GetField(grid_str));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    {
        char sql[1024];
        sprintf(sql, "select  "
            " monster_id_1_1 ,"
            " monster_id_1_2 ,"
            " monster_id_1_3 ,"
            " monster_id_1_4 ,"
            " monster_id_2_1 ,"
            " monster_id_2_2 ,"
            " monster_id_2_3 ,"
            " monster_id_2_4 ,"
            " monster_id_3_1 ,"
            " monster_id_3_2 ,"
            " monster_id_3_3 ,"
            " monster_id_3_4 "
            " from hellgate.task_template_test "
            " where task_id=%u and guanqia_id=%u"
            , task_id, guanqia_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                pos_vec_1[0]= atoi(Mysql_Thread_Conn->GetField("monster_id_1_1"));
                pos_vec_1[1]= atoi(Mysql_Thread_Conn->GetField("monster_id_1_2"));
                pos_vec_1[2]= atoi(Mysql_Thread_Conn->GetField("monster_id_1_3"));
                pos_vec_1[3]= atoi(Mysql_Thread_Conn->GetField("monster_id_1_4"));

                pos_vec_2[0]= atoi(Mysql_Thread_Conn->GetField("monster_id_2_1"));
                pos_vec_2[1]= atoi(Mysql_Thread_Conn->GetField("monster_id_2_2"));
                pos_vec_2[2]= atoi(Mysql_Thread_Conn->GetField("monster_id_2_3"));
                pos_vec_2[3]= atoi(Mysql_Thread_Conn->GetField("monster_id_2_4"));

                pos_vec_3[0]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_1"));
                pos_vec_3[1]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_2"));
                pos_vec_3[2]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_3"));
                pos_vec_3[3]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_4"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}

void ProcServerThread::getTeamBloodNum(short& currentNum,short& defaultNum,int& bloodAddPercent,ScriptBuilderUserData data)
{
	currentNum = 0;
	defaultNum = 0;
	bloodAddPercent = 30;		// 30%

    FightSUD *f_data = (FightSUD*)data.data;

    if(f_data->battle_type != BattleType_MainTask && f_data->battle_type != BattleType_CityGuard)
    {
        //只有主线和守城带血瓶
        return;
    }

	if (data.teamTag == TEAM_TAG_A)
	{
        if(f_data->fightIndex > 1)
        {
            currentNum = f_data->heroHpAfterLastFight.A_teamCurrentBloodNum;
        }
        else
        {
            currentNum = 4;
        }
		
		defaultNum = 4;
	}
    
    /* 2014.07.04 boss加血 暂时使用英雄使用血瓶的逻辑 以后需要改StepType 和逻辑 */
    /*
    else if(data.teamTag == TEAM_TAG_B) {   //boss
        if(f_data->taskId == 20) {          //第二章节的boss魔化之树 特殊表现需要加血
            defaultNum = 1000;              //先给1000个血瓶 
	        bloodAddPercent = 15;	        // 15%
            
            if(f_data->fightIndex > 1) {
                currentNum = f_data->heroHpAfterLastFight.A_teamCurrentBloodNum;
            }
            else {
                currentNum = defaultNum;  
            }
            
        }
    }
    */
    
}
void ProcServerThread::getHeroCDTime(short& cdStepNum,unsigned heroId,ScriptBuilderUserData data)
{
	cdStepNum = 0;

	if (data.teamTag == TEAM_TAG_A)
	{
		cdStepNum = 3;
	}
    /* 2014.07.04 boss加血 暂时使用英雄使用血瓶的逻辑 以后需要改StepType 和逻辑 */
    /*
    else if(data.teamTag == TEAM_TAG_B) {   //boss
        FightSUD *f_data = (FightSUD*)data.data;
        if(f_data->taskId == 20) {          //第二章节的boss魔化之树 特殊表现需要加血
            cdStepNum = 1;          
        }
    }
    */
}


void ProcServerThread::obtainExp(unsigned int hero_id, unsigned int exp)
{
    
    //先查询当前等级和经验 
    unsigned int prof = 0;
    unsigned int level_cur = 0;
    unsigned int exp_cur = 0;
    {
        char sql[1024];
        sprintf(sql, "select profession_id, level, exp_current from hellgate.hero_infor "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                prof = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                level_cur = atoi(Mysql_Thread_Conn->GetField("level"));
                exp_cur = atoi(Mysql_Thread_Conn->GetField("exp_current"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    unsigned int hero_id_get_exp = hero_id;

    //如果已经满级则经验应该注入元神
    if(level_cur >= HERO_MAX_LEVEL)
    {
        char sql[1024];
        sprintf(sql, "select hero_id, exp_current from hellgate.hero_infor "
            " where zhenshen_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_id_get_exp = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                exp_cur = atoi(Mysql_Thread_Conn->GetField("exp_current"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //
    exp_cur += exp;

    {
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor "
            " set exp_current=%u "
            " where hero_id=%u"
            , exp_cur, hero_id_get_exp);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return;
}


int ProcServerThread::drawbyLot(int *count, const int len)
{
    vector<int> count_vec;

    for(int i=0; i<len; i++){
        count_vec.push_back(i);
    }   

    for(int i=0; i<len; i++){
        int j = Utl::auto_random() % (len -i);
        *(count +i) = count_vec[j];
        count_vec.erase(count_vec.begin() +j);
    }   

    return 0;
}


void ProcServerThread::updateRateTaskStarStat(RateStarType type, unsigned int hero_id, 
    unsigned int task_id, unsigned int star)
{
    char sql[1024];
    bool b_insert = false;

    //查询现有星级
    if(type == RateStarType_Task) {
        if(star > 3)
            return;
        sprintf(sql, "select star from hellgate.rate_task_stat "
            " where hero_id=%u and task_id=%u"
            , hero_id, task_id);
    }
    else if(RateStarType_Chapter) {
        if(star > 2)
            return;
        sprintf(sql, "select star from hellgate.rate_chapter_stat "
            " where hero_id=%u and task_id=%u"
            , hero_id, task_id);
    }
    else {
        return;
    }
    
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            //星级不需要更新
            if(atoi(Mysql_Thread_Conn->GetField("star")) >= star)
                return;
        }
        else {
           b_insert = true;
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

    
    if(b_insert){//没有此英雄的评级记录 插入一条新的
        if(type == RateStarType_Task) {
            sprintf(sql, "insert into hellgate.rate_task_stat "
                " set hero_id=%u, task_id=%u, star=%u "
                , hero_id, task_id, star);
        }
        else if(RateStarType_Chapter) {
            sprintf(sql, "insert into hellgate.rate_chapter_stat "
                " set hero_id=%u, task_id=%u, star=%u "
                , hero_id, task_id, star);
        }
    }
    else {//有记录则更新
        if(type == RateStarType_Task) {
            sprintf(sql, "update hellgate.rate_task_stat "
                " set star=%u "
                " where hero_id=%u and task_id=%u"
                , star
                , hero_id, task_id);
        }
        else if(RateStarType_Chapter) {
            sprintf(sql, "update hellgate.rate_chapter_stat "
                " set star=%u "
                " where hero_id=%u and task_id=%u"
                , star
                , hero_id, task_id);
        }
    }

    try
    {
        Mysql_Thread_Conn->Query(sql);
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    
}


/* 给关卡评级 */
void ProcServerThread::rateTask(unsigned int hero_id, unsigned int task_id, 
    unsigned int team_pos[], HeroState herostat, unsigned int guaiwu_attach_time, unsigned int attached_round)
{
    unsigned int star = 1;
    bool b_not_died = true;
    bool b_round = true;

    if(guaiwu_attach_time == 1 ) {
        //是否无角色阵亡
        for(int i=0; i<4; i++) {
            if(team_pos[i] > 0) {
                if(herostat.currentHp_A[i] == 0) {
                    b_not_died = false;
                    break;
                }
            }
        }

        //战斗回合是否小于等于5
        unsigned int round_num = 
            herostat.roundNumForA>herostat.roundNumForB ? herostat.roundNumForA : herostat.roundNumForB;
        if(round_num > 5 ) {
            b_round = false;
        }

        //开始评星级
        if(b_not_died)
            star = 2;

        if(b_round)
            star = 3;
    }
    else { //多波怪物的特殊关卡
        if(attached_round == 6) {
            star = 3;
        }
        else if(attached_round > 3) {
            star = 2;
        }
        else if(attached_round == 3) {
            star = 1;
        }
        else {
            star = 0;
        }
    }

    //更新
    updateRateTaskStarStat(RateStarType_Task, hero_id, task_id, star);
}


/* 给章节评级 */
void ProcServerThread::rateChapter(unsigned int hero_id, unsigned int chapter_id)
{
    char sql[1024];
    unsigned int all_star = 0;
    unsigned int star = 1;
    
    //首先获取主任务进度
    unsigned int maintask_last_actived  = 1;
    {
        char sql[1024];
        sprintf(sql, "select maintask_last_actived, status "
            " from hellgate.hero_maintask_progress "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                unsigned int status = atoi(Mysql_Thread_Conn->GetField("status"));
                maintask_last_actived = atoi(Mysql_Thread_Conn->GetField("maintask_last_actived"));

                if(maintask_last_actived == (chapter_id*10) ) {
                    if(status <TaskStatus_Finished)
                        return;
                }
                else if(maintask_last_actived < (chapter_id*10 +1)){
                    //没有打完当前章节 不能给章节评级
                    return;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //查询小关卡是否全是金星
    sprintf(sql, "select star from hellgate.rate_task_stat "
        " where hero_id=%u and task_id>%u and task_id<=%u"
        , hero_id, (chapter_id-1)*10, chapter_id*10);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        while(Mysql_Thread_Conn->FetchRow() != NULL){
            all_star += atoi(Mysql_Thread_Conn->GetField("star"));
        }
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    
    if(all_star >= 30) {
        star = 2;
    }
    
    //更新
    updateRateTaskStarStat(RateStarType_Chapter, hero_id, chapter_id, star);
}


bool ProcServerThread::get_ratetask_bonus(unsigned int hero_id, unsigned int type, 
    unsigned int task_id, unsigned int star)
{
    char field[32], table[32];
    if(type == RateStarType_Task) {
        sprintf(table, "rate_task_stat");
    }
    else if(type == RateStarType_Chapter) {
        sprintf(table, "rate_chapter_stat");
    }
    else {
        LogMsg("%s, line %d, rate type[%u] error"
            , __FILE__, __LINE__, type);
        return false;
    }

    if(star == RateStarLevel_Cuprum) {
        sprintf(field, "is_get_cuprum");
    }
    else if(star == RateStarLevel_Silver) {
        sprintf(field, "is_get_silver");
    }
    else if(star == RateStarLevel_Gold) {
        sprintf(field, "is_get_gold");
    }
    else {
        LogMsg("%s, line %d, rate star[%u] error"
            , __FILE__, __LINE__, star);
        return false;
    }
    
    unsigned int cur_star = 0;
    bool is_get = false;
    { //查询英雄关卡评级状态
        char sql[1024];
        sprintf(sql, "select star, %s from hellgate.%s "
            " where hero_id=%u and task_id=%u "
            , field, table
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                cur_star = atoi(Mysql_Thread_Conn->GetField("star"));
                is_get = (bool)atoi(Mysql_Thread_Conn->GetField(field));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    if(type==RateStarType_Chapter && cur_star>=2) { //章节评级没有银星 2就表示是金星
        cur_star = RateStarLevel_Gold;
    }
    
    if(star > cur_star) {
        LogMsg("%s, line %d, rate star[%u] error"
            , __FILE__, __LINE__, star);
        return false;
    }

    if(is_get) {
        LogMsg("%s, line %d, hero[%u], task[%u], star[%u] always got bonus "
            , __FILE__, __LINE__, hero_id, task_id, star);
        return false;
    }

    int select_star = star;
    if(type==RateStarType_Chapter && star==RateStarLevel_Gold) {
        //章节评级没有银星 表中2就表示是金星 
        select_star = 2;
    }
    
    __RateBonus tmp_bonus;
    { //查询关卡评级奖励模板中的奖励内容
        char sql[1024];
            sprintf(sql, "select * from hellgate.%s "
                " where task_id=%u and star=%u order by item_type "
                , type==RateStarType_Task ? (char*)"rate_task_temp" : (char*)"rate_chapter_temp"
                , task_id, select_star);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) 
            {
                tmp_bonus.exp = atoi(Mysql_Thread_Conn->GetField("exp"));
                
                ItemInfo item;
                item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                
                if(item.count > 0){
                    tmp_bonus.item_vec.push_back(item);
                }
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


    //把奖励放到包裹中
    for(int i=0; i<tmp_bonus.item_vec.size(); ++i){
        ObtainItem(hero_id, tmp_bonus.item_vec[i].type, tmp_bonus.item_vec[i].count);
    }
    //把经验放到英雄上去
    if(tmp_bonus.exp > 0){
        obtainExp(hero_id, tmp_bonus.exp);
    }

    { //修改英雄关卡评级领取状态
        char sql[1024];
        sprintf(sql, "update hellgate.%s set "
            " %s=1 where hero_id=%u and task_id=%u"
            , table, field
            , hero_id, task_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    
    }

    return true;
}


unsigned int ProcServerThread::getHeroVipInfo(unsigned int hero_id, VIP_FIELD_TYPE type)
{
    char sql[1024];
    char field[32];
    unsigned int result_value = 0;
    switch(type) {
        case VIP_FIELD_TYPE_VITALITY:
            snprintf(field, 32, "%s", "buy_vitality_num");
            break;
        case VIP_FIELD_TYPE_SWEEP:
            snprintf(field, 32, "%s", "sweep_num");
            break;
        case VIP_FIELD_TYPE_ARENA:
            snprintf(field, 32, "%s", "buy_arena_num");
            break;
        case VIP_FIELD_TYPE_REFRESH_REWAED:
            snprintf(field, 32, "%s", "refresh_reward_num");
            break;
        case VIP_FIELD_TYPE_CAST_SILVER:
            snprintf(field, 32, "%s", "cast_silver_num");
            break;
        default:
            break;
    }

    sprintf(sql, "select %s from hellgate.hero_vip_info "
        " where hero_id=%u"
        , field
        , hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL){
            result_value = atoi(Mysql_Thread_Conn->GetField(field));
        }
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    return result_value;
}


void ProcServerThread::updateHeroVipInfo(unsigned int hero_id, VIP_FIELD_TYPE type, unsigned int value)
{
    char sql[1024];
    switch(type) {
        case VIP_FIELD_TYPE_VITALITY:
            sprintf(sql, "update hellgate.hero_vip_info set "
                " buy_vitality_num=%u"
                " where hero_id=%u"
                , value
                , hero_id);
            break;
        case VIP_FIELD_TYPE_SWEEP:
            sprintf(sql, "update hellgate.hero_vip_info set "
                " sweep_num=%u"
                " where hero_id=%u"
                , value
                , hero_id);
            break;
        case VIP_FIELD_TYPE_ARENA:
            sprintf(sql, "update hellgate.hero_vip_info set "
                " buy_arena_num=%u"
                " where hero_id=%u"
                , value
                , hero_id);
            break;
        case VIP_FIELD_TYPE_REFRESH_REWAED:
            sprintf(sql, "update hellgate.hero_vip_info set "
                " refresh_reward_num=%u"
                " where hero_id=%u"
                , value
                , hero_id);
            break;
        case VIP_FIELD_TYPE_CAST_SILVER:
            sprintf(sql, "update hellgate.hero_vip_info set "
                " cast_silver_num=%u "
                " where hero_id=%u"
                , value
                , hero_id);
            break;
        default:
            return;
            break;
    }
    
    try
    {
        Mysql_Thread_Conn->Query(sql);
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
}


void ProcServerThread::refreshHeroVipInfo(unsigned int hero_id)
{
    char sql[1024];
    unsigned int old_time = 0;
    unsigned int vip_level = 0;

    {
        sprintf(sql, "select last_refresh_timestamp, vip_level from hellgate.hero_vip_info "
            " where hero_id=%u "
            , hero_id );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL){
                old_time = atoi(Mysql_Thread_Conn->GetField("last_refresh_timestamp"));
                vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    bool need_refresh = isNeedSystemDailyRefresh(old_time, SystemDailyTask_Hour);
    if(need_refresh)
    {
        VIP_Info v_info;
        v_info.level = vip_level;

        //查询该vip等级的特权信息
        sprintf(sql, "select * from hellgate.vip_template "
            " where level=%u "
            , vip_level );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                v_info.total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                v_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                v_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                v_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                v_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                v_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                v_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                v_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id[%u] not exist"
                        , __FILE__, __LINE__, hero_id);

                Mysql_Thread_Conn->FreeResult();
                return;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //刷新特权信息
        sprintf(sql, "update hellgate.hero_vip_info set "
            " buy_vitality_num=%u, sweep_num=%u, cast_silver_num=%u, "
            " buy_arena_num=%u, refresh_reward_num=%u, "
            " last_refresh_timestamp=%u "
            " where hero_id=%u"
            , v_info.priv.buy_vitality_num, v_info.priv.sweep_num, v_info.priv.cast_silver_num
            , v_info.priv.buy_arena_num, v_info.priv.refresh_reward_num
            , (unsigned int)time(NULL)
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


unsigned int ProcServerThread::poll_drop_equip(unsigned int hero_id, std::map<unsigned int, std::vector<unsigned int> > *zb_type_map)
{
    unsigned int pos = 0;
    char sql[1024];
    //查询该英雄的职业
    {
        sprintf(sql, "select profession_id from hellgate.hero_infor "
            " where hero_id=%u "
            , hero_id );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                pos = atoi(Mysql_Thread_Conn->GetField("profession_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //if((pos!=Profession_Yemanren) && (pos!=Profession_Chike) && (pos!=Profession_Fashi))
    //  return ZhuangbeiType_DanshouJian;

    std::map<unsigned int, unsigned int> poll_map;
    //查询该英雄装备掉落数量
    {
        sprintf(sql, "select * from hellgate.zb_poll_drop "
            " where hero_id=%u "
            , hero_id );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int count;
                if(pos == Profession_Yemanren)
                {
                    count = atoi(Mysql_Thread_Conn->GetField("shuang_shou_fu"));
                    poll_map.insert(make_pair((unsigned int)ZhuangbeiType_ShuangshouFu, count));
                }
                else if(pos == Profession_Chike)
                {
                    count = atoi(Mysql_Thread_Conn->GetField("shuang_shou_bi_shou"));
                    poll_map.insert(make_pair((unsigned int)ZhuangbeiType_ShuangshouBishou, count));
                }
                else if(pos == Profession_Fashi)
                {
                    count = atoi(Mysql_Thread_Conn->GetField("dan_shou_fa_zhang"));
                    poll_map.insert(make_pair((unsigned int)ZhuangbeiType_DanshouFazhang, count));
                    count = atoi(Mysql_Thread_Conn->GetField("fa_qi"));
                    poll_map.insert(make_pair((unsigned int)ZhuangbeiType_Faqi, count));
                }
                
                count = atoi(Mysql_Thread_Conn->GetField("dan_shou_jian"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_DanshouJian, count));
                count = atoi(Mysql_Thread_Conn->GetField("gong"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_Gong, count));
                count = atoi(Mysql_Thread_Conn->GetField("dun_pai"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_Dunpai, count));
                count = atoi(Mysql_Thread_Conn->GetField("hu_shen_fu"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_Hushenfu, count));
                count = atoi(Mysql_Thread_Conn->GetField("kui_jia_zhong"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_KuijiaZhong, count));
                count = atoi(Mysql_Thread_Conn->GetField("kui_jia_qin"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_KuijiaQin, count));
                count = atoi(Mysql_Thread_Conn->GetField("jie_zhi"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_Jiezhi, count));
                count = atoi(Mysql_Thread_Conn->GetField("shuang_shou_fa_zhang"));
                poll_map.insert(make_pair((unsigned int)ZhuangbeiType_ShuangshouFazhang, count));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(poll_map.empty())
    {//没有此英雄的数据 插入新纪录
        sprintf(sql, "insert into hellgate.zb_poll_drop "
            " set hero_id=%u, dan_shou_jian=1 "
            , hero_id );
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
            return ZhuangbeiType_DanshouJian;
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int min_count = 99999999;
    unsigned int min_type = 0;
    bool b_poll = true;

    std::map<unsigned int, unsigned int>::iterator p;
    std::map<unsigned int, std::vector<unsigned int> >::iterator p_zb;
    std::vector<unsigned int> order_vec;
    //第一次根据主英雄循环掉装
    if(pos == Profession_Yemanren) { //野蛮人掉装顺序
        order_vec.insert(order_vec.end(), ZhuangbeiType_DanshouJian);
        order_vec.insert(order_vec.end(), ZhuangbeiType_KuijiaQin);
        order_vec.insert(order_vec.end(), ZhuangbeiType_KuijiaZhong);
        order_vec.insert(order_vec.end(), ZhuangbeiType_ShuangshouFazhang);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Dunpai);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Gong);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Jiezhi);
        order_vec.insert(order_vec.end(), ZhuangbeiType_ShuangshouFu);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Hushenfu);
    }
    else if(pos == Profession_Chike) { //刺客掉装顺序
        order_vec.insert(order_vec.end(), ZhuangbeiType_DanshouJian);
        order_vec.insert(order_vec.end(), ZhuangbeiType_KuijiaQin);
        order_vec.insert(order_vec.end(), ZhuangbeiType_KuijiaZhong);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Gong);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Dunpai);
        order_vec.insert(order_vec.end(), ZhuangbeiType_ShuangshouFazhang);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Jiezhi);
        order_vec.insert(order_vec.end(), ZhuangbeiType_ShuangshouBishou);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Hushenfu);
    }
    else if(pos == Profession_Chike) { //法师掉装顺序
        order_vec.insert(order_vec.end(), ZhuangbeiType_DanshouJian);
        order_vec.insert(order_vec.end(), ZhuangbeiType_KuijiaQin);
        order_vec.insert(order_vec.end(), ZhuangbeiType_KuijiaZhong);
        order_vec.insert(order_vec.end(), ZhuangbeiType_ShuangshouFazhang);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Dunpai);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Gong);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Jiezhi);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Faqi);
        order_vec.insert(order_vec.end(), ZhuangbeiType_DanshouFazhang);
        order_vec.insert(order_vec.end(), ZhuangbeiType_Hushenfu);
    }
         
    for(int i=0; i<order_vec.size(); i++){
        p = poll_map.find(order_vec[i]);
        p_zb = zb_type_map->find(order_vec[i]);
        if(p_zb == zb_type_map->end()){
            poll_map.erase(p);
            continue;
        }
        if(p->second > 0)
            continue;

        //找到了掉装为0, 且掉装map之中有
        min_type = order_vec[i];
        b_poll = false;
        break;
    } 
    
    if(b_poll) { 
        p = poll_map.begin();
        while(p != poll_map.end()){
            if(p->second <= min_count){
                min_type = p->first;
                min_count = p->second;
            }
            p++;
        }
    }
    
    char field[32];
    switch(min_type){
        case ZhuangbeiType_DanshouJian:
            sprintf(field, "dan_shou_jian");
            break;
        case ZhuangbeiType_ShuangshouBishou:
            sprintf(field, "shuang_shou_bi_shou");
            break;
        case ZhuangbeiType_ShuangshouFu:
            sprintf(field, "shuang_shou_fu");
            break;
        case ZhuangbeiType_DanshouFazhang:
            sprintf(field, "dan_shou_fa_zhang");
            break;
        case ZhuangbeiType_Gong:
            sprintf(field, "gong");
            break;
        case ZhuangbeiType_Faqi:
            sprintf(field, "fa_qi");
            break;
        case ZhuangbeiType_Dunpai:
            sprintf(field, "dun_pai");
            break;
        case ZhuangbeiType_Hushenfu:
            sprintf(field, "hu_shen_fu");
            break;
        case ZhuangbeiType_KuijiaZhong:
            sprintf(field, "kui_jia_zhong");
            break;
        case ZhuangbeiType_KuijiaQin:
            sprintf(field, "kui_jia_qin");
            break;
        case ZhuangbeiType_Jiezhi:
            sprintf(field, "jie_zhi");
            break;
        case ZhuangbeiType_ShuangshouFazhang:
            sprintf(field, "shuang_shou_fa_zhang");
            break;
    }

    //更新此装备掉落数量
    {
        sprintf(sql, "update hellgate.zb_poll_drop set "
            " %s=%s+1 where hero_id=%u"
            , field, field, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return min_type;
}


bool ProcServerThread::query_bonus(unsigned int main_hero_id, unsigned int type,
    std::vector<__BonusInfo> *bonus_vec_p)
{
    for(int i=0; i<BonusType_Reward; ++i) {
        bonus_vec_p[i].clear();
    }
    
    if(type == BonusType_Invalid) {
        LogMsg("%s, line %d, bonus type error", __FILE__, __LINE__);
        return false;
    }
    else if(type == BonusType_All) {
        bool result = query_daily_bonus(main_hero_id, bonus_vec_p[BonusType_DailyLogin-1]);
        result &= query_level_bonus(main_hero_id, bonus_vec_p[BonusType_Level-1]);
        result &= query_system_bonus(main_hero_id, BonusType_DayWelfare, bonus_vec_p[BonusType_DayWelfare-1]);
        result &= query_system_bonus(main_hero_id, BonusType_Reward, bonus_vec_p[BonusType_Reward-1]);

        return result;
    }
    else if(type == BonusType_DailyLogin) {
        return query_daily_bonus(main_hero_id, bonus_vec_p[type-1]);
    }
    else if(type == BonusType_Level) {
        return query_level_bonus(main_hero_id, bonus_vec_p[type-1]);
    }
    else {
        return query_system_bonus(main_hero_id, type, bonus_vec_p[type-1]);
    }
    
    return true;
}


bool ProcServerThread::query_daily_bonus(unsigned int main_hero_id, std::vector<__BonusInfo> &bonus_vec)
{
    bonus_vec.clear();

    unsigned int q_day = 0, q_time = 0, get_stat = 0;
    bool is_not_exist = false;
    { //查询每日登陆奖励状态
        char sql[1024];
        sprintf(sql, "select days_id, get_timestamp, get_stat from hellgate.daily_login_bonus_hero "
            " where hero_id=%u order by days_id "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                q_day = atoi(Mysql_Thread_Conn->GetField("days_id"));
                q_time = atoi(Mysql_Thread_Conn->GetField("get_timestamp"));
                get_stat = atoi(Mysql_Thread_Conn->GetField("get_stat"));
            }
            else {
                is_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(is_not_exist) { //记录存在 插入新纪录
        q_time = (unsigned int)(time(NULL)) - (3600 *24 +1);
        char sql[1024];
        sprintf(sql, "insert into hellgate.daily_login_bonus_hero set "
            " hero_id=%u, days_id=%u, get_timestamp=%u "
            , main_hero_id, q_day, q_time);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[0];
    std::map<unsigned int, __BonusInfo>::iterator p;

    bool is_new_day = false;
    if(q_day <= 7 ) { //小于等于7天时 使用自然时间作为登录累计
        int days = pastSystemDays(q_time, SystemDailyTask_Hour);
        if(days > 0 ) { //超过一天则累计
            is_new_day = true;
            q_day += days;

            if(q_day > 8) {
                q_day = 8;
            }
        }
        
    }
    else { //大于7天时 使用用户操作时间作为登录累计
        is_new_day = isNeedSystemDailyRefresh(q_time, SystemDailyTask_Hour);
        if(is_new_day)  //如果时间已经跨天，奖励换为新的一天的奖励
            q_day++;
        
    }

    if(q_day <= 7) { //7天之内就发前7天的奖励
        unsigned int tmp_day = 1;
        for(int i=0; i<7; ++i, ++tmp_day) {
            p = p_bonus_map->find(tmp_day);

            if(p == p_bonus_map->end()) {
                break;
            }
            __BonusInfo info = p->second;    //copy一个结构体出来

            info.bonus_id = tmp_day;
            if(tmp_day < q_day) {
                info.is_get = (bool)((get_stat >> (tmp_day-1)) & 0x1);
            }
            else if(tmp_day == q_day) {
                info.enable = true;
                info.is_get = (!is_new_day);
            }
            
            //插入到输出容器中
            bonus_vec.push_back(info);
        }
    }
    else { //7天之外就发当天以后30天的奖励
        unsigned int tmp_day = q_day;
        const int max_day_id = 22;
        const int cycle_day = 15;
        for(int i=0; i<30; ++i, ++tmp_day) {
            if(tmp_day > max_day_id) {
                p = p_bonus_map->find((tmp_day-max_day_id)%cycle_day + (max_day_id-cycle_day +1));
            }
            else {
                p = p_bonus_map->find(tmp_day);
            }

            if(p == p_bonus_map->end()) {
                break;
            }

            __BonusInfo info = p->second;    //copy一个结构体出来

            info.bonus_id = tmp_day;
            if(tmp_day == q_day) {
                info.enable = true;
                info.is_get = (!is_new_day);
            }
            
            //插入到输出容器中
            bonus_vec.push_back(info);
        }
    }
    
    //填充赠送装备信息
    fill_zhuangbei_bonus(main_hero_id, bonus_vec);
    
    return true;
}


bool ProcServerThread::query_level_bonus(unsigned int main_hero_id, std::vector<__BonusInfo> &bonus_vec)
{
    bonus_vec.clear();

    //获取英雄等级
    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);

    std::vector<BonuStatus> status_vec;
    { //查询用户状态表
        char sql[1024];
        sprintf(sql, "select level_id, is_get from hellgate.level_bonus_hero "
            " where hero_id=%u order by level_id"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                BonuStatus stat;
                stat.id = atoi(Mysql_Thread_Conn->GetField("level_id"));
                stat.is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                                
                if(stat.id > 0)
                    status_vec.insert(status_vec.end(), stat);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[1];
    std::map<unsigned int, __BonusInfo>::iterator p;
    if(status_vec.empty()) {
        p = p_bonus_map->begin();
        while(p != p_bonus_map->end()) {
            __BonusInfo info = p->second;   //copy一个结构体出来

            { //插入新的记录
                char sql[1024];
                sprintf(sql, "insert into hellgate.level_bonus_hero set "
                    " hero_id=%u, level_id=%u, is_get=0 "
                    , main_hero_id, info.bonus_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            info.enable = (hero_info.level >= info.bonus_id ? true : false);

            //插入到输出容器中
            bonus_vec.push_back(info);
            
            p++;
        }
    } 
    else {
        for(int i=0; i<status_vec.size(); ++i) {
            BonuStatus stat = status_vec[i];
            
            p = p_bonus_map->find(stat.id);
            if(p == p_bonus_map->end()) 
                continue;
            
            __BonusInfo info = p->second;   //copy一个结构体出来
            
            info.is_get = stat.is_get;
            info.enable = (hero_info.level >= stat.id ? true : false);
            //插入到输出容器中
            bonus_vec.push_back(info);
        }
    }
    
    //填充赠送装备信息
    fill_zhuangbei_bonus(main_hero_id, bonus_vec);
    
    return true;
}


bool ProcServerThread::query_system_bonus(unsigned int main_hero_id, unsigned int type,
    std::vector<__BonusInfo> &bonus_vec)
{
    bonus_vec.clear();

    std::vector<BonuStatus> status_vec;
    { //查询用户状态表
        char sql[1024];
        sprintf(sql, "select hellgate.system_bonus_hero.id, is_get, is_enable, refresh_timestamp "
            " from hellgate.system_bonus_hero, hellgate.system_bonus_description "
            " where hero_id=%u and type=%u "
            " and hellgate.system_bonus_hero.id=hellgate.system_bonus_description.id " 
            " order by hellgate.system_bonus_hero.id "
            , main_hero_id
            , type==BonusType_DayWelfare?0:1);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                BonuStatus stat;
                stat.id= atoi(Mysql_Thread_Conn->GetField("id"));
                stat.is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                stat.enable = (bool)atoi(Mysql_Thread_Conn->GetField("is_enable"));
                stat.refresh_time = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                
                if(stat.id > 0)
                    status_vec.insert(status_vec.end(), stat);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[2];
    std::map<unsigned int, __BonusInfo>::iterator p;
    time_t cur_time = time(NULL);

    //获取日常任务的排序
    std::vector<int> order_vec;
    if(type == BonusType_DayWelfare) {
        sort_bonus_order(order_vec);
    }
    
    std::vector<__BonusInfo> tmp_bonus_vec;
    if(status_vec.empty()) { //没有数据
        p = p_bonus_map->begin();
        
        tm *p_tm = localtime(&cur_time);
        unsigned int w_day = p_tm->tm_wday;
        
        while(p != p_bonus_map->end()) {
            __BonusInfo info = p->second;   //copy一个结构体出来
            bool b_need_refresh = false;    //计算当天是否刷新
            if(w_day == 0) { //周日
                b_need_refresh = (bool)((info.w_day >> 6) & 0x1);
            }
            else {  //周一至周六
                b_need_refresh = (bool)((info.w_day >> (w_day-1)) & 0x1);
            }

            unsigned int task_order = 0;
            for(int i=0; i<order_vec.size(); ++i) {
                if(order_vec[i] == info.bonus_id) { //找到排序
                    task_order = i +1;
                    break;
                }
            }
            
            { //插入新的记录
                char sql[1024];
                sprintf(sql, "insert into hellgate.system_bonus_hero set "
                    " hero_id=%u, id=%u, is_get=0, is_enable=0, "
                    " task_order=%u, refresh_timestamp=%u "
                    , main_hero_id, info.bonus_id
                    , task_order, (unsigned int)cur_time);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }

            if(b_need_refresh && info.type == type) {
                //插入到输出容器中
                tmp_bonus_vec.push_back(info);
            }
            
            p++;
        }
    } 
    else {
        tm *p_tm = localtime(&cur_time);
        unsigned int w_day = p_tm->tm_wday;
        
        for(int i=0; i<status_vec.size(); ++i) {
            BonuStatus stat = status_vec[i];
            
            p = p_bonus_map->find(stat.id);
            if(p == p_bonus_map->end()) 
                continue;
            
            __BonusInfo info = p->second;   //copy一个结构体出来
            bool b_need_refresh = false;    //计算当天是否刷新
            if(w_day == 0) { //周日
                b_need_refresh = (bool)((info.w_day >> 6) & 0x1);
            }
            else {  //周一至周六
                b_need_refresh = (bool)((info.w_day >> (w_day-1)) & 0x1);
            }
            
            if(b_need_refresh && isNeedSystemDailyRefresh(stat.refresh_time, SystemDailyTask_Hour)) {
                //需要刷新
                info.is_get = false;
                info.enable = false;

                unsigned int task_order = 0;
                for(int i=0; i<order_vec.size(); ++i) {
                    if(order_vec[i] == info.bonus_id) { //找到排序
                        task_order = i +1;
                        break;
                    }
                }

                { //更新状态
                    char sql[1024];
                    sprintf(sql, "update hellgate.system_bonus_hero set "
                        " is_get=0, is_enable=0, task_order=%u, refresh_timestamp=%u "
                        " where hero_id=%u and id=%u "
                        , task_order, (unsigned int)cur_time
                        , main_hero_id, info.bonus_id);
                    try
                    {
                        Mysql_Thread_Conn->Query(sql);
                        Mysql_Thread_Conn->FreeResult();
                    }
                    catch(CMysqlException& e)
                    {
                        LogMsg("%s, line %d, mysql exception. [%s]"
                                    , __FILE__, __LINE__, e.GetErrMsg());
                        //
                        exit(1);
                    }
                }
            }
            else {
                info.is_get = stat.is_get;
                info.enable = stat.enable;
            }

            if(b_need_refresh) {//插入到输出容器中
                tmp_bonus_vec.push_back(info);
            }
        }
    }

    if(type == BonusType_DayWelfare) { //日常任务需要排序
        std::vector<unsigned int> id_vec;
        { //查询日常任务的顺序
            char sql[1024];
            sprintf(sql, "select hellgate.system_bonus_hero.id "
                " from hellgate.system_bonus_hero, hellgate.system_bonus_description "
                " where hero_id=%u and type=0 "
                " and hellgate.system_bonus_hero.id=hellgate.system_bonus_description.id " 
                " order by task_order "
                , main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    unsigned int id= atoi(Mysql_Thread_Conn->GetField("id"));
                    
                    if(id > 0)
                        id_vec.insert(id_vec.end(), id);
                }
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        //按照排序输出到容器中 客户端根据此顺序来显示
        for(int i=0; i<id_vec.size(); ++i) {
            for(int j=0; j<tmp_bonus_vec.size(); ++j) {
                if(id_vec[i] == tmp_bonus_vec[j].bonus_id) {
                    bonus_vec.push_back(tmp_bonus_vec[j]);
                    break;
                }
            }
        }
    }
    else { //周常任务不用排序
        bonus_vec = tmp_bonus_vec;
    }
    
    //填充赠送装备信息
    fill_zhuangbei_bonus(main_hero_id, bonus_vec);
    
    return true;
}


bool ProcServerThread::sort_bonus_order(std::vector<int> &order_vec)
{
    order_vec.clear();

    std::vector<int> tmp_vec;
    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[2];
    std::map<unsigned int, __BonusInfo>::iterator p = p_bonus_map->begin();
    for(; p!=p_bonus_map->end(); ++p) {
        if(p->second.type == BonusType_DayWelfare) {
            tmp_vec.push_back(p->second.bonus_id);
        }
    }

    int count = tmp_vec.size();
    for(int i=0; i<count; ++i) {
        int index = Utl::auto_random()%tmp_vec.size();
        order_vec.push_back(tmp_vec[index]);
        tmp_vec.erase(tmp_vec.begin() +index);
    }
    
    return true;
}


void ProcServerThread::fill_zhuangbei_bonus(unsigned int main_hero_id, std::vector<__BonusInfo> &bonus_vec)
{
    //查询英雄职业
    unsigned int profession_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select profession_id, level from hellgate.hero_infor "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
            } 
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(profession_id < Profession_Yemanren || profession_id > Profession_Fashi) {
        LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
            , __FILE__, __LINE__, main_hero_id, profession_id);
        return;
    }

    for(int i=0; i<bonus_vec.size(); ++i) {
        __BonusInfo &info = bonus_vec[i];
        //首先填充随机装备
        info.ran_zb_count = info.prof_zb_ran[profession_id -1];

        //填充指定装备
        for(int j=0; j<info.prof_zb_group_vec[profession_id -1].size(); ++j) {
            unsigned int group_id = info.prof_zb_group_vec[profession_id -1][j];
            __DuanzaoGroupZBInfo zb_info;
            if(query_duanzao_group_zb_info(group_id, zb_info)) {
                info.zb_vec.push_back(zb_info);
            }
        }
    }
}


bool ProcServerThread::present_zhuangbei(unsigned int hero_id, __BonusInfo bonus, unsigned int multiple,
    std::vector<__ZhuangbeiDetail> &zhuangbei_vec)
{
    zhuangbei_vec.clear();
    
    //查询英雄职业
    unsigned int profession_id = 0;
    std::vector<unsigned int> unlocked_prof_vec;
    {
       char sql[1024];
       sprintf(sql, "select hero_id, profession_id from hellgate.hero_infor "
           " where (hero_id=%u or parent_hero_id=%u) and is_yuanshen=0 "
           " and is_unlocked=1 "
           , hero_id, hero_id);
       try
       {
           Mysql_Thread_Conn->Query(sql);
           while(Mysql_Thread_Conn->FetchRow() != NULL) {
               unsigned int tmp_hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
               unsigned int tmp_prof_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));

               if(tmp_hero_id == hero_id)
                    profession_id = tmp_prof_id;

               unlocked_prof_vec.push_back(tmp_prof_id);
           } 
           Mysql_Thread_Conn->FreeResult();
       }
       catch(CMysqlException& e)
       {
           LogMsg("%s, line %d, mysql exception. [%s]"
                       , __FILE__, __LINE__, e.GetErrMsg());
           //
           exit(1);
       }
    }

    if(profession_id < Profession_Yemanren || profession_id > Profession_Fashi) {
       LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
           , __FILE__, __LINE__, hero_id, profession_id);
       return false;
    }

    unsigned int ran_count = bonus.prof_zb_ran[profession_id -1];
    std::vector<unsigned int> present_group_vec = bonus.prof_zb_group_vec[profession_id -1];
    if(ran_count == 0 && present_group_vec.empty()) {
        return true;
    }

    if(ran_count > 0) {
        std::vector<unsigned int> can_use_legend_vec;
        for(int i=0; i<m_shenbing_vec.size(); ++i) {
            for(int j=0; j<unlocked_prof_vec.size(); ++j) {
                if(m_shenbing_vec[i].profession_id == unlocked_prof_vec[j])
                    can_use_legend_vec.push_back(m_shenbing_vec[i].zb_group_id);
            }
        }

        for(int i=0; i<ran_count; i++) {
            unsigned int index = Utl::auto_random()%can_use_legend_vec.size();
            present_group_vec.push_back(can_use_legend_vec[index]);
        }
    }
    
    
        
    for(int i=0; i<present_group_vec.size(); i++){
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(present_group_vec[i]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        for(int i=0; i<multiple; ++i) { // 多倍入库
            __ZhuangbeiDetail detail;
            if(!createZhuangbei(zb_name_id, present_group_vec[i], hero_id, detail))
            {
                LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                        , __FILE__, __LINE__, zb_name_id);
                return false;
            }
            //入库
            detail.zhuangbei_id = ObtainZhuangbei(hero_id, zb_name_id, detail);

            zhuangbei_vec.push_back(detail);
        }
    }

    return true;
}


bool ProcServerThread::check_and_get_bonus(unsigned int hero_id, unsigned int type, unsigned int id, 
    std::vector<__ZhuangbeiDetail> &zhuangbei_vec)
{
    zhuangbei_vec.clear();
    
    //获取英雄等级
    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);
    
    std::map<unsigned int, __BonusInfo> *p_bonus_map;
    std::map<unsigned int, __BonusInfo>::iterator p;

    unsigned int get_stat = 0;
    if(type == BonusType_DailyLogin) { //日常登陆奖励
        unsigned int q_day = 0, q_time = 0;
        { //查询每日登陆奖励状态
            char sql[1024];
            sprintf(sql, "select days_id, get_timestamp, get_stat from hellgate.daily_login_bonus_hero "
                " where hero_id=%u"
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    q_day = atoi(Mysql_Thread_Conn->GetField("days_id"));
                    q_time = atoi(Mysql_Thread_Conn->GetField("get_timestamp"));
                    get_stat = atoi(Mysql_Thread_Conn->GetField("get_stat"));
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(q_day > id) { //领取天数不对
            LogMsg("%s, line %d, hero[%u] days[%u] is error"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }
        
        if(!isNeedSystemDailyRefresh(q_time, SystemDailyTask_Hour)) { //已领取
            LogMsg("%s, line %d, hero[%u] days[%u] is already get the bonus"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }

        if(id <= 7) {
            if((bool)((get_stat >> (id-1)) & 0x1)) {
                LogMsg("%s, line %d, hero[%u] days[%u] is already get the bonus"
                    , __FILE__, __LINE__, hero_id, id);
                return false;
            }
        }
        
        p_bonus_map = &m_bonus_map[0];
        const int max_day_id = 22;
        const int cycle_day = 15;
        unsigned int tmp_id = id;
        if(id > max_day_id) {
            tmp_id = (id - max_day_id)%cycle_day + (max_day_id-cycle_day +1);
        }
        if((p = p_bonus_map->find(tmp_id)) == p_bonus_map->end()) {
            LogMsg("%s, line %d, hero[%u] days[%u] is not exist"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }
    }
    else if(type == BonusType_Level) { //等级奖励
        bool is_get = false;
        { //查询系统奖励状态
            char sql[1024];
            sprintf(sql, "select is_get from hellgate.level_bonus_hero "
                " where hero_id=%u and level_id=%u "
                , hero_id, id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    is_get = atoi(Mysql_Thread_Conn->GetField("is_get"));
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(hero_info.level < id) { //不能领取
            LogMsg("%s, line %d, hero[%u] bonus[%u] can not get"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }
        
        if(is_get) { //已经领取
            LogMsg("%s, line %d, hero[%u] bonus[%u] is already get the bonus"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }
        
        p_bonus_map = &m_bonus_map[1];
        if((p = p_bonus_map->find(id)) == p_bonus_map->end()) {
            LogMsg("%s, line %d, hero[%u] bonus[%u] is not exist"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }

    }
    else if(type == BonusType_DayWelfare || type == BonusType_Reward) { //成就奖励
        bool is_get = false, is_enable = false;
        { //查询成就奖励状态
            char sql[1024];
            sprintf(sql, "select is_get, is_enable from hellgate.system_bonus_hero "
                " where hero_id=%u and id=%u "
                , hero_id, id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    is_get = atoi(Mysql_Thread_Conn->GetField("is_get"));
                    is_enable = atoi(Mysql_Thread_Conn->GetField("is_enable"));
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(!is_enable) { //不能领取
            LogMsg("%s, line %d, hero[%u] bonus[%u] can not get"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }
        
        if(is_get) { //已经领取
            LogMsg("%s, line %d, hero[%u] bonus[%u] is already get the bonus"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }
        
        p_bonus_map = &m_bonus_map[2];
        if((p = p_bonus_map->find(id)) == p_bonus_map->end()) {
            LogMsg("%s, line %d, hero[%u] bonus[%u] is not exist"
                , __FILE__, __LINE__, hero_id, id);
            return false;
        }

    }
    else {
        LogMsg("%s, line %d, bonus type[%u] is error"
            , __FILE__, __LINE__, type);
        return false;
    }

    __BonusInfo &info = p->second;
    unsigned int multiple = 1;
    if(info.vip_level>0 && info.multiple>1 && hero_info.vip_level>=info.vip_level) {
        //一定vip级别多倍奖励a
        multiple = info.multiple;
    }
    
    for(int i=0; i<info.item_vec.size(); ++i){ //道具入库
        if(info.item_vec[i].type == ItemsType_PresentVIP1) {
            present_vip(hero_id, 1);
            continue;
        }
        ObtainItem(hero_id, info.item_vec[i].type, info.item_vec[i].count * multiple);
    }
    
    for(int i=0; i<info.item_suipian_vec.size(); ++i){ //道具碎片入库
        ObtainItemSuipian(hero_id, info.item_suipian_vec[i].item_id, 
            info.item_suipian_vec[i].suipian_id, info.item_suipian_vec[i].suipian_count * multiple);
    }
    
    for(int i=0; i<info.zb_suipian_vec.size(); ++i){ //装备碎片入库
        ObtainZhuangbeiSuipian(hero_id, info.zb_suipian_vec[i].zb_group_id, 
            info.zb_suipian_vec[i].suipian_id, info.zb_suipian_vec[i].suipian_count * multiple);
    }
    
    for(int i=0; i<info.gift_bag_vec.size(); ++i){ //礼包入库
        ObtainGiftBag(hero_id, info.gift_bag_vec[i].id, info.gift_bag_vec[i].count * multiple);
    }
    
    { //体力
        addVitality(hero_id, info.vitality);
    } 

    { //赠送装备
        present_zhuangbei(hero_id, info, multiple, zhuangbei_vec);
    }

    //更新领取状态
    if(type == BonusType_DailyLogin) {
        if(id <= 7) { //把领取那天的状态置为1
            get_stat |= (0x1 << (id -1));   
        }
        
        char sql[1024];
        sprintf(sql, "update hellgate.daily_login_bonus_hero set "
            " days_id=%u, get_timestamp=%u, get_stat=%u "
            " where hero_id=%u"
            , id, (unsigned int)time(NULL), get_stat
            , hero_id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else if(type == BonusType_Level){
        char sql[1024];
        sprintf(sql, "update hellgate.level_bonus_hero set "
            " is_get=1 "
            " where hero_id=%u and level_id=%u"
            , hero_id
            , id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else {
        char sql[1024];
        sprintf(sql, "update hellgate.system_bonus_hero set "
            " is_get=1 "
            " where hero_id=%u and id=%u"
            , hero_id
            , id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::send_system_bonus_notify(unsigned int hero_id, unsigned int type, unsigned int id)
{
#ifdef _DEBUG
        LogMsg("%s, line %d,ProcServerThread::send_system_bonus_notify", __FILE__, __LINE__);
#endif //_DEBUG
    
    std::map<unsigned int, __BonusInfo> *p_bonus_map = NULL;
    std::map<unsigned int, __BonusInfo>::iterator p;
    
    if(type == BonusType_DayWelfare) {
        p_bonus_map = &m_bonus_map[2];

        unsigned int task_order = 0;
        { //查询日常周常任务状态
            char sql[1024];
            sprintf(sql, "select task_order, is_enable from hellgate.system_bonus_hero "
                " where hero_id=%u and id=%u "
                , hero_id, id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    task_order = atoi(Mysql_Thread_Conn->GetField("task_order"));
                    bool is_enable = (bool)atoi(Mysql_Thread_Conn->GetField("is_enable"));
                    if(is_enable) {
                        LogMsg("%s, line %d, hero[%u] system bonus[%u] is always activated "
                            , __FILE__, __LINE__, hero_id, id);
                        return ;
                    }
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return ;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //不是第一个任务 后面就要判断是不是完成了前置任务
        //没有完成前置任务 则不能激活这个任务
        if(task_order > 1) { 
            char sql[1024];
            sprintf(sql, "select is_get from hellgate.system_bonus_hero "
                " where hero_id=%u and task_order=%u "
                , hero_id, task_order-1);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    bool is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                    if(!is_get) {
                        LogMsg("%s, line %d, hero[%u] system bonus[%u] can not activated, "
                            " because prev task not complete. "
                            , __FILE__, __LINE__, hero_id, id);
                        return ;
                    }
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return ;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

        }
    }
    else if(type == BonusType_Reward) {
        p_bonus_map = &m_bonus_map[2];
        
        { //查询日常周常任务状态
            char sql[1024];
            sprintf(sql, "select is_enable from hellgate.system_bonus_hero "
                " where hero_id=%u and id=%u "
                , hero_id, id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    bool is_enable = (bool)atoi(Mysql_Thread_Conn->GetField("is_enable"));
                    if(is_enable) {
                        LogMsg("%s, line %d, hero[%u] system bonus[%u] is always activated "
                            , __FILE__, __LINE__, hero_id, id);
                        return ;
                    }
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return ;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    else if(type == BonusType_Level) {
        p_bonus_map = &m_bonus_map[1];
        
        { //查询等级状态
            char sql[1024];
            sprintf(sql, "select is_get from hellgate.level_bonus_hero "
                " where hero_id=%u and level_id=%u "
                , hero_id, id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    bool is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                    if(is_get) {
                        LogMsg("%s, line %d, hero[%u] level[%u] bonus is always got "
                            , __FILE__, __LINE__, hero_id, id);
                        return ;
                    }
                }
                else {
                    LogMsg("%s, line %d, hero[%u] not exist"
                        , __FILE__, __LINE__, hero_id);
                    return ;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    else {
        return ;
    }
    
    if((p = p_bonus_map->find(id)) == p_bonus_map->end())
        return ;
    if(p->second.enable)
        return ;
    
    if(type == BonusType_DayWelfare || type == BonusType_Reward) { //先更新使能状态
        time_t cur_time = time(NULL);
        tm *p_tm = localtime(&cur_time);
        unsigned int w_day = p_tm->tm_wday;
        
        bool b_need_refresh = false;    //计算当天是否刷新
        if(w_day == 0) { //周日
            b_need_refresh = (bool)((p->second.w_day >> 6) & 0x1);
        }
        else {  //周一至周六
            b_need_refresh = (bool)((p->second.w_day >> (w_day-1)) & 0x1);
        }
        
        if(!b_need_refresh) { //今天不刷新此奖励任务 所以不能激活
            LogMsg("%s, line %d, today is have not the task[%u] "
                , __FILE__, __LINE__, id);
            return ;
        }
        
        char sql[1024];
        sprintf(sql, "update hellgate.system_bonus_hero set "
            " is_enable=1 "
            " where hero_id=%u and id=%u"
            , hero_id
            , id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //再组包推送
    int rspDataLen = sizeof(SPCmd_SendBonusNotify);
    
    SPHead* rspHead;
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = sendBonusNotify;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_SendBonusNotify* rspBody = (SPCmd_SendBonusNotify*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->type = htonl(type);
    rspBody->id = htonl(id);

    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);

    return ;
}


bool ProcServerThread::present_vitality(unsigned int hero_id)
{
    { //增加体力
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set vit_current=vit_current+%u "
            " where hero_id=%u"
            , Vitality_Total, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::load_database_template(void)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::load_database_template", __FILE__, __LINE__);
#endif //_DEBUG

    this->load_daily_bonus_temp();
    this->load_level_bonus_temp();
    this->load_system_bonus_temp();
    this->load_email_temp();
    this->load_assess_weapon();
    this->load_purify_attr_temp();

    this->load_system_notice();
    this->load_market_info();
    
    this->load_levelup_exp();
}


void ProcServerThread::load_daily_bonus_temp(void)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::load_system_bonus_temp", __FILE__, __LINE__);
#endif //_DEBUG

    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[0];
    std::map<unsigned int, __BonusInfo>::iterator p;

    p_bonus_map->clear();
    { //查询奖励模板内容
        char sql[1024];
        sprintf(sql, "select * from hellgate.daily_login_bonus_temp order by id");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int id = atoi(Mysql_Thread_Conn->GetField("id"));

                p = p_bonus_map->find(id);
                if(p == p_bonus_map->end()) {
                    __BonusInfo tmp_info;
                    tmp_info.type = BonusType_DailyLogin;
                    tmp_info.bonus_id = id;
                    p = p_bonus_map->insert(p, make_pair(tmp_info.bonus_id, tmp_info));
                }

                __BonusInfo &info = p->second;
                
                int bonus_type = atoi(Mysql_Thread_Conn->GetField("bonus_type"));
                int bonus_id = atoi(Mysql_Thread_Conn->GetField("bonus_id"));
                unsigned int bonus_count = atoi(Mysql_Thread_Conn->GetField("bonus_count"));

                if(bonus_type <= AttachType_Props) { //道具奖励
                    ItemInfo item;
                    item.type = bonus_id;
                    item.count = bonus_count;

                    if(item.count > 0) {
                        info.item_vec.push_back(item);
                    }
                }
                else if(bonus_type == AttachType_PropsDebris) { //道具碎片
                    ItemSuipianInfo item_deb;
                    item_deb.item_id = bonus_id;
                    item_deb.suipian_count = bonus_count;
                    item_deb.suipian_id = Utl::auto_random()/5;

                    if(item_deb.suipian_count > 0) {
                        info.item_suipian_vec.push_back(item_deb);
                    }
                }
                else if(bonus_type == AttachType_ArmsDebris) { //装备碎片
                    ShenbingSuipianInfo sb_deb;
                    sb_deb.zb_group_id = bonus_id;
                    sb_deb.suipian_count = bonus_count;
                    //碎片id先随机 最后改成固定的
                    sb_deb.suipian_id = Utl::auto_random()/5;

                    if(sb_deb.suipian_count > 0) {
                        info.zb_suipian_vec.push_back(sb_deb);
                    }
                }
                else if(bonus_type == AttachType_Arms) { //装备
                    __DuanzaoGroupZBInfo zb_info;
                    unsigned int prof = atoi(Mysql_Thread_Conn->GetField("hero_profession"));
                    if(prof > Profession_Fashi)
                        continue;
                    else if(prof == 0) { //所有职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                    else if(prof <= Profession_Fashi){  //指定职业主角
                        if(bonus_id == 0) { //随机装备
                            ++(info.prof_zb_ran[prof-1]);
                        }
                        else { //指定装备
                            info.prof_zb_group_vec[prof-1].push_back(bonus_id);
                        }
                    }
                    else { //指定其他职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                }
                else if(bonus_type == AttachType_GiftBag) { //礼包
                    GiftBag gift;
                    gift.id = bonus_id;
                    gift.count = bonus_count;

                    if(gift.count > 0) {
                        info.gift_bag_vec.push_back(gift);
                    }
                }
                else if(bonus_type == AttachType_Vitality) { //体力
                    info.vitality = bonus_count;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_level_bonus_temp(void)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::load_level_bonus_temp", __FILE__, __LINE__);
#endif //_DEBUG

    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[1];
    std::map<unsigned int, __BonusInfo>::iterator p;

    p_bonus_map->clear();
    { //查询奖励模板内容
        char sql[1024];
        sprintf(sql, "select * from hellgate.level_bonus_temp order by id");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int id = atoi(Mysql_Thread_Conn->GetField("id"));

                p = p_bonus_map->find(id);
                if(p == p_bonus_map->end()) {
                    __BonusInfo tmp_info;
                    tmp_info.type = BonusType_Level;
                    tmp_info.bonus_id = id;
                    p = p_bonus_map->insert(p, make_pair(tmp_info.bonus_id, tmp_info));
                }

                __BonusInfo &info = p->second;
                
                int bonus_type = atoi(Mysql_Thread_Conn->GetField("bonus_type"));
                int bonus_id = atoi(Mysql_Thread_Conn->GetField("bonus_id"));
                unsigned int bonus_count = atoi(Mysql_Thread_Conn->GetField("bonus_count"));

                if(bonus_type <= AttachType_Props) { //道具奖励
                    ItemInfo item;
                    item.type = bonus_id;
                    item.count = bonus_count;

                    if(item.count > 0) {
                        info.item_vec.push_back(item);
                    }
                }
                else if(bonus_type == AttachType_PropsDebris) { //道具碎片
                    ItemSuipianInfo item_deb;
                    item_deb.item_id = bonus_id;
                    item_deb.suipian_count = bonus_count;
                    item_deb.suipian_id = Utl::auto_random()/5;

                    if(item_deb.suipian_count > 0) {
                        info.item_suipian_vec.push_back(item_deb);
                    }
                }
                else if(bonus_type == AttachType_ArmsDebris) { //装备碎片
                    ShenbingSuipianInfo sb_deb;
                    sb_deb.zb_group_id = bonus_id;
                    sb_deb.suipian_count = bonus_count;
                    //碎片id先随机 最后改成固定的
                    sb_deb.suipian_id = Utl::auto_random()/5;

                    if(sb_deb.suipian_count > 0) {
                        info.zb_suipian_vec.push_back(sb_deb);
                    }
                }
                else if(bonus_type == AttachType_Arms) { //装备
                    __DuanzaoGroupZBInfo zb_info;
                    unsigned int prof = atoi(Mysql_Thread_Conn->GetField("hero_profession"));
                    if(prof > Profession_Fashi)
                        continue;
                    else if(prof == 0) { //所有职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                    else if(prof <= Profession_Fashi){  //指定职业主角
                        if(bonus_id == 0) { //随机装备
                            ++(info.prof_zb_ran[prof-1]);
                        }
                        else { //指定装备
                            info.prof_zb_group_vec[prof-1].push_back(bonus_id);
                        }
                    }
                    else { //指定其他职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                }
                else if(bonus_type == AttachType_GiftBag) { //礼包
                    GiftBag gift;
                    gift.id = bonus_id;
                    gift.count = bonus_count;

                    if(gift.count > 0) {
                        info.gift_bag_vec.push_back(gift);
                    }
                }
                else if(bonus_type == AttachType_Vitality) { //体力
                    info.vitality = bonus_count;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_system_bonus_temp(void)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::load_system_bonus_temp", __FILE__, __LINE__);
#endif //_DEBUG

    std::map<unsigned int, __BonusInfo> *p_bonus_map = &m_bonus_map[2];
    std::map<unsigned int, __BonusInfo>::iterator p;

    p_bonus_map->clear();
    
    { //查询奖励描述内容
        char sql[1024];
        sprintf(sql, "select * from hellgate.system_bonus_description order by id");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                __BonusInfo info;
                bool type = (bool)atoi(Mysql_Thread_Conn->GetField("type"));
                info.type = (type ? BonusType_Reward : BonusType_DayWelfare);
                info.bonus_id = atoi(Mysql_Thread_Conn->GetField("id"));
                char *des = Mysql_Thread_Conn->GetField("description");
                info.description = std::string(des);
                info.w_day = atoi(Mysql_Thread_Conn->GetField("w_day"));
                info.vip_level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                info.multiple = atoi(Mysql_Thread_Conn->GetField("multiple"));

                if(info.bonus_id > 0) {
                    p_bonus_map->insert(make_pair(info.bonus_id, info));
                }
            }
           
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(p_bonus_map->empty()) {
        LogMsg("%s, line %d, have no system bonus temp", __FILE__, __LINE__);
        return ;
    }

    
    { //查询奖励模板内容
        char sql[1024];
        sprintf(sql, "select * from hellgate.system_bonus_temp order by id");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int id= atoi(Mysql_Thread_Conn->GetField("id"));

                p = p_bonus_map->find(id);
                if(p == p_bonus_map->end())
                    continue;

                 __BonusInfo &info = p->second;
                
                int bonus_type = atoi(Mysql_Thread_Conn->GetField("bonus_type"));
                int bonus_id = atoi(Mysql_Thread_Conn->GetField("bonus_id"));
                unsigned int bonus_count = atoi(Mysql_Thread_Conn->GetField("bonus_count"));

                if(bonus_type <= AttachType_Props) { //道具奖励
                    ItemInfo item;
                    item.type = bonus_id;
                    item.count = bonus_count;

                    if(item.count > 0) {
                        info.item_vec.push_back(item);
                    }
                }
                else if(bonus_type == AttachType_PropsDebris) { //道具碎片
                    ItemSuipianInfo item_deb;
                    item_deb.item_id = bonus_id;
                    item_deb.suipian_count = bonus_count;
                    item_deb.suipian_id = Utl::auto_random()/5;

                    if(item_deb.suipian_count > 0) {
                        info.item_suipian_vec.push_back(item_deb);
                    }
                }
                else if(bonus_type == AttachType_ArmsDebris) { //装备碎片
                    ShenbingSuipianInfo sb_deb;
                    sb_deb.zb_group_id = bonus_id;
                    sb_deb.suipian_count = bonus_count;
                    //碎片id先随机 最后改成固定的
                    sb_deb.suipian_id = Utl::auto_random()/5;

                    if(sb_deb.suipian_count > 0) {
                        info.zb_suipian_vec.push_back(sb_deb);
                    }
                }
                else if(bonus_type == AttachType_Arms) { //装备
                    __DuanzaoGroupZBInfo zb_info;
                    unsigned int prof = atoi(Mysql_Thread_Conn->GetField("hero_profession"));
                    if(prof > Profession_Fashi)
                        continue;
                    else if(prof == 0) { //所有职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                    else if(prof <= Profession_Fashi){  //指定职业主角
                        if(bonus_id == 0) { //随机装备
                            ++(info.prof_zb_ran[prof-1]);
                        }
                        else { //指定装备
                            info.prof_zb_group_vec[prof-1].push_back(bonus_id);
                        }
                    }
                    else { //指定其他职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                }
                else if(bonus_type == AttachType_GiftBag) { //礼包
                    GiftBag gift;
                    gift.id = bonus_id;
                    gift.count = bonus_count;

                    if(gift.count > 0) {
                        info.gift_bag_vec.push_back(gift);
                    }
                }
                else if(bonus_type == AttachType_Vitality) { //体力
                    info.vitality = bonus_count;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_email_temp()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::load_email_temp", __FILE__, __LINE__);
#endif //_DEBUG

    std::map<unsigned int, __EmailInfo> *p_email_map = &m_email_internal_map;
    std::map<unsigned int, __EmailInfo>::iterator p;

    p_email_map->clear();
    { //查询奖励模板内容
        char sql[1024];
        sprintf(sql, "select * from hellgate.email_internal_temp order by id");
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int id = atoi(Mysql_Thread_Conn->GetField("id"));

                if(id==0 || id>MAX_INTERNAL_EMAIL_ID) 
                    continue;

                p = p_email_map->find(id);
                if(p == p_email_map->end()) {
                    __EmailInfo tmp_info;
                    tmp_info.email_id = id;
                    p = p_email_map->insert(p, make_pair(tmp_info.email_id, tmp_info));
                }

                __EmailInfo &info = p->second;
                
                char *des = Mysql_Thread_Conn->GetField("description");
                info.content = std::string(des);

                char *sum = Mysql_Thread_Conn->GetField("summary");
                info.summary = std::string(sum);

                info.type = (EmailType)atoi(Mysql_Thread_Conn->GetField("type"));

                if(info.type!=EmailType_Bonus && info.type!=EmailType_Compensate) 
                    continue;

                int bonus_type = atoi(Mysql_Thread_Conn->GetField("bonus_type"));
                int bonus_id = atoi(Mysql_Thread_Conn->GetField("bonus_id"));
                unsigned int bonus_count = atoi(Mysql_Thread_Conn->GetField("bonus_count"));

                if(bonus_type <= AttachType_Props) { //道具奖励
                    ItemInfo item;
                    item.type = bonus_id;
                    item.count = bonus_count;

                    if(item.count > 0) {
                        info.item_vec.push_back(item);
                    }
                }
                else if(bonus_type == AttachType_PropsDebris) { //道具碎片
                    ItemSuipianInfo item_deb;
                    item_deb.item_id = bonus_id;
                    item_deb.suipian_count = bonus_count;
                    item_deb.suipian_id = Utl::auto_random()/5;

                    if(item_deb.suipian_count > 0) {
                        info.item_suipian_vec.push_back(item_deb);
                    }
                }
                else if(bonus_type == AttachType_ArmsDebris) { //装备碎片
                    ShenbingSuipianInfo sb_deb;
                    sb_deb.zb_group_id = bonus_id;
                    sb_deb.suipian_count = bonus_count;
                    //碎片id先随机 最后改成固定的
                    sb_deb.suipian_id = Utl::auto_random()/5;

                    if(sb_deb.suipian_count > 0) {
                        info.zb_suipian_vec.push_back(sb_deb);
                    }
                }
                else if(bonus_type == AttachType_Arms) { //装备
                    __DuanzaoGroupZBInfo zb_info;
                    unsigned int prof = atoi(Mysql_Thread_Conn->GetField("hero_profession"));
                    if(prof > Profession_Fashi)
                        continue;
                    else if(prof == 0) { //所有职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                    else if(prof <= Profession_Fashi){  //指定职业主角
                        if(bonus_id == 0) { //随机装备
                            ++(info.prof_zb_ran[prof-1]);
                        }
                        else { //指定装备
                            info.prof_zb_group_vec[prof-1].push_back(bonus_id);
                        }
                    }
                    else { //指定其他职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                }
                else if(bonus_type == AttachType_GiftBag) { //礼包
                    GiftBag gift;
                    gift.id = bonus_id;
                    gift.count = bonus_count;

                    if(gift.count > 0) {
                        info.gift_bag_vec.push_back(gift);
                    }
                }
                else if(bonus_type == AttachType_Vitality) { //体力
                    info.vitality = bonus_count;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_system_notice()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::load_system_notice", __FILE__, __LINE__);
#endif //_DEBUG
    m_notice.activity_vec.clear();
    
    { //查询活动公告
        char sql[1024];
        sprintf(sql, "select * from hellgate.notice_activity ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __NoticeActivityInfo info;
                info.type = (NoticeActivityType)atoi(Mysql_Thread_Conn->GetField("type"));
                char *title = Mysql_Thread_Conn->GetField("title");
                char *activity_time = Mysql_Thread_Conn->GetField("activity_time");
                char *content = Mysql_Thread_Conn->GetField("content");
                
                if(info.type != NoticeActivityType_Invalid) {
                    info.title = std::string(title);
                    info.time = std::string(activity_time);
                    info.content = std::string(content);
                    
                    m_notice.activity_vec.push_back(info);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_market_info()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::load_market_info", __FILE__, __LINE__);
#endif //_DEBUG
    m_market_map.clear();
    
    std::map<unsigned int, MarketItem>::iterator p;

    { //查询商城信息
        char sql[1024];
        sprintf(sql, "select * from hellgate.market order by id");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int id = atoi(Mysql_Thread_Conn->GetField("id"));

                p = m_market_map.find(id);
                if(p == m_market_map.end()) {
                    MarketItem tmp_info;
                    tmp_info.id = id;
                    p = m_market_map.insert(p, make_pair(tmp_info.id, tmp_info));
                }
                else { //商城每件商品只有一种
                    continue ;
                }

                MarketItem &info = p->second;

                //售卖货物
                int sell_type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                int sell_id = atoi(Mysql_Thread_Conn->GetField("item_id"));
                unsigned int sell_count = atoi(Mysql_Thread_Conn->GetField("item_count"));

                info.sell_type = sell_type;
                if(sell_type <= AttachType_Props) { //道具
                    if(sell_count > 0) {
                        info.sell_item.item.type = sell_id;
                        info.sell_item.item.count  = sell_count;
                    }
                }
                else if(sell_type == AttachType_PropsDebris) { //道具碎片
                    if(sell_count > 0) {
                        info.sell_item.item_debris.item_id = sell_id;
                        info.sell_item.item_debris.suipian_count = sell_count;
                        info.sell_item.item_debris.suipian_id = Utl::auto_random()/5;
                    }
                }
                else if(sell_type == AttachType_ArmsDebris) { //装备碎片
                    if(sell_count > 0) {
                        info.sell_item.zb_debris.zb_group_id = sell_id;
                        info.sell_item.zb_debris.suipian_count = sell_count;
                        info.sell_item.zb_debris.suipian_id = Utl::auto_random()/5;
                    }
                }
                else if(sell_type == AttachType_GiftBag) { //礼包
                    if(sell_count > 0) {
                        info.sell_item.gift.id = sell_id;
                        info.sell_item.gift.count = sell_count;
                    }
                }
                else if(sell_type == AttachType_Vitality) { //体力
                    info.sell_item.vitality = sell_count;
                }
                else if(sell_type == AttachType_Arms) { //装备
                    //商城不会直接出售装备 错误
                    continue ;
                }

                //购买次数限制
                info.is_unlimit = (bool)atoi(Mysql_Thread_Conn->GetField("sell_type"));
                info.sell_count = atoi(Mysql_Thread_Conn->GetField("sell_count"));


                //售价
                int need_type = atoi(Mysql_Thread_Conn->GetField("need_type"));
                int need_id = atoi(Mysql_Thread_Conn->GetField("need_id"));
                unsigned int need_count = atoi(Mysql_Thread_Conn->GetField("need_count"));

                info.need_type = need_type;
                if(need_type == AttachType_Gold || need_type == AttachType_Silver) { //货币
                    if(need_count > 0) {
                        info.need_item.item.type = need_id;
                        info.need_item.item.count  = need_count;
                    }
                }
                else { //货币类型只有金币或者银币
                    continue ;
                }
                
                //折扣
                info.discount = atoi(Mysql_Thread_Conn->GetField("discount"));

                //出售倒计时
                char *sale_time = Mysql_Thread_Conn->GetField("sale_time");
                if(sale_time == NULL || std::string(sale_time).length()==0) {  
                    info.sale_time = 0;
                }
                else {
                    struct tm tm_time;  
                    strptime(sale_time, "%Y-%m-%d %H:%M:%S", &tm_time);  
                    info.sale_time = (unsigned int)mktime(&tm_time);
                }
                
                //购买限制等级
                info.level_type = atoi(Mysql_Thread_Conn->GetField("need_level_type"));
                info.level = atoi(Mysql_Thread_Conn->GetField("need_level"));
                
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_levelup_exp()
{
#ifdef _DEBUG
    LogMsg("%s, line %d,ProcServerThread::load_levelup_exp", __FILE__, __LINE__);
#endif //_DEBUG
    m_exp_map[0].clear();
    m_exp_map[1].clear();
    
    { //查询等级所需经验
        char sql[1024];
        sprintf(sql, "select * from hellgate.levelup_exp "
            " order by type, level ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int type = atoi(Mysql_Thread_Conn->GetField("type"));
                unsigned int level = atoi(Mysql_Thread_Conn->GetField("level"));
                unsigned int experience = atoi(Mysql_Thread_Conn->GetField("experience"));
                if(type <= 1) {
                    m_exp_map[type].insert(m_exp_map[type].end(), make_pair(level, experience));
                }
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::query_extern_email_info(__EmailInfo &info)
{
    if(info.email_id <= MAX_INTERNAL_EMAIL_ID)
        return;
    
    { //查询奖励模板内容
        char sql[1024];
        sprintf(sql, "select type, bonus_type, bonus_id, bonus_count, hero_profession, summary, description "
            " from hellgate.email_internal_temp "
            " where id=%u "
            , info.email_id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                char *des = Mysql_Thread_Conn->GetField("description");
                info.content = std::string(des);

                char *sum = Mysql_Thread_Conn->GetField("summary");
                info.summary = std::string(sum);

                info.type = (EmailType)atoi(Mysql_Thread_Conn->GetField("type"));

                if(info.type!=EmailType_Bonus && info.type!=EmailType_Compensate) 
                    continue;

                int bonus_type = atoi(Mysql_Thread_Conn->GetField("bonus_type"));
                int bonus_id = atoi(Mysql_Thread_Conn->GetField("bonus_id"));
                unsigned int bonus_count = atoi(Mysql_Thread_Conn->GetField("bonus_count"));

                if(bonus_type <= AttachType_Props) { //道具奖励
                    ItemInfo item;
                    item.type = bonus_id;
                    item.count = bonus_count;

                    if(item.count > 0) {
                        info.item_vec.push_back(item);
                    }
                }
                else if(bonus_type == AttachType_PropsDebris) { //道具碎片
                    ItemSuipianInfo item_deb;
                    item_deb.item_id = bonus_id;
                    item_deb.suipian_count = bonus_count;
                    item_deb.suipian_id = Utl::auto_random()/5;

                    if(item_deb.suipian_count > 0) {
                        info.item_suipian_vec.push_back(item_deb);
                    }
                }
                else if(bonus_type == AttachType_ArmsDebris) { //装备碎片
                    ShenbingSuipianInfo sb_deb;
                    sb_deb.zb_group_id = bonus_id;
                    sb_deb.suipian_count = bonus_count;
                    //碎片id先随机 最后改成固定的
                    sb_deb.suipian_id = Utl::auto_random()/5;

                    if(sb_deb.suipian_count > 0) {
                        info.zb_suipian_vec.push_back(sb_deb);
                    }
                }
                else if(bonus_type == AttachType_Arms) { //装备
                    __DuanzaoGroupZBInfo zb_info;
                    unsigned int prof = atoi(Mysql_Thread_Conn->GetField("hero_profession"));
                    if(prof > Profession_Fashi)
                        continue;
                    else if(prof == 0) { //所有职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                    else if(prof <= Profession_Fashi){  //指定职业主角
                        if(bonus_id == 0) { //随机装备
                            ++(info.prof_zb_ran[prof-1]);
                        }
                        else { //指定装备
                            info.prof_zb_group_vec[prof-1].push_back(bonus_id);
                        }
                    }
                    else { //指定其他职业
                        if(bonus_id == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_id);
                            }
                        }
                    }
                }
                else if(bonus_type == AttachType_GiftBag) { //礼包
                    GiftBag gift;
                    gift.id = bonus_id;
                    gift.count = bonus_count;

                    if(gift.count > 0) {
                        info.gift_bag_vec.push_back(gift);
                    }
                }
                else if(bonus_type == AttachType_Vitality) { //体力
                    info.vitality = bonus_count;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


bool ProcServerThread::query_email(unsigned int main_hero_id, std::vector<__EmailInfo> &email_vec)
{
    email_vec.clear();

    const int delete_time = 3600 *72;
    { //删除阅读过的过期邮件
        char sql[1024];
        sprintf(sql, "delete from hellgate.email_hero "
            " where hero_id=%u and is_read=1 and read_timestamp<=%u "
            , main_hero_id
            , (int)time(NULL)-delete_time);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //检查每日产出发送的邮件  暂时只有英雄榜排名产出
    check_email(main_hero_id);

    
    { //查询用户状态表
        char sql[1024];
        sprintf(sql, "select addresser_id, type, assign_id, id, is_read, content "
            " from hellgate.email_hero "
            " where hero_id=%u order by assign_id"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __EmailInfo info;
                info.email_id = atoi(Mysql_Thread_Conn->GetField("id"));
                info.assign_id = atoi(Mysql_Thread_Conn->GetField("assign_id"));
                info.type = (EmailType)atoi(Mysql_Thread_Conn->GetField("type"));
                info.addresser_id = atoi(Mysql_Thread_Conn->GetField("addresser_id"));
                info.is_read = (bool)atoi(Mysql_Thread_Conn->GetField("is_read"));
                if(info.type == EmailType_Player) {
                    char *content = Mysql_Thread_Conn->GetField("content");
                    info.content = std::string(content);
                }
                
                if(info.assign_id > 0)
                    email_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    std::map<unsigned int, __EmailInfo> *p_email_map = &m_email_internal_map;
    std::map<unsigned int, __EmailInfo>::iterator p;
    for(int i=0; i<email_vec.size(); ++i) { //填充邮件信息
        __EmailInfo &info = email_vec[i];

        if(info.addresser_id > 0) { //查询发件人姓名
            HeroInfo hero_info;
            GetHeroBasicInfo(info.addresser_id, hero_info);
            info.addresser = std::string(hero_info.name);
        }
        else {
            info.addresser = std::string(system_name);
        }

        if(info.type == EmailType_Player)
            continue;

        if(info.email_id <= MAX_INTERNAL_EMAIL_ID) { // 内部系统邮件
            p = p_email_map->find(info.email_id);
            if(p == p_email_map->end())
                continue;
            
            info.content = p->second.content;
            info.summary = p->second.summary;
            info.vitality = p->second.vitality;
            info.item_vec = p->second.item_vec;
            info.item_suipian_vec = p->second.item_suipian_vec;
            info.zb_suipian_vec = p->second.zb_suipian_vec;
            info.gift_bag_vec = p->second.gift_bag_vec;
            for(int j=0; j<Profession_Fashi; ++j) {
            	info.prof_zb_ran[j] = p->second.prof_zb_ran[j];
                info.prof_zb_group_vec[j] = p->second.prof_zb_group_vec[j];
            }
        }
        else { // 外部邮件
            query_extern_email_info(info);
        }
        
    }
    
    //填充赠送装备信息
    fill_zhuangbei_email(main_hero_id, email_vec);
    
    return true;
}


bool ProcServerThread::read_email(unsigned int hero_id, unsigned int assign_id, 
    std::vector<__ZhuangbeiDetail> &zhuangbei_vec)
{
    zhuangbei_vec.clear();

    unsigned int type = 0, id = 0;
    bool is_read = false;
    { //查询玩家邮件状态
        char sql[1024];
        sprintf(sql, "select type, id, is_read from hellgate.email_hero "
            " where hero_id=%u and assign_id=%u "
            , hero_id, assign_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                type = atoi(Mysql_Thread_Conn->GetField("type"));
                id = atoi(Mysql_Thread_Conn->GetField("id"));
                is_read = (bool)atoi(Mysql_Thread_Conn->GetField("is_read"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] id[%u] not exist"
                    , __FILE__, __LINE__, hero_id, assign_id);
                return false;
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(is_read) { //已读
        LogMsg("%s, line %d, hero[%u] id[%u] is already read "
            , __FILE__, __LINE__, hero_id, assign_id);
        return false;
    }

    if((type==EmailType_Bonus || type==EmailType_Compensate) && id > 0) { //有附件的
        __EmailInfo info;
        if(id <= MAX_INTERNAL_EMAIL_ID) { //内部邮件
            std::map<unsigned int, __EmailInfo> *p_email_map = &m_email_internal_map;
            std::map<unsigned int, __EmailInfo>::iterator p;
            p = p_email_map->find(id);

            if(p != p_email_map->end()) {
                info = p->second;
            }
        }
        else { //外部邮件
            query_extern_email_info(info);
        }

        if(info.vitality > 0) { //赠送体力
            char sql[1024];
            sprintf(sql, "update hellgate.hero_infor set vit_current=vit_current+%u "
                " where hero_id=%u"
                , info.vitality, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                exit(1);
            }
        }

        for(int i=0; i<info.item_vec.size(); ++i){ //道具入库
            ObtainItem(hero_id, info.item_vec[i].type, info.item_vec[i].count);
        }

        for(int i=0; i<info.item_suipian_vec.size(); ++i){ //道具碎片入库
            ObtainItemSuipian(hero_id, info.item_suipian_vec[i].item_id, 
                info.item_suipian_vec[i].suipian_id, info.item_suipian_vec[i].suipian_count);
        }

        for(int i=0; i<info.zb_suipian_vec.size(); ++i){ //装备碎片入库
            ObtainZhuangbeiSuipian(hero_id, info.zb_suipian_vec[i].zb_group_id, 
                info.zb_suipian_vec[i].suipian_id, info.zb_suipian_vec[i].suipian_count);
        }

        for(int i=0; i<info.gift_bag_vec.size(); ++i){ //礼包入库
            ObtainGiftBag(hero_id, info.gift_bag_vec[i].id, info.gift_bag_vec[i].count);
        }
           
        { //体力
            addVitality(hero_id, info.vitality);
        } 

        { //赠送装备
            present_zhuangbei_email(hero_id, info, zhuangbei_vec);
        }
    }
    
    //更新领取状态
    {
        char sql[1024];
        sprintf(sql, "update hellgate.email_hero set "
            " is_read=1, read_timestamp=%u "
            " where hero_id=%u and assign_id=%u "
            , (unsigned int)time(NULL)
            , hero_id, assign_id);
        
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
   
    return true;
}


bool ProcServerThread::write_email(unsigned int main_hero_id, unsigned int receiver_id, char* content)
{
    if(receiver_id == 0) {
        LogMsg("%s, line %d, receiver can not empty ", __FILE__, __LINE__);
        return false;
    }
    if(content == NULL) {
        LogMsg("%s, line %d, content can not empty ", __FILE__, __LINE__);
        return false;
    }

    {//发送通知给收件人
        insert_and_send_email(receiver_id, main_hero_id, EmailType_Player, 0, content);
    }
    
    return true;
}


bool ProcServerThread::delete_email(unsigned int main_hero_id, unsigned int assign_id)
{
    { //查询是否存在
        char sql[1024];
        sprintf(sql, "select 1 from hellgate.email_hero "
            " where hero_id=%u and assign_id=%u "
            , main_hero_id, assign_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() == NULL) { // 邮件不存在
                LogMsg("%s, line %d, hero[%u] email[%u] is not exist ", 
                    __FILE__, __LINE__, main_hero_id, assign_id);
                return false;
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    { //删除邮件
        char sql[1024];
        sprintf(sql, "delete from hellgate.email_hero "
            " where hero_id=%u and assign_id=%u "
            , main_hero_id, assign_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


void ProcServerThread::fill_zhuangbei_email(unsigned int main_hero_id, std::vector<__EmailInfo> &email_vec)
{
    //查询英雄职业
    unsigned int profession_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select profession_id, level from hellgate.hero_infor "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
            } 
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(profession_id < Profession_Yemanren || profession_id > Profession_Fashi) {
        LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
            , __FILE__, __LINE__, main_hero_id, profession_id);
        return;
    }

    for(int i=0; i<email_vec.size(); ++i) {
        __EmailInfo &info = email_vec[i];
        //首先填充随机装备
        info.ran_zb_count = info.prof_zb_ran[profession_id -1];

        //填充指定装备
        for(int j=0; j<info.prof_zb_group_vec[profession_id -1].size(); ++j) {
            unsigned int group_id = info.prof_zb_group_vec[profession_id -1][j];
            __DuanzaoGroupZBInfo zb_info;
            if(query_duanzao_group_zb_info(group_id, zb_info)) {
                info.zb_vec.push_back(zb_info);
            }
        }
    }
}


bool ProcServerThread::present_zhuangbei_email(unsigned int hero_id, __EmailInfo email, 
    std::vector<__ZhuangbeiDetail> &zhuangbei_vec)
{
    zhuangbei_vec.clear();
    
    //查询英雄职业
    unsigned int profession_id = 0;
    std::vector<unsigned int> unlocked_prof_vec;
    {
       char sql[1024];
       sprintf(sql, "select hero_id, profession_id from hellgate.hero_infor "
           " where (hero_id=%u or parent_hero_id=%u) and is_yuanshen=0 "
           " and is_unlocked=1 "
           , hero_id, hero_id);
       try
       {
           Mysql_Thread_Conn->Query(sql);
           while(Mysql_Thread_Conn->FetchRow() != NULL) {
               unsigned int tmp_hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
               unsigned int tmp_prof_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));

               if(tmp_hero_id == hero_id)
                    profession_id = tmp_prof_id;

               unlocked_prof_vec.push_back(tmp_prof_id);
           } 
           Mysql_Thread_Conn->FreeResult();
       }
       catch(CMysqlException& e)
       {
           LogMsg("%s, line %d, mysql exception. [%s]"
                       , __FILE__, __LINE__, e.GetErrMsg());
           //
           exit(1);
       }
    }

    if(profession_id < Profession_Yemanren || profession_id > Profession_Fashi) {
       LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
           , __FILE__, __LINE__, hero_id, profession_id);
       return false;
    }

    unsigned int ran_count = email.prof_zb_ran[profession_id -1];
    std::vector<unsigned int> present_group_vec = email.prof_zb_group_vec[profession_id -1];
    if(ran_count == 0 && present_group_vec.empty()) {
        return true;
    }

    if(ran_count > 0) {
        std::vector<unsigned int> can_use_legend_vec;
        for(int i=0; i<m_shenbing_vec.size(); ++i) {
            for(int j=0; j<unlocked_prof_vec.size(); ++j) {
                if(m_shenbing_vec[i].profession_id == unlocked_prof_vec[j])
                    can_use_legend_vec.push_back(m_shenbing_vec[i].zb_group_id);
            }
        }

        for(int i=0; i<ran_count; i++) {
            unsigned int index = Utl::auto_random()%can_use_legend_vec.size();
            present_group_vec.push_back(can_use_legend_vec[index]);
        }
    }
    
    
        
    for(int i=0; i<present_group_vec.size(); i++){
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(present_group_vec[i]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, present_group_vec[i], hero_id, detail))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            return false;
        }
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(hero_id, zb_name_id, detail);

        zhuangbei_vec.push_back(detail);
    }

    return true;
}


unsigned int ProcServerThread::insert_into_email(unsigned int hero_id, unsigned int addresser_id, 
    unsigned int type, unsigned int id, char* content/*=NULL*/)
{ 
    unsigned int max_id = 0;
    { //查询收件人最大邮件assign_id
        char sql[1024];
        sprintf(sql, "select max(assign_id) max_id from hellgate.email_hero "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                char *max_id_str = Mysql_Thread_Conn->GetField("max_id");
                if(max_id_str != NULL)
                    max_id = atoi(max_id_str);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    ++max_id;
    std::string content_str = std::string("");
    if(type == EmailType_Player) 
        Mysql_Thread_Conn->Escape(content_str, content, strlen(content));
    
    { //插入新邮件
        char sql[1024];
        sprintf(sql, "insert into hellgate.email_hero set "
            " hero_id=%u, addresser_id=%u, type=%u, assign_id=%u, "
            " id=%u, is_read=0, send_timestamp=%u, read_timestamp=0, "
            " content='%s' "
            , hero_id, addresser_id, type, max_id
            , id, (unsigned int)time(NULL)
            , content_str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return max_id;
}


void ProcServerThread::send_email_notify(unsigned int hero_id, std::vector<__EmailInfo> &email_vec)
{
#ifdef _DEBUG
        LogMsg("%s, line %d,ProcServerThread::send_email_notify", __FILE__, __LINE__);
#endif //_DEBUG
    
    
    int total_length = 0;      //统计邮件总共长度
    for(int i=0; i<email_vec.size(); ++i) {
        total_length += email_vec[i].get_length();
    }

    SPHead* rspHead;
    int rspDataLen = sizeof(SPCmd_PushEmail) + total_length;
    
    (rspHead) = (SPHead*)new char[sizeof(SPHead) + rspDataLen];
    (rspHead)->protocol_tag = SimpleProtocol_Tag_Server;
    (rspHead)->protocol_ver = 1;
    (rspHead)->cmd = pushEmail;
    (rspHead)->data_len = rspDataLen;
    //将包头转换为网络字节序
    hton_SPHead((rspHead));
    
    SPCmd_PushEmail* rspBody = (SPCmd_PushEmail*)((rspHead)+1);
    rspBody->err_code = htonl(Success);
    rspBody->count = htonl(email_vec.size());

    char * tmp_p = rspBody->email_arr;
    EmailInfo* p = (EmailInfo*)tmp_p;
    unsigned int email_out_len = 0;
    for(int i=0; i<email_vec.size(); ++i)
    {
        email_vec[i].convert2_email_info_hton(p, email_out_len);
        tmp_p += email_out_len;
        p = (EmailInfo*) (tmp_p);
    }
    
    Packet* rsppack = new Packet;
    rsppack->fd_account = "";
    rsppack->client_id = 0;
    rsppack->main_hero_id = hero_id;
    rsppack->packdata = (char*)rspHead;

    m_outport_q->push(rsppack);
}


void ProcServerThread::insert_and_send_email(unsigned int hero_id, unsigned int addresser_id, 
    unsigned int type, unsigned int id, char* content/*=NULL*/)
{
    std::vector<__EmailInfo> email_vec;
    __EmailInfo info;

    info.addresser_id = addresser_id;
    if(content != NULL)
        info.content = std::string(content);
    else 
        info.content = std::string("");
    
    info.type = (EmailType)type;
    info.is_read = false;

    if(addresser_id == 0) {
        info.addresser = std::string(system_name);
    }
    else {
        HeroInfo hero_info;
        GetHeroBasicInfo(info.addresser_id, hero_info);
        info.addresser = std::string(hero_info.name);
    }

    //插入邮件系统
    info.assign_id = insert_into_email(hero_id, addresser_id, type, id, content);

    email_vec.push_back(info);
    send_email_notify(hero_id, email_vec);

    return ;
}


void ProcServerThread::check_email(unsigned int hero_id)
{
    unsigned int hero_order = 10001, refresh_timestamp = 0;
    { //查询昨日排名 和 最后刷新时间
       char sql[1024];
       sprintf(sql, "select hero_order, last_refresh_timestamp from hellgate.top_hero_list "
           " where hero_id=%u "
           , hero_id);
       try
       {
           Mysql_Thread_Conn->Query(sql);
           if(Mysql_Thread_Conn->FetchRow() != NULL) {
               hero_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
               refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("last_refresh_timestamp"));
           } 
           else {
                LogMsg("%s, line %d, hero[%u] have not top hero list record "
                    , __FILE__, __LINE__, hero_id);
                return ;
           }
           Mysql_Thread_Conn->FreeResult();
       }
       catch(CMysqlException& e)
       {
           LogMsg("%s, line %d, mysql exception. [%s]"
                       , __FILE__, __LINE__, e.GetErrMsg());
           //
           exit(1);
       }
    }

    if(!isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour)) {
        //已经刷新过
        return ;
    }
    else { //更新刷新时间
       char sql[1024];
       sprintf(sql, "update hellgate.top_hero_list set "
           " last_refresh_timestamp = %u "
           " where hero_id=%u "
           , (unsigned int)time(NULL)
           , hero_id);
       try
       {
           Mysql_Thread_Conn->Query(sql);
           Mysql_Thread_Conn->FreeResult();
       }
       catch(CMysqlException& e)
       {
           LogMsg("%s, line %d, mysql exception. [%s]"
                       , __FILE__, __LINE__, e.GetErrMsg());
           //
           exit(1);
       }
    }

    EmailID email_id = EmailID_Invalid;
    if(hero_order > 5000 && hero_order <= 10000) {
        email_id = EmailID_TopList_5001_1w;
    } 
    else if(hero_order > 2000 && hero_order <= 5000) {
        email_id = EmailID_TopList_2001_5k;
    } 
    else if(hero_order > 1000 && hero_order <= 2000) {
        email_id = EmailID_TopList_1001_2k;
    } 
    else if(hero_order > 200 && hero_order <= 1000) {
        email_id = EmailID_TopList_201_1k;
    } 
    else if(hero_order > 100 && hero_order <= 200) {
        email_id = EmailID_TopList_101_200;
    } 
    else if(hero_order > 30 && hero_order <= 100) {
        email_id = EmailID_TopList_31_100;
    }  
    else if(hero_order > 10 && hero_order <= 30) {
        email_id = EmailID_TopList_11_30;
    } 
    else if(hero_order > 3 && hero_order <= 10) {
        email_id = EmailID_TopList_4_10;
    } 
    else if(hero_order == 3) {
        email_id = EmailID_TopList_3;
    }
    else if(hero_order == 2) {
        email_id = EmailID_TopList_2;
    } 
    else if(hero_order == 1) {
        email_id = EmailID_TopList_1;
    } 
    else {
        return ;
    }

    //插入邮件
    insert_into_email(hero_id, 0, EmailType_Bonus, email_id);
    
}


bool ProcServerThread::present_zhuangbei_gift_bag(unsigned int hero_id, __GiftBagInfo &gift_bag)
{
    gift_bag.zb_vec.clear();
    
    //查询英雄职业
    unsigned int profession_id = 0;
    std::vector<unsigned int> unlocked_prof_vec;
    {
       char sql[1024];
       sprintf(sql, "select hero_id, profession_id from hellgate.hero_infor "
           " where (hero_id=%u or parent_hero_id=%u) and is_yuanshen=0 "
           " and is_unlocked=1 "
           , hero_id, hero_id);
       try
       {
           Mysql_Thread_Conn->Query(sql);
           while(Mysql_Thread_Conn->FetchRow() != NULL) {
               unsigned int tmp_hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
               unsigned int tmp_prof_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));

               if(tmp_hero_id == hero_id)
                    profession_id = tmp_prof_id;

               unlocked_prof_vec.push_back(tmp_prof_id);
           } 
           Mysql_Thread_Conn->FreeResult();
       }
       catch(CMysqlException& e)
       {
           LogMsg("%s, line %d, mysql exception. [%s]"
                       , __FILE__, __LINE__, e.GetErrMsg());
           //
           exit(1);
       }
    }

    if(profession_id < Profession_Yemanren || profession_id > Profession_Fashi) {
       LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
           , __FILE__, __LINE__, hero_id, profession_id);
       return false;
    }

    unsigned int ran_count = gift_bag.prof_zb_ran[profession_id -1];
    std::vector<unsigned int> present_group_vec = gift_bag.prof_zb_group_vec[profession_id -1];
    if(ran_count == 0 && present_group_vec.empty()) {
        return true;
    }

    if(ran_count > 0) {
        std::vector<unsigned int> can_use_legend_vec;
        for(int i=0; i<m_shenbing_vec.size(); ++i) {
            for(int j=0; j<unlocked_prof_vec.size(); ++j) {
                if(m_shenbing_vec[i].profession_id == unlocked_prof_vec[j])
                    can_use_legend_vec.push_back(m_shenbing_vec[i].zb_group_id);
            }
        }

        for(int i=0; i<ran_count; i++) {
            unsigned int index = Utl::auto_random()%can_use_legend_vec.size();
            present_group_vec.push_back(can_use_legend_vec[index]);
        }
    }
    
    
        
    for(int i=0; i<present_group_vec.size(); i++){
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(present_group_vec[i]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, present_group_vec[i], hero_id, detail))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            return false;
        }
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(hero_id, zb_name_id, detail);

        gift_bag.zb_vec.push_back(detail);
    }

    return true;
}


bool ProcServerThread::get_gift_bag(unsigned int main_hero_id, unsigned int id,
    std::vector<__GiftBagInfo> &gift_bag_vec)
{
    gift_bag_vec.clear();
    
    unsigned int gift_bag_count = 0;
    { //查询礼包池
        char sql[1024];
        sprintf(sql, "select gift_bag_count "
            " from hellgate.gift_bag_hero "
            " where hero_id=%u and gift_bag_id=%u "
            , main_hero_id, id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                gift_bag_count = atoi(Mysql_Thread_Conn->GetField("gift_bag_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(gift_bag_count == 0) {
        LogMsg("%s, line %d, hero[%u], gift bag[%u] is not enough"
            , __FILE__, __LINE__, main_hero_id, id);
        return false;
    }

    //填充礼包
    if(!fill_gift_bag(main_hero_id, id, gift_bag_vec)) {
        return false;
    }

    { //更新状态
        char sql[1024];
        sprintf(sql, "update hellgate.gift_bag_hero "
            " set gift_bag_count=gift_bag_count-1 "
            " where hero_id=%u and gift_bag_id=%u "
            , main_hero_id, id);
        try
        {
            Mysql_Thread_Conn->Query(sql);            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


bool ProcServerThread::fill_gift_bag(unsigned int main_hero_id, unsigned int id,
    std::vector<__GiftBagInfo> &gift_bag_vec)
{
    std::vector<unsigned int> weight_vec;
    unsigned int weight_total = 0;
    GiftBagType type = GiftBagType_Invalid;
    { //查询礼包类型和权重
        char sql[1024];
        sprintf(sql, "select type, weight "
            " from hellgate.gift_bag_temp "
            " where id=%u order by weight desc "
            , id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type = (GiftBagType)atoi(Mysql_Thread_Conn->GetField("type"));
                unsigned int weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                if(weight > 0) {
                    weight_vec.push_back(weight);
                    weight_total += weight;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned select_weight = 0;  //如果是随机礼包 这个用来选择权重是哪个
    if(GiftBagType_Invalid == type) {
        LogMsg("%s, line %d, gift bag[%u] is not exist"
            , __FILE__, __LINE__, id);
        return false;
    }
    else if(GiftBagType_Random == type) {
        int ran_num = Utl::auto_random()%weight_total;
        for(int i=0; i<weight_vec.size(); ++i) {
            if((ran_num -= weight_vec[i]) < 0) { //选中
                select_weight = weight_vec[i];
                break;
            }
        }
    }

    __GiftBagInfo info;
    { //查询奖励模板内容
        char sql[1024];
        if(GiftBagType_All == type) {
            sprintf(sql, "select bonus_type, bonus_id, bonus_count, hero_profession "
                " from hellgate.gift_bag_temp "
                " where id=%u "
                , id);
        }
        else {
            sprintf(sql, "select bonus_type, bonus_id, bonus_count, hero_profession "
                " from hellgate.gift_bag_temp "
                " where id=%u and weight=%u "
                , id, select_weight);
        }
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int bonus_type = atoi(Mysql_Thread_Conn->GetField("bonus_type"));
                int bonus_id = atoi(Mysql_Thread_Conn->GetField("bonus_id"));
                unsigned int bonus_count = atoi(Mysql_Thread_Conn->GetField("bonus_count"));

                if(bonus_type <= AttachType_Props) { //道具奖励
                    ItemInfo item;
                    item.type = bonus_id;
                    item.count = bonus_count;

                    if(item.count > 0) {
                        info.item_vec.push_back(item);
                    }
                }
                else if(bonus_type == AttachType_PropsDebris) { //道具碎片
                    ItemSuipianInfo item_deb;
                    item_deb.item_id = bonus_id;
                    item_deb.suipian_count = bonus_count;
                    item_deb.suipian_id = Utl::auto_random()/5;

                    if(item_deb.suipian_count > 0) {
                        info.item_suipian_vec.push_back(item_deb);
                    }
                }
                else if(bonus_type == AttachType_ArmsDebris) { //装备碎片
                    ShenbingSuipianInfo sb_deb;
                    sb_deb.zb_group_id = bonus_id;
                    sb_deb.suipian_count = bonus_count;
                    //碎片id先随机 最后改成固定的
                    sb_deb.suipian_id = Utl::auto_random()/5;

                    if(sb_deb.suipian_count > 0) {
                        info.zb_suipian_vec.push_back(sb_deb);
                    }
                }
                else if(bonus_type == AttachType_Arms) { //装备
                    __DuanzaoGroupZBInfo zb_info;
                    unsigned int prof = atoi(Mysql_Thread_Conn->GetField("hero_profession"));
                    if(prof > Profession_Fashi)
                        continue;
                    else if(prof == 0) { //所有职业
                        if(bonus_count == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_count);
                            }
                        }
                    }
                    else if(prof <= Profession_Fashi){  //指定职业主角
                        if(bonus_count == 0) { //随机装备
                            ++(info.prof_zb_ran[prof-1]);
                        }
                        else { //指定装备
                            info.prof_zb_group_vec[prof-1].push_back(bonus_count);
                        }
                    }
                    else { //指定其他职业
                        if(bonus_count == 0) { //随机装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	++(info.prof_zb_ran[i]);
                            }
                        }
                        else { //指定装备
                            for(int i=0; i<Profession_Fashi; ++i) {
                            	info.prof_zb_group_vec[i].push_back(bonus_count);
                            }
                        }
                    }
                }
                else if(bonus_type == AttachType_GiftBag) { //礼包
                    GiftBag gift;
                    gift.id = bonus_id;
                    gift.count = bonus_count;

                    if(gift.count > 0) {
                        info.gift_bag_vec.push_back(gift);
                    }
                }
                else if(bonus_type == AttachType_Vitality) { //体力
                    info.vitality = bonus_count;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(info.vitality > 0) { //赠送体力
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set vit_current=vit_current+%u "
            " where hero_id=%u"
            , info.vitality, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    for(int i=0; i<info.item_vec.size(); ++i){ //道具入库
        ObtainItem(main_hero_id, info.item_vec[i].type, info.item_vec[i].count);
    }

    for(int i=0; i<info.item_suipian_vec.size(); ++i){ //道具碎片入库
        ObtainItemSuipian(main_hero_id, info.item_suipian_vec[i].item_id, 
            info.item_suipian_vec[i].suipian_id, info.item_suipian_vec[i].suipian_count);
    }

    for(int i=0; i<info.zb_suipian_vec.size(); ++i){ //装备碎片入库
        ObtainZhuangbeiSuipian(main_hero_id, info.zb_suipian_vec[i].zb_group_id, 
            info.zb_suipian_vec[i].suipian_id, info.zb_suipian_vec[i].suipian_count);
    }

    for(int i=0; i<info.gift_bag_vec.size(); ++i){ //礼包入库
        ObtainGiftBag(main_hero_id, info.gift_bag_vec[i].id, info.gift_bag_vec[i].count);
    }
    
    { //体力
        addVitality(main_hero_id, info.vitality);
    } 

    { //赠送装备
        present_zhuangbei_gift_bag(main_hero_id, info);
    }

    //压入输出库
    gift_bag_vec.push_back(info);
    return true;
}


bool ProcServerThread::present_vip(unsigned int hero_id, unsigned int vip_level)
{
    bool b_exist = true;
    VIP_Info v_info;
    
    {//查询历史充值
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.hero_vip_info where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                v_info.level = atoi(Mysql_Thread_Conn->GetField("vip_level"));
                if(v_info.level >= vip_level){
                    LogMsg("%s, line %d, hero_id[%u] vip level[%u] always > vip[%u] "
                        , __FILE__, __LINE__, hero_id, v_info.level, vip_level);
                    return false;
                }
                
                v_info.total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                v_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                v_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                v_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                v_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                v_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                v_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                v_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));
            }
            else {
                b_exist = false;
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //查询vip功能模板
    VIP_Info old_v_info;
    VIP_Info new_v_info;
    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.vip_template " 
            " where level=%u or level=%u "
            , v_info.level, vip_level);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                VIP_Info tmp_v_info;
                tmp_v_info.level = atoi(Mysql_Thread_Conn->GetField("level"));
                tmp_v_info.total_charge = atoi(Mysql_Thread_Conn->GetField("total_charge"));
                tmp_v_info.priv.buy_vitality_num = atoi(Mysql_Thread_Conn->GetField("buy_vitality_num"));
                tmp_v_info.priv.sweep_num = atoi(Mysql_Thread_Conn->GetField("sweep_num"));
                tmp_v_info.priv.buy_arena_num = atoi(Mysql_Thread_Conn->GetField("buy_arena_num"));
                tmp_v_info.priv.over_creep_num = atoi(Mysql_Thread_Conn->GetField("over_creep_num"));
                tmp_v_info.priv.cast_silver_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
                tmp_v_info.priv.honor_exchange = (bool)atoi(Mysql_Thread_Conn->GetField("honor_exchange"));
                tmp_v_info.priv.refresh_reward_num = atoi(Mysql_Thread_Conn->GetField("refresh_reward_num"));

                if(tmp_v_info.level == vip_level) {
                    new_v_info = tmp_v_info;
                } else {
                    old_v_info = tmp_v_info;
                }
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    {//修改hero_info
        char sql[1024];
        if(b_exist) {
            sprintf(sql, "update hellgate.hero_vip_info set vip_level=%u, total_charge=%u "
                ", buy_vitality_num=%u, sweep_num=%u, buy_arena_num=%u, over_creep_num=%u, cast_silver_num=%u "
                ", honor_exchange=%u, refresh_reward_num=%u, last_refresh_timestamp=%u "
                " where hero_id=%u"
                , vip_level 
                , new_v_info.total_charge
                , new_v_info.priv.buy_vitality_num - (old_v_info.priv.buy_vitality_num - v_info.priv.buy_vitality_num)
                , new_v_info.priv.sweep_num - (old_v_info.priv.sweep_num - v_info.priv.sweep_num)
                , new_v_info.priv.buy_arena_num - (old_v_info.priv.buy_arena_num - v_info.priv.buy_arena_num)
                , new_v_info.priv.over_creep_num
                , new_v_info.priv.cast_silver_num
                , new_v_info.priv.honor_exchange
                , new_v_info.priv.refresh_reward_num - (old_v_info.priv.refresh_reward_num - v_info.priv.refresh_reward_num)
                , (unsigned int)time(NULL)
                , hero_id);
        } 
        else {
            sprintf(sql, "insert into hellgate.hero_vip_info set hero_id=%u, vip_level=%u, total_charge=%u "
                ", buy_vitality_num=%u, sweep_num=%u, buy_arena_num=%u, over_creep_num=%u, cast_silver_num=%u "
                ", honor_exchange=%u, refresh_reward_num=%u, last_refresh_timestamp=%u "
                , hero_id
                , vip_level 
                , new_v_info.total_charge
                , new_v_info.priv.buy_vitality_num
                , new_v_info.priv.sweep_num
                , new_v_info.priv.buy_arena_num
                , new_v_info.priv.over_creep_num
                , new_v_info.priv.cast_silver_num
                , new_v_info.priv.honor_exchange
                , new_v_info.priv.refresh_reward_num
                , (unsigned int)time(NULL));
        }
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::query_both_two_order(
    unsigned int hero_a, unsigned int hero_b, unsigned int &order_a, unsigned int &order_b)
{
    char sql[1024];
    sprintf(sql, "select * from hellgate.top_hero_list "
        " where hero_id=%u or hero_id=%u "
        , hero_a, hero_b);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        while(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

            if(hero_id == hero_a) {
                order_a = atoi(Mysql_Thread_Conn->GetField("hero_order"));
            }
            else if(hero_id == hero_b) {
                order_b = atoi(Mysql_Thread_Conn->GetField("hero_order"));

            }
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
}


bool ProcServerThread::check_and_upgrade_shenbing(unsigned int hero_id
    , unsigned long long zb_id, unsigned long long cailiao_zb_id
    , std::vector<ItemInfo> &cailiao_vec)
{
    cailiao_vec.clear();
    
    if(zb_id == cailiao_zb_id)
    {
        LogMsg("%s, line %d, zhuangbei_id[%llu] is the same id of cailiao_zb_id"
                            , __FILE__, __LINE__, zb_id);
        return false;
    }
    
    //获取现有silver数量
    unsigned silver_total_count = getItemCountInTeam(hero_id, ItemsType_Silver);
    unsigned kanebook_total_count = getItemCountInTeam(hero_id, ItemsType_Shenbing_Jianding);


    //检查装备
    unsigned int zhuangbei_hero_id = 0;
    unsigned int zb_name_id = 0;
    unsigned int group_id = 0;
    unsigned int zb_colour = 0;
    __DuanzaoGroupZBInfo current_sb_info;
    {
        //
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_list.zhuangbei_name_id, zhuangbei_hero_id, group_id, "
                " zhuangbei_colour, jinglian_level "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                    group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    zb_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //检查是否是传奇
        if(zb_colour != ZhuangbeiColour_Chuanqi)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not chuanqi"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        int index=-1;
        //检查是否是神兵 
        for(int i=0; i<m_shenbing_vec.size(); ++i) {
            if(m_shenbing_vec[i].zb_group_id == group_id) {
                current_sb_info = m_shenbing_vec[i];
                index = i;
                break;
            }
        }

        if(index == -1) {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not shenbing"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //是否已经是最高等级
        if(current_sb_info.level >= 30)
        {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is already full level"
                            , __FILE__, __LINE__, zb_id);
            return false;
        }

        //检查此神兵是不是在英雄身上
        bool zb_equip_by_hero = false;
        unsigned int equip_hero_id = 0;
        {
            char sql[1024];
            sprintf(sql, "select group_id, zhuangbei_hero_id, "
                " qianghua_cailiao_goldstar_count"
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    equip_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    if(equip_hero_id != 0)
                    {
                        zb_equip_by_hero = true;
                    }
                }
                else
                {
                    LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //
        if(zb_equip_by_hero)
        {
            HeroInfo hero_info;
            GetHeroBasicInfo(equip_hero_id, hero_info);

            if(!hero_info.is_yuanshen) { //如果是元神就不用管等级了
                bool b_level_not_enough = false;

                if(current_sb_info.level == 5) {
                    if(hero_info.level < 15)
                        b_level_not_enough = true;
                }
                else if(current_sb_info.level == 15) {
                    if(hero_info.level < 25)
                        b_level_not_enough = true;
                }
                else if(current_sb_info.level == 25) {
                    if(hero_info.level < 30)
                        b_level_not_enough = true;
                }

                if(b_level_not_enough) { //升级后英雄等级不够 不能升级
                    LogMsg("%s, line %d, zhuangbei_id[%llu] has equiped to hero"
                        " and  hero level[%u] not enough when upgrade. "
                        , __FILE__, __LINE__, zb_id, hero_info.level);

                    return false;
                }
            }
        }
        
    }

    //检查升级材料装状态
    if(cailiao_zb_id > 0){
        bool cailiao_zb_equip_by_hero = false;
        {
            char sql[1024];
            sprintf(sql, "select group_id, zhuangbei_hero_id, qianghua_cailiao_total_count, "
                " qianghua_cailiao_goldstar_count, diamond_type_1, diamond_type_2, diamond_type_3"
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , cailiao_zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    unsigned int equip_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    if(equip_hero_id != 0)
                    {
                        cailiao_zb_equip_by_hero = true;
                    }
                    else
                    {
                        cailiao_zb_equip_by_hero = false;
                    }

                    int qianghua_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_total_count"));
                    if(qianghua_count > 0){
                        ItemInfo item;
                        item.type = ItemsType_QianghuaNormal;
                        item.count = qianghua_count;
                        cailiao_vec.push_back(item);
                    }
                    int qianghua_goldstar_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_goldstar_count"));
                    if(qianghua_goldstar_count > 0){
                        ItemInfo item;
                        item.type = ItemsType_GoldStar_Qianghua;
                        item.count = qianghua_goldstar_count;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                    if(diamond_type_1 > 0){
                        ItemInfo item;
                        item.type = diamond_type_1;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                    if(diamond_type_2 > 0){
                        ItemInfo item;
                        item.type = diamond_type_2;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));
                    if(diamond_type_3 > 0){
                        ItemInfo item;
                        item.type = diamond_type_3;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                }
                else
                {
                    LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //
        if(cailiao_zb_equip_by_hero)
        {
            LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] has equiped to hero"
                            , __FILE__, __LINE__, cailiao_zb_id);

            return false;
        }

    }

    unsigned int silver_need_count = CS::ShenbingUpgradeNeedSilver(current_sb_info.level);
    unsigned int kanebook_need_count = CS::ShenbingUpgradeNeedItemCount(current_sb_info.level);
    if(silver_total_count < silver_need_count) {
        LogMsg("%s, line %d,  silver_need_count=[%u] silver_total_count[%u]"
                            , __FILE__, __LINE__, silver_need_count, silver_total_count);
            
        return false;
    }
    if(kanebook_total_count < kanebook_need_count ) {
        LogMsg("%s, line %d,  kanebook_need_count=[%u] kanebook_total_count[%u]"
                            , __FILE__, __LINE__, kanebook_need_count, kanebook_total_count);
            
        return false;
    }

    unsigned int next_zb_name_id = 0;
    {
        char sql[1024];
        sprintf(sql, "select zhuangbei_name_id "
            " from hellgate.zhuangbei_name_list_copy "
            " where group_id=%u "
            , current_sb_info.next_group_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                next_zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
            }
            else
            {
                LogMsg("%s, line %d, group_id[%llu] not exist or not belong to in zb temp"
                        , __FILE__, __LINE__, current_sb_info.next_group_id);

                Mysql_Thread_Conn->FreeResult();
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    __ZhuangbeiDetail detail;
    if(!createZhuangbei(next_zb_name_id, current_sb_info.next_group_id
        , hero_id, detail))
    {
        LogMsg("%s, line %d, createzhuangbei failed. next_zb_name_id[%u]"
                                , __FILE__, __LINE__, next_zb_name_id);
        return false;
    }

    //入库
    {
        char sql[2048];
        std::string attr_str;
        char str[64];
        for(int i=0; i<detail.attr_vec.size(); ++i)
        {
            sprintf(str, "attr_type_%d=%u, attr_value_%d=%u, cuiqu_suc_ratio_%d=%u, "
                , i+1, detail.attr_vec[i].attr_type, i+1, detail.attr_vec[i].attr_value
                , i+1, detail.attr_vec[i].cuiqu_suc_ratio);

            attr_str += str;
        }
        
        sprintf(sql, "update hellgate.zhuangbei_list set "
            " zhuangbei_name_id=%u, hole=%u, "
            " gongji_min=%u, gongji_max=%u, hujia=%u, "
            " %s "  //字符串后面有逗号
            " attr_count=%u "
            " where zhuangbei_id=%llu and owner_hero_id=%u"
            , next_zb_name_id
            , detail.hole
            , detail.gongji_min, detail.gongji_max, detail.hujia
            , attr_str.c_str()
            , (unsigned int)detail.attr_vec.size()
            , zb_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //回收强化材料
    for(int i=0; i<cailiao_vec.size(); i++)
    {
        ObtainItem(hero_id, cailiao_vec[i].type, cailiao_vec[i].count);
    }

    //再扣钱
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , silver_need_count, hero_id, ItemsType_Silver);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //再kane之书
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-%u "
            " where hero_id=%u and item_type=%u"
            , kanebook_need_count, hero_id, ItemsType_Shenbing_Jianding);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //删除材料装
    if(cailiao_zb_id > 0){
        char sql[1024];
        sprintf(sql, "delete from hellgate.zhuangbei_list where zhuangbei_id=%llu"
            , cailiao_zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(zhuangbei_hero_id > 0) { //穿在英雄身上 重新计算战斗力
        calculate_fight_capacity(zhuangbei_hero_id);
    }

    return true;
}


unsigned int ProcServerThread::selected_group_id(unsigned int hero_level, const std::vector<__zb_type_group_id> &zb_vec)
{
    if(zb_vec.empty())
        return 0;

    //首先随机一个装备类型
    unsigned int index = Utl::auto_random()%zb_vec.size();
    unsigned int type = zb_vec[index].type;

    //然后根据此类型生成一个装备库
    std::vector<__zb_type_group_id> zb_tmp_vec;
    for(int i=0; i<zb_vec.size(); i++) {
        if(zb_vec[i].type == type)
            zb_tmp_vec.push_back(zb_vec[i]);
    }

    //从英雄等级向两端辐射查找装备,直到找到为止
    unsigned int level_low = hero_level, level_high = hero_level;
    for(int count=0; count<HERO_MAX_LEVEL; count++) {   //最多循环30次
        for(int i=0; i<zb_tmp_vec.size(); i++) {
            //找到装备，返回group_id
            if(zb_tmp_vec[i].zb_level==level_low || zb_tmp_vec[i].zb_level==level_high)
                return zb_tmp_vec[i].group_id;
        }

        if(level_low > 1)
            level_low--;
        if(level_high < 30)
            level_high++;
    }   
    return 0;
}


bool ProcServerThread::check_and_draw_shenbing(unsigned int main_hero_id, unsigned int profession_id
    , bool is_times_10, std::vector<__ZhuangbeiDetail> &zhuangbei_vec)
{
    unsigned int hero_id =0;
    unsigned int query_profession_id =0;
    unsigned int hero_level=0;

    unsigned int total_count = get_unequipped_counts(main_hero_id);
    total_count += is_times_10?10:1;
    if(total_count > MAX_COUNTS_IN_KNAPSACK) {
        LogMsg("%s, line %d, hero[%u] unequipped zb is over limit."
            , __FILE__, __LINE__, main_hero_id);
        return false;
    }
    
    if(profession_id < Profession_Yemanren || profession_id > Profession_WuShi){
        LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], profession is waring. "
            , __FILE__, __LINE__, main_hero_id, profession_id);
        return false;
    }

    //查询英雄信息
    if(profession_id <= Profession_Fashi) {//查询主英雄职业
        hero_id = main_hero_id;
        char sql[1024];
        sprintf(sql, "select profession_id, level from hellgate.hero_infor "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                query_profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                if(query_profession_id != profession_id){
                    LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], profession is waring. "
                        , __FILE__, __LINE__, main_hero_id, profession_id);
                    return false;
                }

                hero_level = atoi(Mysql_Thread_Conn->GetField("level"));
            } 
            else {
                LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
                    , __FILE__, __LINE__, main_hero_id, profession_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else {//查询该职业的英雄id
        char sql[1024];
        sprintf(sql, "select hero_id, level from hellgate.hero_infor "
            " where parent_hero_id=%u and profession_id=%u"
            , main_hero_id, profession_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                hero_level = atoi(Mysql_Thread_Conn->GetField("level"));
            } 
            else {
                LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
                    , __FILE__, __LINE__, main_hero_id, profession_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //查询余额
    int gold_balance = 0;
    int gold_need = 0;
        
    {
        gold_need = is_times_10 ? (DROW_SHENBING_NEED_GOLD *10) : DROW_SHENBING_NEED_GOLD;
        gold_balance = getItemCountInTeam(main_hero_id, ItemsType_Gold);

        if(gold_balance < gold_need) {
            LogMsg("%s, line %d, main_hero_id[%u], gold[%u] is not enough. "
                , __FILE__, __LINE__, main_hero_id, gold_balance);
            return false;
        }
    }

    //查询本职业和该等级的蓝装和稀有以及5级传奇
    std::vector<__zb_type_group_id> fumo_vec;
    std::vector<__zb_type_group_id> xiyou_vec;
    std::vector<unsigned int> chuanqi_vec;
    {
        char sql[1024];
        std::vector<__zb_type_group_id> fumo_tmp_vec;
        std::vector<__zb_type_group_id> xiyou_tmp_vec;
        sprintf(sql, "select distinct(group_id), zhuangbei_colour, zhuangbei_type, zhuangbei_level "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_level>=%u "
            " and zhuangbei_colour=%u or zhuangbei_colour=%u"
            , hero_level<5 ? 0: (hero_level-5)
            , ZhuangbeiColour_Xiyou, ZhuangbeiColour_Fumo);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __zb_type_group_id info;
                unsigned int colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                info.group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                info.type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                info.zb_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));

                if(colour == ZhuangbeiColour_Xiyou) {
                    xiyou_tmp_vec.push_back(info);
                }
                else {
                    fumo_tmp_vec.push_back(info);
                }
               
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        sprintf(sql, "select group_id "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_level=5 and bind_profession_id=%u "
            " and zhuangbei_colour=%u "
            , profession_id, ZhuangbeiColour_Chuanqi);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int group = atoi(Mysql_Thread_Conn->GetField("group_id"));
                chuanqi_vec.push_back(group);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        

        //过滤蓝装和稀有
        //fumo_vec = filterZBGroupCannotUse((Profession)profession_id, fumo_vec);
        //xiyou_vec = filterZBGroupCannotUse((Profession)profession_id, xiyou_vec);
        for(int i=0; i<xiyou_tmp_vec.size(); i++) {
            if(CS::canEquipToHero(xiyou_tmp_vec[i].type, profession_id)) {
                xiyou_vec.push_back(xiyou_tmp_vec[i]);
            }
        }
        for(int i=0; i<fumo_tmp_vec.size(); i++) {
            if(CS::canEquipToHero(fumo_tmp_vec[i].type, profession_id)) {
                fumo_vec.push_back(fumo_tmp_vec[i]);
            }
        }
        
        if(fumo_vec.empty() || xiyou_vec.empty() || chuanqi_vec.empty()) {
            LogMsg("%s, line %d, profession_id[%u], not zhuangbei in db "
                , __FILE__, __LINE__, profession_id);
            return false;
        }
    }
    

    int hit_10_times_times = -1;
    std::vector<unsigned int> chuanqi_without_vec;
    if(is_times_10) {//查询点击10次的次数
        char sql[1024];
        sprintf(sql, "select times from hellgate.profession_hit_10_times "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                hit_10_times_times = atoi(Mysql_Thread_Conn->GetField("times"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        if(hit_10_times_times < 0) { //没有此英雄id的记录 插入新纪录
            sprintf(sql, "insert into hellgate.profession_hit_10_times "
                " set hero_id=%u, times=0 "
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        } 
        else if(hit_10_times_times >= 10) { //抽取10次的次数超过10
            chuanqi_without_vec = chuanqi_vec;
            
            std::vector<unsigned int> chuanqi_exist_vec;
            //查询英雄已有的传奇装备
            sprintf(sql, "select distinct(zhuangbei_name_list_copy.group_id) from "
                " hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy"
                " where owner_hero_id=%u and hellgate.zhuangbei_name_list_copy.bind_profession_id=%u "
                " and hellgate.zhuangbei_list.zhuangbei_name_id=hellgate.zhuangbei_name_list_copy.zhuangbei_name_id "
                " and hellgate.zhuangbei_name_list_copy.zhuangbei_colour=%u "
                " group by zhuangbei_name_list_copy.group_id "
                , hero_id, profession_id, ZhuangbeiColour_Chuanqi);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                std::vector<SuitPart> parts_of_suit;
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    unsigned int group = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    chuanqi_exist_vec.push_back(group);
                }
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }

            if(!chuanqi_exist_vec.empty()) {
                for(int i=0; i<chuanqi_exist_vec.size(); i++) {
                    for(int j=0; j< chuanqi_without_vec.size(); j++) {
                        //找到了 删除此配件模板
                        if(check_same_parts(chuanqi_exist_vec[i], chuanqi_without_vec[j])) {
                            chuanqi_without_vec.erase(chuanqi_without_vec.begin() +j);
                            break;
                        }
                    }
                }
            }
        }
    }

    //抽取装备
    if(is_times_10) { //抽取10次
        for(int i=0; i<9; i++) { //前9次抽取
            int ran_num = Utl::auto_random()%100;
            unsigned int choose_group_id = 0;
            
            ran_num -= 69;
            if(ran_num < 0) { //蓝装
                choose_group_id = selected_group_id(hero_level, fumo_vec);
            }
            else {
                ran_num -= 30;
                if(ran_num < 0) { //稀有
                    choose_group_id = selected_group_id(hero_level, xiyou_vec);
                } 
                else { //传奇
                    unsigned int choose_index = Utl::auto_random()%chuanqi_vec.size();
                    choose_group_id = chuanqi_vec[choose_index];
                    
                    //锻造出传奇插入到跑马灯队列中
                    insert_marquee_message(MarqueeType_ForgeLegend, main_hero_id, choose_group_id);
                }
            }
            
            unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(choose_group_id);
            //
            if(zb_name_id == 0) {
                LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
                assert(false);
            }

            __ZhuangbeiDetail detail;
            if(!createZhuangbei(zb_name_id, choose_group_id, main_hero_id, detail, false))
            {
                LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                        , __FILE__, __LINE__, zb_name_id);
                return false;
            }
            //入库
            detail.zhuangbei_id = ObtainZhuangbei(main_hero_id, zb_name_id, detail);

            zhuangbei_vec.push_back(detail);
        }

        //第10次
        std::vector<unsigned int> choose_vec;
        if((hit_10_times_times >= 10) && (!chuanqi_without_vec.empty())) 
        {//点击10次的次数大于10 且该职业的神兵装备未满
            choose_vec = chuanqi_without_vec;
        }
        else {
            choose_vec = chuanqi_vec;
        }
        
        int ran_num = Utl::auto_random()%choose_vec.size();
        
        //根据各装备概率选择应该掉哪件
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(choose_vec[ran_num]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, choose_vec[ran_num], main_hero_id, detail, false))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            return false;
        }
        
        //锻造出传奇插入到跑马灯队列中
        insert_marquee_message(MarqueeType_ForgeLegend, main_hero_id, choose_vec[ran_num]);
        
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(main_hero_id, zb_name_id, detail);

        zhuangbei_vec.push_back(detail);
        
    } 
    else {  //抽取1次
        int ran_num = Utl::auto_random()%100;
        unsigned int choose_group_id = 0;
        
        ran_num -= 63;
        if(ran_num < 0) { //蓝装
            choose_group_id = selected_group_id(hero_level, fumo_vec);
        }
        else {
            ran_num -= 30;
            if(ran_num < 0) { //稀有
                choose_group_id = selected_group_id(hero_level, xiyou_vec);
            } 
            else { //传奇
                unsigned int choose_index = Utl::auto_random()%chuanqi_vec.size();
                choose_group_id = chuanqi_vec[choose_index];
                
                //锻造出传奇插入到跑马灯队列中
                insert_marquee_message(MarqueeType_ForgeLegend, main_hero_id, choose_group_id);
            }
        }
        
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(choose_group_id);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, choose_group_id, main_hero_id, detail, false))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            return false;
        }
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(main_hero_id, zb_name_id, detail);

        zhuangbei_vec.push_back(detail);
    }

    //锻造完再扣钱
    gold_balance -= gold_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , gold_balance, main_hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(is_times_10) { //增加点击10次的次数
        char sql[1024];
        sprintf(sql, "update hellgate.profession_hit_10_times set times=times+1 "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    return true;
}


bool ProcServerThread::query_zhuangbei_album(unsigned int main_hero_id, unsigned int profession_id
    , std::vector<__DuanzaoGroupZBInfo> &legend_vec
    , std::vector<__DuanzaoGroupZBInfo> &xiyou_vec)
{
    legend_vec.clear();
    xiyou_vec.clear();
    if(profession_id < Profession_Yemanren || profession_id > Profession_WuShi){
        LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], profession is waring. "
            , __FILE__, __LINE__, main_hero_id, profession_id);
        return false;
    }

    /*2014.03.12 放开对其他主职业的的限制
    unsigned int query_profession_id =0;
    unsigned int hero_id =0;
    if(profession_id <= 3) {//查询主英雄职业
        hero_id = main_hero_id;
        char sql[1024];
        sprintf(sql, "select profession_id from hellgate.hero_infor "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                query_profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                
                if(query_profession_id != profession_id){
                    LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], profession is waring. "
                        , __FILE__, __LINE__, main_hero_id, profession_id);
                    return false;
                }
            } 
            else {
                LogMsg("%s, line %d, main_hero_id[%u], profession_id[%u], is not exist. "
                    , __FILE__, __LINE__, main_hero_id, profession_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    */
    
    
    //查询本职业的稀有和5级传奇
    std::vector<unsigned int> legend_group_vec;
    std::vector<unsigned int> xiyou_group_vec;
    {
        char sql[1024];
        sprintf(sql, "select group_id from hellgate.zhuangbei_name_list_copy "
            " where bind_profession_id=%u and zhuangbei_colour=%u and zhuangbei_level=5 "
            , profession_id, ZhuangbeiColour_Chuanqi);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int group = atoi(Mysql_Thread_Conn->GetField("group_id"));
                legend_group_vec.push_back(group);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        std::vector<__zb_type_group_id> xiyou_tmp_vec;
        sprintf(sql, "select distinct(group_id), zhuangbei_type "
            " from hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_colour=%u"
            , ZhuangbeiColour_Xiyou);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __zb_type_group_id info;
                info.group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                info.type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                xiyou_tmp_vec.push_back(info);
               
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        //过滤稀有的
        //xiyou_group_vec = filterZBGroupCannotUse((Profession)profession_id, xiyou_group_vec);
        for(int i=0; i<xiyou_tmp_vec.size(); i++) {
            if(CS::canEquipToHero(xiyou_tmp_vec[i].type, profession_id)) {
                xiyou_group_vec.push_back(xiyou_tmp_vec[i].group_id);
            }
        }
        
        if(legend_group_vec.empty() || xiyou_group_vec.empty()) {
            LogMsg("%s, line %d, profession_id[%u], not zhuangbei in db "
                , __FILE__, __LINE__, profession_id);
            return false;
        }
    }

    //获取传奇装备属性
    for(int i=0; i<legend_group_vec.size(); i++) {
        for(int j=0; j<m_shenbing_vec.size(); j++) {
            if(m_shenbing_vec[j].zb_group_id == legend_group_vec[i]) {
                legend_vec.push_back(m_shenbing_vec[j]);
                break;
            }
        }
    }
   
    //获取稀有装备属性
    for(int i=0; i<xiyou_group_vec.size(); i++) {
        __DuanzaoGroupZBInfo info;
        if(query_duanzao_group_zb_info(xiyou_group_vec[i], info)) {
            xiyou_vec.push_back(info);
        }
    }

    return true;
}


void ProcServerThread::get_team_formation(unsigned int main_hero_id, unsigned int *team_pos_attr, unsigned int *capacity_attr)
{
    char sql[1024];
    sprintf(sql, "select hero_id, position, fight_capacity from hellgate.hero_infor "
        " where (parent_hero_id=%u or hero_id=%u) and position>0"
        , main_hero_id, main_hero_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        while(Mysql_Thread_Conn->FetchRow() != NULL)
        {
            int pos = atoi(Mysql_Thread_Conn->GetField("position"));
            unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
            unsigned int fight_capacity = atoi(Mysql_Thread_Conn->GetField("fight_capacity"));

            if(pos <= 0 || pos > 4)
            {
                LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                    , __FILE__, __LINE__, main_hero_id, pos);
            }
            else
            {
                team_pos_attr[pos-1] = hero_id;
                capacity_attr[pos-1] = fight_capacity;
            }
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }

}


bool ProcServerThread::check_same_parts(unsigned int group_id_a, unsigned int group_id_b)
{
    OneSuitInfo info;
    std::vector<SuitPart> parts_of_suit;
    if(group_id_a == group_id_b)
        return true;

    //不是套装配件
    if(!(SuitPool::getPool()->getSuitInforByZBGroupId(group_id_a, info))) {
        LogMsg("%s, line %d, group_id[%u] not in suit.", 
            __FILE__, __LINE__, group_id_a);
        assert(false);
    }
    
    parts_of_suit = info.parts_of_suit;
    for(int i=0; i<parts_of_suit.size(); i++) {
        bool b_found = false;
        for(int j=0; j<parts_of_suit[i].group_ids.size(); j++) {
            if(parts_of_suit[i].group_ids[j] == group_id_a) {
                b_found = true;
            }
        }
        
        if(!b_found) //没有找到，直接跳出这个配件
           continue;
        
        for(int j=0; j<parts_of_suit[i].group_ids.size(); j++) {
            if(parts_of_suit[i].group_ids[j] == group_id_b) {
                return true;
            }
        }
    }
    
    return false;
}


bool ProcServerThread::check_and_unlock_assistant(unsigned int main_hero_id, unsigned int assistant,
    unsigned int &honor_balance)
{
    honor_balance = 0;
    {//查询主英雄等级
        char sql[1024];
        sprintf(sql, "select level from hellgate.hero_infor "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                int level = atoi(Mysql_Thread_Conn->GetField("level"));
                if(level < CS::getUnlockAbleHeroLevel()){
                    LogMsg("%s, line %d, main_hero_id=[%u] level not enough"
                        , __FILE__, __LINE__, main_hero_id);
                    return false;
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
                exit(1);
        }
    }

    std::vector<unsigned int> locked_hero_vec, locked_prof_vec;
    {//查询主英雄未解锁英雄
        char sql[1024];
        sprintf(sql, "select hero_id, profession_id from hellgate.hero_infor "
            " where parent_hero_id=%u and is_unlocked=0 and is_unlock_able=1"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                unsigned int profession_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                locked_hero_vec.push_back(hero_id);
                locked_prof_vec.push_back(profession_id);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
                exit(1);
        }
    }

    if(locked_hero_vec.empty()) {
        LogMsg("%s, line %d, have no hero locked.", __FILE__, __LINE__);
        return false;
    }

    //查找要解锁的英雄是否在未解锁英雄池里
    int index = -1;
    for(int i=0; i<locked_hero_vec.size(); ++i) {
        if(assistant == locked_hero_vec[i]) {
            index = i;
            break;
        }
    }
    if(index < 0) {
        LogMsg("%s, line %d, assistant[%u] is not locked.", 
            __FILE__, __LINE__, assistant);
        return false;
    }

    unsigned int honor_need = CS::AssistantUnLockNeedHonor(locked_hero_vec.size());
    {//查询现有荣誉
        char sql[1024];
        sprintf(sql, "select jifen "
            " from hellgate.arena_hero_info where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                honor_balance = atoi(Mysql_Thread_Conn->GetField("jifen"));
            }
            else {
                LogMsg("%s, line %d, main_hero_id[%u] not exist"
                        , __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(honor_balance < honor_need) {
        LogMsg("%s, line %d, honor not enough.", __FILE__, __LINE__);
        return false;
    }

    {//先解锁英雄
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set is_unlocked=1, level=5 "
            " where parent_hero_id=%u and hero_id=%u "
            , main_hero_id, assistant);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    { //给解锁的助手初始化装备
        init_assistant_arms(main_hero_id, (Profession)locked_prof_vec[index], assistant);
    }
    
    honor_balance -= honor_need;
    {//扣除积分
        char sql[1024];
        sprintf(sql, "update hellgate.arena_hero_info set jifen=%u "
            " where hero_id=%u "
            , honor_balance, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    return true;
}


bool ProcServerThread::query_duanzao_group_zb_info(unsigned int group_id, __DuanzaoGroupZBInfo &info)
{
    char sql[1024];
    sprintf(sql, "select distinct(group_id), bind_profession_id, zhuangbei_type, "
        " zhuangbei_colour, zhuangbei_name, zhuangbei_pic, zhuangbei_level, "
        " gongji_min_min, gongji_min_max, gongji_max_min, gongji_max_max, "
        " wufang_min, wufang_max, hole1_percent, hole2_percent, hole3_percent, "
        " attr_1, attr_2, attr_3, attr_4, attr_5, attr_6, attr_7, attr_8, attr_9, attr_10, "
        " zhuangbei_desc "
        " from hellgate.zhuangbei_name_list_copy "
        " where zhuangbei_name_list_copy.group_id=%u "
        , group_id);
    try
    {
        Mysql_Thread_Conn->Query(sql);
        if(Mysql_Thread_Conn->FetchRow() != NULL) {
            info.ratio = 0;

            info.zb_group_id = group_id;
            info.next_group_id = 0;
            info.need_expend_group_id = 0;
            
            info.profession_id = atoi(Mysql_Thread_Conn->GetField("bind_profession_id"));
            info.zhuangbei_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
            info.zhuangbei_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
            
            strncpy(info.zhuangbei_name, Mysql_Thread_Conn->GetField("zhuangbei_name"), ZhuangbeiNameMaxLen);
            info.zhuangbei_name[ZhuangbeiNameMaxLen] = 0;

            strncpy(info.zhuangbei_pic, Mysql_Thread_Conn->GetField("zhuangbei_pic"), ZhuangbeiPicMaxLen);
            info.zhuangbei_pic[ZhuangbeiPicMaxLen] = 0;
            
            info.level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));

            info.gongji_min_min = atoi(Mysql_Thread_Conn->GetField("gongji_min_min"));
            info.gongji_min_max = atoi(Mysql_Thread_Conn->GetField("gongji_min_max"));
            info.gongji_max_min = atoi(Mysql_Thread_Conn->GetField("gongji_max_min"));
            info.gongji_max_max = atoi(Mysql_Thread_Conn->GetField("gongji_max_max"));
            info.wufang_min = atoi(Mysql_Thread_Conn->GetField("wufang_min"));
            info.wufang_max = atoi(Mysql_Thread_Conn->GetField("wufang_max"));
            
            get_zb_hole_percent(info.level, info.zhuangbei_colour, info.zhuangbei_type,
                info.hole1_percent, info.hole2_percent, info.hole3_percent);
           
            if(strlen(Mysql_Thread_Conn->GetField("attr_1")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_1")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_2")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_2")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_3")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_3")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_4")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_4")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_5")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_5")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_6")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_6")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_7")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_7")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_8")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_8")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_9")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_9")));
            }
            if(strlen(Mysql_Thread_Conn->GetField("attr_10")) > 0)
            {
                info.attr_vec.insert(info.attr_vec.end(), std::string(Mysql_Thread_Conn->GetField("attr_10")));
            }

            //
            info.desc = (Mysql_Thread_Conn->GetField("zhuangbei_desc"));

            //
        }
        else
        {
            LogMsg("%s, line %d, zhuangbei_group_id not exist. [%u]"
                    , __FILE__, __LINE__, group_id);
            return false;
        }
        
        Mysql_Thread_Conn->FreeResult();
    }
    catch(CMysqlException& e)
    {
        LogMsg("%s, line %d, mysql exception. [%s]"
                    , __FILE__, __LINE__, e.GetErrMsg());
        //
        exit(1);
    }
    
    return true;
}


int ProcServerThread::get_zb_hole(unsigned int zb_level, unsigned int zb_colour, unsigned int zb_type)
{
    if(zb_level >= 15) { //15级以上装备才有孔
        if(zb_colour == ZhuangbeiColour_Chuanqi) {//传奇和神兵
            if(zb_type <=ZhuangbeiType_Gong || zb_type==ZhuangbeiType_ShuangshouFazhang) {
                return 1;
            }
            else if(zb_type == ZhuangbeiType_KuijiaQin || zb_type == ZhuangbeiType_KuijiaZhong) {
                return 3;
            }
        }
        else if(zb_colour == ZhuangbeiColour_Xiyou) {//稀有
            int ratio = Utl::auto_random()%100;
            const int const_ratio = 15;
            ratio -= const_ratio;
            if(zb_type <=ZhuangbeiType_Gong || zb_type==ZhuangbeiType_ShuangshouFazhang) {
                if(ratio < 0) {
                    return 1;
                }
            }
            else if(zb_type == ZhuangbeiType_KuijiaQin || zb_type == ZhuangbeiType_KuijiaZhong) {
                if(ratio < 0) {
                    return 3;
                }
                else {
                    ratio -= const_ratio;
                    if(ratio < 0) {
                        return 2;
                    }
                    else {
                        ratio -= const_ratio;
                        if(ratio < 0) {
                            return 1;
                        }
                    }
                }
            }
        }
    }

    return 0;
}

void ProcServerThread::get_zb_hole_percent(unsigned int zb_level, unsigned int zb_colour, unsigned int zb_type,
    unsigned int &per1, unsigned int &per2, unsigned int &per3)
{
     per1 = 0;
     per2 = 0;
     per3 = 0;
     if(zb_level >= 15) { //15级以上装备才有孔
        if(zb_colour == ZhuangbeiColour_Chuanqi) {//传奇和神兵
            const int const_ratio = 100;
            if(zb_type <=ZhuangbeiType_Gong || zb_type==ZhuangbeiType_ShuangshouFazhang) {
                per1 = const_ratio;
            }
            else if(zb_type == ZhuangbeiType_KuijiaQin || zb_type == ZhuangbeiType_KuijiaZhong) {
                per1 = const_ratio;
                per2 = const_ratio;
                per3 = const_ratio;
            }
        }
        else if(zb_colour == ZhuangbeiColour_Xiyou) {//稀有
            const int const_ratio = 15;
            if(zb_type <=ZhuangbeiType_Gong || zb_type==ZhuangbeiType_ShuangshouFazhang) {
                per1 = const_ratio;
            }
            else if(zb_type == ZhuangbeiType_KuijiaQin || zb_type == ZhuangbeiType_KuijiaZhong) {
                per1 = const_ratio;
                per2 = const_ratio;
                per3 = const_ratio;
            }
        }
    }
}


bool ProcServerThread::query_gift_activity(unsigned int hero_id, std::vector<ActivityInfo> &info_vec)
{
    info_vec.clear();
    std::vector<unsigned int > time_vec;
    {//查询英雄领取活动状态
        char sql[1024];
        sprintf(sql, "select activity_id, is_get, last_get_timestamp from hellgate.hero_gift_activity "
            " where hero_id=%u order by activity_id"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                ActivityInfo info;
                info.id = atoi(Mysql_Thread_Conn->GetField("activity_id"));
                info.is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                unsigned int last_get_time = atoi(Mysql_Thread_Conn->GetField("last_get_timestamp"));
                
                time_vec.push_back(last_get_time);
                info_vec.push_back(info);
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //找到数据库没有记录的字段
    std::vector<ActivityType> not_exist_id_vec;
    not_exist_id_vec.push_back(ActivityType_12_14);
    not_exist_id_vec.push_back(ActivityType_18_20);

    for(int i=0; i<info_vec.size(); i++) {
        for(int j=0; j<not_exist_id_vec.size(); j++) {
            if(not_exist_id_vec[j] == info_vec[i].id) {
                //删除已经存在的记录
                not_exist_id_vec.erase(not_exist_id_vec.begin() +j);
                break;
            }
        }
    }
    
     for(int i=0; i<not_exist_id_vec.size(); i++) {//记录不存在 插入新纪录
        char sql[1024];
        sprintf(sql, "insert into hellgate.hero_gift_activity set "
            " hero_id=%u, activity_id=%u, is_get=0, last_get_timestamp=0 "
            , hero_id, not_exist_id_vec[i]);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        ActivityInfo info;
        info.id = not_exist_id_vec[i];
        info.is_get = false;
        
        time_vec.push_back(0);
        info_vec.push_back(info);
        
    }


    //新的一天刷新领取状态
    for(int i=0; i<info_vec.size(); i++) {
        if(isNeedSystemDailyRefresh(time_vec[i], SystemDailyTask_Hour) && info_vec[i].is_get){
            info_vec[i].is_get = false;
            char sql[1024];
            sprintf(sql, "update hellgate.hero_gift_activity set is_get=0 "
                " where hero_id=%u and activity_id=%u "
                , hero_id, info_vec[i].id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    
    time_t t = time(NULL);
    tm *p_tm = localtime(&t);
    p_tm->tm_min = 0;
    p_tm->tm_sec = 0;
    
    for(int i=0; i<info_vec.size(); i++) {//填充活动是否开启状态
        if(ActivityType_12_14 == info_vec[i].id){
            p_tm->tm_hour = VITALITY_ACTIVITY_OPEN_HOUR_1;
            info_vec[i].open_time = mktime(p_tm);
            p_tm->tm_hour = VITALITY_ACTIVITY_CLOSE_HOUR_1;
            info_vec[i].close_time = mktime(p_tm);
        }
        else if(ActivityType_18_20 == info_vec[i].id) {
            p_tm->tm_hour = VITALITY_ACTIVITY_OPEN_HOUR_2;
            info_vec[i].open_time = mktime(p_tm);
            p_tm->tm_hour = VITALITY_ACTIVITY_CLOSE_HOUR_2;
            info_vec[i].close_time = mktime(p_tm);
        }
    }

    return true;
}


bool ProcServerThread::check_and_get_activity(unsigned int hero_id, unsigned int id)
{
    {//查询活动是否开启
        time_t t = time(NULL);
        tm *p_tm = localtime(&t);
        if(id == ActivityType_12_14){
            if(p_tm->tm_hour <VITALITY_ACTIVITY_OPEN_HOUR_1 && 
                p_tm->tm_hour >VITALITY_ACTIVITY_CLOSE_HOUR_1){
                LogMsg("%s, line %d, activity[%d] not open ",
                    __FILE__, __LINE__, id);
                return false;
            }
        }
        else if(id == ActivityType_18_20){
            if(p_tm->tm_hour <VITALITY_ACTIVITY_OPEN_HOUR_2 && 
                p_tm->tm_hour >VITALITY_ACTIVITY_CLOSE_HOUR_2){
                LogMsg("%s, line %d, activity[%d] not open ",
                    __FILE__, __LINE__, id);
                return false;
            }
        }
        else {
            LogMsg("%s, line %d, activity[%d] not exist ",
                __FILE__, __LINE__, id);
            return false;
        }
    }
    
    bool is_get = false;
    {//查询英雄领取活动状态
        char sql[1024];
        sprintf(sql, "select is_get from hellgate.hero_gift_activity where "
            " hero_id=%u and activity_id=%u "
            , hero_id, id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                if(is_get) {
                    LogMsg("%s, line %d, hero_id[%u] had to get the activity[%d]", 
                        __FILE__, __LINE__, hero_id, id);
                    return false;
                }
            }
            else {
                LogMsg("%s, line %d, hero_id[%u] activity[%u] record not exist", 
                    __FILE__, __LINE__, hero_id, id);
                return false;
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    {//先增加体力
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set vit_current=vit_current+%u "
            " where hero_id=%u"
            , Vitality_Total/2, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    {//更新领取状态
        char sql[1024];
        sprintf(sql, "update hellgate.hero_gift_activity set "
            " is_get=1, last_get_timestamp=%u "
            " where hero_id=%u and activity_id=%u"
            , (unsigned int)time(NULL)
            , hero_id, id);
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

    }

    return true;
}


void ProcServerThread::update_killed_monster_counts(unsigned int hero_id, unsigned int common_count, unsigned int elite_count)
{
    bool is_not_exist = false;
    { //查询击杀怪物数量
        char sql[1024];
        sprintf(sql, "select hero_id "
            " from hellgate.hero_killed_monster where hero_id=%u "
            , hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() == NULL) {
                is_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    
    {
        char sql[1024];
        if(is_not_exist){ //没有记录 插入新纪录
            sprintf(sql, "insert into hellgate.hero_killed_monster set "
                " hero_id=%u, common_monster_count=%u, elite_monster_count=%u "
                , hero_id, common_count, elite_count);
        }
        else { //有记录则更新
            sprintf(sql, "update hellgate.hero_killed_monster set "
                " common_monster_count=common_monster_count+%u, "
                " elite_monster_count=elite_monster_count+%u "
                " where hero_id=%u"
                , common_count, elite_count, hero_id);
        }
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


bool ProcServerThread::check_and_get_killed_monster_bonus(unsigned int hero_id, unsigned int type)
{
    unsigned int common_count = 0;
    unsigned int elite_count = 0;
    { //查询击杀怪物数量
        char sql[1024];
        sprintf(sql, "select common_monster_count, elite_monster_count "
            " from hellgate.hero_killed_monster where hero_id=%u "
            , hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                common_count = atoi(Mysql_Thread_Conn->GetField("common_monster_count"));
                elite_count = atoi(Mysql_Thread_Conn->GetField("elite_monster_count"));
            }
            else {
                LogMsg("%s, line %d, hero_id[%u] not killed monster record", 
                    __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , 
                __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    std::vector<ItemInfo> item_vec;
    {//查询击杀小怪奖励
        char sql[1024];
        sprintf(sql, "select item_type, item_count "
            " from hellgate.killed_monster_bonus_temp "
            " where type=%u "
            , type);
        try {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                ItemInfo info;
                info.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                info.count = atoi(Mysql_Thread_Conn->GetField("item_count"));

                if(info.count > 0) {
                    item_vec.push_back(info); 
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    if(item_vec.empty()) {
        LogMsg("%s, line %d, type[%u] not have content ", 
            __FILE__, __LINE__, type);
        return false;
    }

    for(int i=0; i<item_vec.size(); i++) { //先入库奖励
        ObtainItem(hero_id, item_vec[i].type, item_vec[i].count);
    }

    {//然后扣除相应的怪物数
        char sql[1024];
        if(type == Accumulate_Common_Monster) {
            sprintf(sql, "update hellgate.hero_killed_monster set "
                " common_monster_count=common_monster_count-%u "
                " where hero_id=%u "
                , CS::cashBonusNeedKilledMonsters(type)
                , hero_id);
        }
        else {
            sprintf(sql, "update hellgate.hero_killed_monster set "
                " elite_monster_count=elite_monster_count-%u "
                " where hero_id=%u "
                , CS::cashBonusNeedKilledMonsters(type)
                , hero_id);
        }
        
        try {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    
    return true;
}


void ProcServerThread::hton_top_arena_info(TopArenaInfo& top_info_in, TopArenaInfo& top_info_out)
{
    hton_hero_info(top_info_in.hero_a, top_info_out.hero_a);
    hton_hero_info(top_info_in.hero_b, top_info_out.hero_b);
    top_info_out.winer = top_info_in.winer;
}


bool ProcServerThread::check_and_guess_top_arena(unsigned int hero_id, unsigned int round, unsigned int group,
        bool guess_winer, unsigned int wager, unsigned int &silver_balance)
{ 
    silver_balance = 0;
    
    unsigned int tmp_round = TopArenaRoundType_NUL;
	TopArenaStat stat[3];
	TopArenaHeroValue value_arr_8_4[4];		//8进4各小组英雄身价
	TopArenaHeroValue value_arr_4_2[2];		//4进2各小组英雄身价
	TopArenaHeroValue value_arr_2_1[1];		//2进1各小组英雄身价

    unsigned int tmp_value = 0;
	
    pthread_mutex_lock(&m_toparena.mutex);
    {
        tmp_round = m_toparena.round;

        for(int i=0; i<3; i++) {
            stat[i] = m_toparena.stat[i];
        }

        memcpy(value_arr_8_4, m_toparena.value_arr_8_4, sizeof(TopArenaHeroValue) *4);
        memcpy(value_arr_4_2, m_toparena.value_arr_4_2, sizeof(TopArenaHeroValue) *2);
        memcpy(value_arr_2_1, m_toparena.value_arr_2_1, sizeof(TopArenaHeroValue));
    }
    pthread_mutex_unlock(&m_toparena.mutex);

    if(round < TopArenaRoundType_8_4 || round > TopArenaRoundType_2_1) {
        LogMsg("%s, line %d, round[%u] is not right" , 
            __FILE__, __LINE__, round);
        return false;
    }

    if(stat[round-1] != TopArenaStat_GuessOpen) {
        LogMsg("%s, line %d, round[%u] guess not open" , 
            __FILE__, __LINE__, round);
        return false;
    }

    char top_table_str[32];
    char guess_table_str[32];
    char field_str[32];
    if(round == TopArenaRoundType_8_4) {
        if(group > 3){
            LogMsg("%s, line %d, round[%u] group[%u] >  4" , 
                __FILE__, __LINE__, round, group+1);
            return false;
        }

        if(guess_winer) {
            tmp_value = value_arr_8_4[group].value_a + wager;
            if(tmp_value > MAX_HERO_VALUE) {
                LogMsg("%s, line %d, value[%u] + wager[%u] over max value" , 
                    __FILE__, __LINE__, value_arr_8_4[group].value_a, wager);
                return false;
            }
        }
        else {
            tmp_value = value_arr_8_4[group].value_b + wager;
            if(tmp_value > MAX_HERO_VALUE) {
                LogMsg("%s, line %d, value[%u] + wager[%u] over max value" , 
                    __FILE__, __LINE__, value_arr_8_4[group].value_b, wager);
                return false;
            }
        }
        
        sprintf(field_str, "value_%d_%s", group+1, guess_winer?"a":"b");
        sprintf(top_table_str, "top_arena_game_8_4");
        sprintf(guess_table_str, "top_arena_guess_8_4");
    }
    else if(round == TopArenaRoundType_4_2) {
        if(group > 1){
            LogMsg("%s, line %d, round[%u] group[%u] >  2" , 
                __FILE__, __LINE__, round, group+1);
            return false;
        }

        sprintf(field_str, "value_%d_%s", group+1, guess_winer?"a":"b");
        sprintf(top_table_str, "top_arena_game_4_2");
        sprintf(guess_table_str, "top_arena_guess_4_2");
    }
    else {
        if(group > 0){
            LogMsg("%s, line %d, round[%u] group[%u] >  1" , 
                __FILE__, __LINE__, round, group+1);
            return false;
        }

        sprintf(field_str, "value_%d_%s", group+1, guess_winer?"a":"b");
        sprintf(top_table_str, "top_arena_game_2_1");
        sprintf(guess_table_str, "top_arena_guess_2_1");
    }

    {//查询是否已经参加
        char sql[1024];
        sprintf(sql, "select 1 "
            " from hellgate.%s "
            " where hero_id=%u "
            , guess_table_str, hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                LogMsg("%s, line %d, hero[%u] already joined guess" , 
                    __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    silver_balance = getItemCountInTeam(hero_id, ItemsType_Silver);

    if(silver_balance < wager) {
        LogMsg("%s, line %d, hero_id[%u] silver not enought " , 
            __FILE__, __LINE__, hero_id);
        return false;
    }

    {//先插入竞猜记录
        char sql[1024];
        sprintf(sql, "insert into hellgate.%s set "
            " hero_id=%u, guess_game=%u, guess_result=%u, wager=%u, is_award=0 "
            , guess_table_str, hero_id
            , group+1
            , guess_winer?0:1
            , wager);
        try {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    // 更新身价缓存
    pthread_mutex_lock(&m_toparena.mutex);
    {
        if(round == TopArenaRoundType_8_4) {
            if(guess_winer)
                m_toparena.value_arr_8_4[group].value_a += wager;
            else
                m_toparena.value_arr_8_4[group].value_b += wager;
        }
        else if(round == TopArenaRoundType_4_2) {
            if(guess_winer)
                m_toparena.value_arr_4_2[group].value_a += wager;
            else
                m_toparena.value_arr_4_2[group].value_b += wager;
        }
        else if(round == TopArenaRoundType_2_1) {
            if(guess_winer)
                m_toparena.value_arr_2_1[group].value_a += wager;
            else
                m_toparena.value_arr_2_1[group].value_b += wager;
        }


        {
            char sql[1024];
            sprintf(sql, "update hellgate.%s set "
                " %s=%s+%u "
                , top_table_str, field_str, field_str, wager);
            try {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e) {
                LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
                exit(1);
            }
        }
    }
    pthread_mutex_unlock(&m_toparena.mutex);


    silver_balance -= wager;
    {//再扣除赌注
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set "
            " item_count=%u where hero_id=%u and item_type=%u "
            , silver_balance, hero_id, ItemsType_Silver);
        try {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    
    return true;
    
}


bool ProcServerThread::query_top_arena_value(unsigned int round, unsigned int group, TopArenaHeroValue &value)
{ 
    value.initValue();
    
    unsigned int tmp_round = TopArenaRoundType_NUL;
	TopArenaStat stat[3];
	TopArenaHeroValue value_arr_8_4[4];		//8进4各小组英雄身价
	TopArenaHeroValue value_arr_4_2[2];		//4进2各小组英雄身价
	TopArenaHeroValue value_arr_2_1[1];		//2进1各小组英雄身价
	
    pthread_mutex_lock(&m_toparena.mutex);
    {
        tmp_round = m_toparena.round;

        for(int i=0; i<3; i++) {
            stat[i] = m_toparena.stat[i];
        }

        memcpy(value_arr_8_4, m_toparena.value_arr_8_4, sizeof(TopArenaHeroValue) *4);
        memcpy(value_arr_4_2, m_toparena.value_arr_4_2, sizeof(TopArenaHeroValue) *2);
        memcpy(value_arr_2_1, m_toparena.value_arr_2_1, sizeof(TopArenaHeroValue));
    }
    pthread_mutex_unlock(&m_toparena.mutex);

    if(round < TopArenaRoundType_8_4 || round > TopArenaRoundType_2_1) {
        LogMsg("%s, line %d, round[%u] is not right" , 
            __FILE__, __LINE__, round);
        return false;
    }

    if(stat[round-1] != TopArenaStat_GuessOpen) {
        LogMsg("%s, line %d, round[%u] guess not open" , 
            __FILE__, __LINE__, round);
        return false;
    }

    if(round == TopArenaRoundType_8_4) {
        if(group > 3){
            LogMsg("%s, line %d, round[%u] group[%u] >  4" , 
                __FILE__, __LINE__, round, group+1);
            return false;
        }

        memcpy(&value, &value_arr_8_4[group], sizeof(TopArenaHeroValue));
    }
    else if(round == TopArenaRoundType_4_2) {
        if(group > 1){
            LogMsg("%s, line %d, round[%u] group[%u] >  2" , 
                __FILE__, __LINE__, round, group+1);
            return false;
        }
        
        memcpy(&value, &value_arr_4_2[group], sizeof(TopArenaHeroValue));
    }
    else {
        if(group > 0){
            LogMsg("%s, line %d, round[%u] group[%u] >  1" , 
                __FILE__, __LINE__, round, group+1);
            return false;
        }
        
        memcpy(&value, &value_arr_2_1[group], sizeof(TopArenaHeroValue));
    }

    return true;
    
}


bool ProcServerThread::check_and_cast_silver(unsigned int hero_id, unsigned int &gold_balance, unsigned int &silver_balance)
{
    gold_balance = 0;
    silver_balance = 0;
    
    //查询剩余铸银次数
    unsigned int cast_num = getHeroVipInfo(hero_id, VIP_FIELD_TYPE_CAST_SILVER);

    if(cast_num == 0){
        LogMsg("%s, line %d, hero[%u] have no cast_silver_num times ", 
            __FILE__, __LINE__, hero_id);
        return false;
    }

    
    unsigned int total_cast_num = 0;
    { //查询当前vip总共铸银次数
        char sql[1024];
        sprintf(sql, "select hellgate.vip_template.cast_silver_num "
            " from hellgate.vip_template, hellgate.hero_vip_info "
            " where hellgate.hero_vip_info.hero_id=%u and "
            " hellgate.vip_template.level=hellgate.hero_vip_info.vip_level "
            , hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                total_cast_num = atoi(Mysql_Thread_Conn->GetField("cast_silver_num"));
            }
            else {
                LogMsg("%s, line %d, the vip level not cast_silver_num record", 
                    __FILE__, __LINE__);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , 
                __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);

    //查询所需金币
    unsigned int gold_need = CS::castSilverNeedGold(total_cast_num -cast_num +1);
    //查询铸造银币数
    unsigned int silver_gain = CS::getCastSilverCount(hero_info.level);

    //查询余额
    gold_balance = getItemCountInTeam(hero_id, ItemsType_Gold);
    silver_balance = getItemCountInTeam(hero_id, ItemsType_Silver);

    if(gold_balance < gold_need){
        LogMsg("%s, line %d, hero[%u] gold not enough ", 
            __FILE__, __LINE__, hero_id);
        return false;
    }

    silver_balance += silver_gain;
    //先添加银币
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count+%u "
            " where hero_id=%u and item_type=%u "
            , silver_gain, hero_id, ItemsType_Silver);
        try{
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    //再扣钱
    gold_balance -= gold_need;
    {
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , gold_balance, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    //铸银次数减1
    updateHeroVipInfo(hero_id, VIP_FIELD_TYPE_CAST_SILVER, cast_num-1);

    return true;
}


bool ProcServerThread::check_and_challenge_legend_note(unsigned int main_hero_id, 
    unsigned int group_id, char **fight_script, int &script_len)
{
    *fight_script = NULL;
    script_len = 0;
    
    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);
    if(hero_info.level < LEVEL_LIMIT_LEGEND_NOTE) { //等级不够
        LogMsg("%s, line %d, hero[u] level[%u] not enough ", 
            __FILE__, __LINE__, main_hero_id, hero_info.level);
        return false;
    }
    
    int index = ZBGroupIsShenbing(group_id);
    if(-1 == index) {
        LogMsg("%s, line %d, group_id[u] is not legend ", 
            __FILE__, __LINE__, group_id);
        return false;
    }

    if(5 != m_shenbing_vec[index].level) {
        LogMsg("%s, line %d, group_id[u] is not level 5 legend ", 
            __FILE__, __LINE__, group_id);
        return false;
    }

    std::vector<unsigned int > prof_vec;
    { //查询主英雄的解锁职业
        char sql[1024];
        sprintf(sql, "select distinct(profession_id) "
            " from hellgate.hero_infor "
            " where (hero_id=%u or parent_hero_id=%u) "
            " and is_unlocked=1 "
            , main_hero_id, main_hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                unsigned int prof_id = atoi(Mysql_Thread_Conn->GetField("profession_id"));
                prof_vec.push_back(prof_id);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]" , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    bool b_same_profession = false;
    for(int i=0; i<prof_vec.size(); i++){
        if(m_shenbing_vec[index].profession_id == prof_vec[i]) {
            b_same_profession = true;
            break;
        }
    }

    if(!b_same_profession) { //解锁英雄职业没有此职业装备
        LogMsg("%s, line %d, group_id[u] legend profession[%u] not same unlocked profession", 
            __FILE__, __LINE__, group_id, m_shenbing_vec[index].profession_id);
        return false;
    }

    unsigned int times = 0;
    { //查询剩余次数
        char sql[1024];
        sprintf(sql, "select time_remainder from hellgate.hero_legend_note_info "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                times = atoi(Mysql_Thread_Conn->GetField("time_remainder"));
            } 
            else {
                LogMsg("%s, line %d, hero[%u] have no legend note record", 
                    __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    if(times == 0) {
        LogMsg("%s, line %d, hero[%u] have no challenge times ", 
            __FILE__, __LINE__, main_hero_id);
        return false;
    }

    { //先把挑战次数减1
        char sql[1024];
        sprintf(sql, "update hellgate.hero_legend_note_info set "
            " time_remainder=time_remainder-1 "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
   
    bool battle_win = false;
    { //再挑战 生成战斗脚本
        unsigned int team_pos_vec[4] = {0, 0, 0, 0}; 
        { //查询我方上阵阵型
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                        return false;
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //真实的怪物数据在战斗脚本获取怪物数据时直接填入
        //必须放在1号位
        unsigned int monster_id = get_special_monster_id(m_shenbing_vec[index].profession_id);
        unsigned int monster_pos_vec_1[4] = {monster_id, 0, 0, 0};
        
        {//生成战斗脚本
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_LegendNote;
            
            HeroState teamHp;
            f_sud.heroId = main_hero_id;
            f_sud.taskId = 1;
            f_sud.gridId = 1;
            FightScriptBuilder scriptBuild;
            std::vector<FightScript> team_script_vec;

            unsigned int fight_index = 1;

            {
                //SpecialControl SControl = SC_NONE;
                FightScript team_script;
                FightScript monster_script;
                f_sud.fightIndex = fight_index;

                //初始化boss的剩余血量
                teamHp.currentHp_B[0] = 1;
                f_sud.heroHpAfterLastFight = teamHp;
                
                teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                    , team_script, monster_script
                    , this
                    , userData, FBB_BoardB
                    , BATTLE_ROUND_LIMIT);
                team_script_vec.push_back(team_script);

                battle_win = (team_script.endResult.myResult == Result_Win);
            }

            if(battle_win) {
                std::vector<ShenbingSuipianInfo> sp_vec;
                std::vector<ItemInfo> item_vec;
                get_challenge_legend_suipian(main_hero_id, group_id, times-1, sp_vec, item_vec);
                
                team_script_vec[0].endResult.gettedShenBingSuiPian = sp_vec;
                team_script_vec[0].endResult.gettedItem = item_vec;
            }
            
            *fight_script = scriptBuild.FightScriptVec_2_CharArr(team_script_vec, script_len);
        }
    }
    return true;
}


bool ProcServerThread::get_challenge_legend_suipian(unsigned int main_hero_id, unsigned int group_id, 
    unsigned int times, std::vector<ShenbingSuipianInfo> &sp_vec, std::vector<ItemInfo> &item_vec)
{
    sp_vec.clear();
    item_vec.clear();
    
    { //掉落教堂升级材料
        ItemInfo info;
        info.type = ItemsType_Dalishi + (Utl::auto_random()%4);
        int ratio = Utl::auto_random()%100;

        if((ratio -= 70) < 0)
            info.count = 1;
        else
            info.count = 2;
            
        item_vec.push_back(info);
    }
    
    
    bool b_first = false;
    { //查询是否是第一次挑战传奇录
        char sql[1024];
        sprintf(sql, "select is_first from hellgate.hero_legend_note_info "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                b_first = !(bool)atoi(Mysql_Thread_Conn->GetField("is_first"));
            } 
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int drop_times = 0;
    {//查询当天掉落次数
        char sql[1024];
        sprintf(sql, "select drop_times from hellgate.hero_legend_note_info "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                drop_times = atoi(Mysql_Thread_Conn->GetField("drop_times"));
            } 
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


    bool b_droped = false; //是否掉落的标志位
    if(b_first) {//第一次打传奇副本必掉
        ShenbingSuipianInfo suipian;
        suipian.zb_group_id = group_id;
        suipian.suipian_count = 1;

        //随机掉落碎片id
        suipian.suipian_id = Utl::auto_random()%5 +1;
        
        sp_vec.push_back(suipian);

        b_droped = true;
    }
    else {//随机决定是否掉落
        const unsigned int const_basic_ratio = 10;  //基础掉率
        int rand_v = Utl::auto_random()%100;
        int id_arr[5] = {1, 2, 3, 4, 5};
        
        std::vector<unsigned int> id_vec;
        id_vec.insert (id_vec.end(), id_arr, id_arr+5);

        if(times == 0 && drop_times == 0) { //每天保底掉落
            rand_v -= 100;
        }
        else {
            rand_v -= const_basic_ratio;
        }
        
        if(rand_v < 0) {//掉
            /* 2014.04.08 修改为轮询掉落 */
           // if(drop_times == 0) { //每天第一次掉落碎片
                //查找还差的碎片id
                char sql[1024];
                sprintf(sql, "select suipian_id, suipian_count from hellgate.shenbing_suipian_in_team "
                    " where hero_id=%u and zb_group_id=%u order by suipian_id, suipian_count "
                    , main_hero_id, group_id);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    while(Mysql_Thread_Conn->FetchRow() != NULL) {
                        unsigned int id = atoi(Mysql_Thread_Conn->GetField("suipian_id"));
                        unsigned int count = atoi(Mysql_Thread_Conn->GetField("suipian_count"));
                        if(count > 0) { //有此id的碎片 排除
                            for(int i=0; i<id_vec.size(); i++) {
                                if(id_vec[i] == id) {
                                    id_vec.erase(id_vec.begin()+i);
                                    break;
                                }
                            }
                        }
                    }
                    
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            //}

            ShenbingSuipianInfo suipian;
            suipian.zb_group_id = group_id;
            suipian.suipian_count = 1;

            //随机掉落碎片id
            if(id_vec.empty()) {
                suipian.suipian_id = Utl::auto_random()%5 +1;
            } else {
                suipian.suipian_id = id_vec[Utl::auto_random()%id_vec.size()];
            }
            
            sp_vec.push_back(suipian);
            
            b_droped = true;
        } 
    }

    if(b_first) {//第一次更新状态
        char sql[1024];
        sprintf(sql, "update hellgate.hero_legend_note_info set "
            " is_first=1 where "
            " hero_id=%u  "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(b_droped){ //更新掉落次数
        char sql[1024];
        sprintf(sql, "update hellgate.hero_legend_note_info set "
            " drop_times=drop_times+1 where "
            " hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<sp_vec.size(); ++i)
    {
        ObtainZhuangbeiSuipian(main_hero_id, sp_vec[i].zb_group_id, sp_vec[i].suipian_id, sp_vec[i].suipian_count);
    }

    return true;
}


unsigned int ProcServerThread::get_special_monster_id(unsigned int prof)
{
    unsigned int monster_id = 0;
    switch(prof) {
        case Profession_Yemanren:
            monster_id = SMID_LegendNote_YeManRen;
            break;
        case Profession_Chike:
            monster_id = SMID_LegendNote_CiKe;
            break;
        case Profession_Fashi:
            monster_id = SMID_LegendNote_FaShi;
            break;
        case Profession_Qishi:
            monster_id = SMID_LegendNote_QiShi;
            break;
        case Profession_ShenJianShou:
            monster_id = SMID_LegendNote_ShenJianShou;
            break;
        case Profession_MiShu:
            monster_id = SMID_LegendNote_MiShu;
            break;
        case Profession_WuSeng:
            monster_id = SMID_LegendNote_WuSeng;
            break;
        case Profession_YouXia:
            monster_id = SMID_LegendNote_YouXia;
            break;
        case Profession_LieShou:
            monster_id = SMID_LegendNote_LieShou;
            break;
        case Profession_WuShi:
            monster_id = SMID_LegendNote_WuShi;
            break;
    }

    return monster_id;
}


struct __hero_order{    
    unsigned int hero_id;
    unsigned int order_id;
};
bool ProcServerThread::query_top_hero_list(unsigned int main_hero_id, unsigned int &hero_order, unsigned int &next_chlg_time,
    std::vector<HeroAndOrder> &order_vec, std::vector<TopHeroReport> &report_vec)
{
#if 0
    struct timeval tm_begin, tm_end;
    gettimeofday(&tm_begin, NULL);
    gettimeofday(&tm_end, NULL);
    LogMsg("%s, line %d, ~~~time is %fs", __FILE__, __LINE__, 
        (tm_end.tv_sec + tm_end.tv_usec/1000000) - (tm_begin.tv_sec + tm_begin.tv_usec/1000000));
#endif
    
    hero_order = 0;
    next_chlg_time = 0;
    order_vec.clear();
    report_vec.clear();

    { //获取自己的名次
        char sql[1024];
        sprintf(sql, "select hero_order, next_chlg_time from " 
            " hellgate.top_hero_list where hero_id=%u", main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                hero_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
                next_chlg_time = atoi(Mysql_Thread_Conn->GetField("next_chlg_time"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id not exist in tophero. [%u]"
                        , __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //获取最后的名次
    unsigned int max_order = 0;
    {
        char sql[1024];
        sprintf(sql, "select max(hero_order) max_hero_order from " 
            " hellgate.top_hero_list ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                max_order = atoi(Mysql_Thread_Conn->GetField("max_hero_order"));
            }
            else
            {
                LogMsg("%s, line %d, hero_id not exist in tophero. [%u]"
                        , __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    std::string sql_str;
    const int const_count = 7; //取出自己的前10名
    int after_count = 2; //取出自己的后3名
    if((max_order-hero_order) < 2){
        after_count = max_order-hero_order;
    }
    
    if(hero_order >= 10){//超过top10 计算从数据库里面取出的排名
        std::vector<unsigned int > tmp_order_vec;
        /*
        if(hero_order <=20) {
            char str[64];
            sprintf(str, "or hero_order<=%u ", hero_order+after_count);
            sql_str += str;
        }
        else 
        */
        if(hero_order <=100) {//已1为单位取10个出来
            char str[64];
            sprintf(str, "or (hero_order>%u and hero_order<=%u) "
                , hero_order-const_count, hero_order+after_count);
            sql_str += str;
        }
        else if(hero_order <= 200) { //已2为单位取10个出来
            const int const_grade = 2;
            int tmp_order = hero_order;
            for(int i=0; i<const_count && tmp_order>100; i++, tmp_order-=const_grade) {
                tmp_order_vec.push_back(tmp_order);
            }

            tmp_order=100;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order--) {
                tmp_order_vec.push_back(tmp_order);
            }

            for(int i=0; i<after_count; i++) {
                tmp_order_vec.push_back(hero_order +1 +i);
            }
        }
        else if(hero_order <= 500) { //已3为单位取10个出来
            const int const_grade = 3;
            int tmp_order = hero_order;
            for(int i=0; i<const_count && tmp_order>200; i++, tmp_order-=const_grade) {
                tmp_order_vec.push_back(tmp_order);
            }

            tmp_order=200;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order-=2) {
                tmp_order_vec.push_back(tmp_order);
            }
            
            for(int i=0; i<after_count; i++) {
                tmp_order_vec.push_back(hero_order +1 +i);
            }
        }
        else if(hero_order <= 1000) { //已5为单位取10个出来
            const int const_grade = 5;
            int tmp_order = hero_order;
            for(int i=0; i<const_count && tmp_order>500; i++, tmp_order-=const_grade) {
                tmp_order_vec.push_back(tmp_order);
            }

            tmp_order=500;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order-=3) {
                tmp_order_vec.push_back(tmp_order);
            }
            
            for(int i=0; i<after_count; i++) {
                tmp_order_vec.push_back(hero_order +1 +i);
            }
        }
        else if(hero_order <= 2000) { //已10为单位取10个出来
            const int const_grade = 10;
            int tmp_order = hero_order;
            for(int i=0; i<const_count && tmp_order>1000; i++, tmp_order-=const_grade) {
                tmp_order_vec.push_back(tmp_order);
            }

            tmp_order=1000;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order-=5) {
                tmp_order_vec.push_back(tmp_order);
            }
            
            for(int i=0; i<after_count; i++) {
                tmp_order_vec.push_back(hero_order +1 +i);
            }
        }
        else if(hero_order <= 5000) { //已20为单位取10个出来
            const int const_grade = 20;
            int tmp_order = hero_order;
            for(int i=0; i<const_count && tmp_order>2000; i++, tmp_order-=const_grade) {
                tmp_order_vec.push_back(tmp_order);
            }

            tmp_order=2000;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order-=10) {
                tmp_order_vec.push_back(tmp_order);
            }
            
            for(int i=0; i<after_count; i++) {
                tmp_order_vec.push_back(hero_order +1 +i);
            }
        }
        else if(hero_order <= 8000) { //已30为单位取10个出来
            const int const_grade = 30;
            int tmp_order = hero_order;
            for(int i=0; i<const_count && tmp_order>5000; i++, tmp_order-=const_grade) {
                tmp_order_vec.push_back(tmp_order);
            }

            tmp_order=5000;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order-=20) {
                tmp_order_vec.push_back(tmp_order);
            }
            
            for(int i=0; i<after_count; i++) {
                tmp_order_vec.push_back(hero_order +1 +i);
            }
        }
        else { //排名前500随机取9名
            const int const_grade = 50;
            int tmp_order = hero_order > 10000 ? 10000 : hero_order;
            tmp_order_vec.push_back(hero_order);

            tmp_order--; //排除自己
            for(int i=0; i<(const_count -1) && tmp_order>8000; i++, tmp_order-=const_grade) {
                
                int ran_num = Utl::auto_random()%const_grade;
                tmp_order_vec.push_back(tmp_order -ran_num);
            }
            
            tmp_order=8000;
            int i = tmp_order_vec.size();
            for(; i<const_count; i++, tmp_order-=30) {
                tmp_order_vec.push_back(tmp_order);
            }

            if(hero_order < (10000-after_count)) {
                for(int i=0; i<after_count; i++) {
                    tmp_order_vec.push_back(hero_order +1 +i);
                }
            }
        }

        for(int i=0; i<tmp_order_vec.size(); i++) {
            char str[64];
            sprintf(str, "or hero_order=%u ", tmp_order_vec[i]);
            sql_str += str;
        }
        
    }
    

    //获取top30英雄列表
    {
        std::vector<__hero_order> top20_hero_order_vec;
        
        char sql[1024];
        sprintf(sql, "select * from hellgate.top_hero_list where "
            " hero_order<=10 " 
            " %s "
            " order by hero_order "
            , sql_str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                __hero_order info;
                info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                info.order_id = atoi(Mysql_Thread_Conn->GetField("hero_order"));

                top20_hero_order_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        if(top20_hero_order_vec.size()<10 || top20_hero_order_vec.size()>(10+ after_count +const_count) )
        {
            LogMsg("%s, line %d, top30_vec.size [%d]"
                            , __FILE__, __LINE__, top20_hero_order_vec.size());
            return false;
        }

        PropertyCalculator calculator;
        for(int i=0; i<top20_hero_order_vec.size(); ++i)
        {
            //获取我方上阵英雄
            unsigned int team_pos_attr[4] = {0, 0, 0, 0};
            unsigned int capacity_attr[4] = {0, 0, 0, 0};
            get_team_formation(top20_hero_order_vec[i].hero_id, team_pos_attr, capacity_attr);
            
            HeroAndOrder info;
            info.order = top20_hero_order_vec[i].order_id;
            info.zhandouli = 0;
            GetHeroBasicInfo(top20_hero_order_vec[i].hero_id, info.hero_info);

            //根据上阵英雄计算队伍战斗力
            for(int i=0; i<4; i++) {
                if(team_pos_attr[i] == 0)
                    continue;
                
                info.zhandouli += capacity_attr[i];
                /*
                ScriptBuilderUserData userData;
                FightSUD f_sud;
                userData.data = &f_sud;
                
                f_sud.battle_type = BattleType_TopHeroChallenge;
                f_sud.heroId = 0;
                f_sud.taskId = 0;
                f_sud.gridId = 0;
                f_sud.hero_a_level = 1;
                f_sud.hero_b_level = 1;
                f_sud.fightIndex = 1;

                BaseHero *base_data = getBaseHero(team_pos_attr[i], userData);
                CalculateData cal_data = base_data->getCalculateData();

                info.zhandouli += (unsigned int)calculator.calculateZhanDouLi(cal_data, Range_Average);
                */
                
            }

            order_vec.push_back(info);
        }
    }


    std::vector<unsigned int> tmp_time_vec;
    {//获取战报
        char sql[1024];
        sprintf(sql, "select fight_time from hellgate.top_hero_report where "
            " challenger_id=%u " 
            " order by fight_time desc "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                unsigned int fight_time = atoi(Mysql_Thread_Conn->GetField("fight_time"));
                tmp_time_vec.push_back(fight_time);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(tmp_time_vec.size() > 20) { //删除战报表中超过20条之前的战报
        char sql[1024];
        sprintf(sql, "delete from hellgate.top_hero_report "
            " where fight_time<=%u and challenger_id=%u "
            , tmp_time_vec[20], main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
        
    }

    
    {//获取战报
        char sql[1024];
        sprintf(sql, "select * from hellgate.top_hero_report where "
            " challenger_id=%u or be_challenger_id=%u " 
            " order by fight_time desc "
            , main_hero_id, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                TopHeroReport info;
                bzero(&info, sizeof(TopHeroReport));
                info.challenger.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("challenger_id"));
                info.challenger.order = atoi(Mysql_Thread_Conn->GetField("challenger_order"));
                info.be_challenger.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("be_challenger_id"));
                info.be_challenger.order = atoi(Mysql_Thread_Conn->GetField("be_challenger_order"));

                info.challenger_win = (bool)atoi(Mysql_Thread_Conn->GetField("is_result"));
                info.fight_time = atoi(Mysql_Thread_Conn->GetField("fight_time"));

                report_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    for(int i=0; i<report_vec.size(); i++){ //填充英雄信息
        GetHeroBasicInfo(report_vec[i].challenger.hero_info.hero_id, report_vec[i].challenger.hero_info);
        GetHeroBasicInfo(report_vec[i].be_challenger.hero_info.hero_id, report_vec[i].be_challenger.hero_info);

        //填充战斗另一方当前排名
        char sql[1024];
        if(report_vec[i].challenger.hero_info.hero_id != main_hero_id) {
            sprintf(sql, "select hero_order from hellgate.top_hero_list where "
                " hero_id=%u " 
                , report_vec[i].challenger.hero_info.hero_id);
        }
        else {
            sprintf(sql, "select hero_order from hellgate.top_hero_list where "
                " hero_id=%u " 
                , report_vec[i].be_challenger.hero_info.hero_id);
        }
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                report_vec[i].other_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


bool ProcServerThread::check_and_challenge_top_hero(unsigned int main_hero_id, unsigned int chlg_hero_id,
    unsigned int &order_after_fight, unsigned int &next_chlg_time, char **fight_script, int &script_len)
{
    order_after_fight = 0;
    next_chlg_time = 0;
    *fight_script = NULL;
    script_len = 0;
    
    unsigned int main_hero_order = 0;
    unsigned int comp_hero_order = 0;
    { //查询玩家排名信息
        char sql[1024];
        sprintf(sql, "select hero_order, next_chlg_time from hellgate.top_hero_list where hero_id=%u", main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                main_hero_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
                next_chlg_time = atoi(Mysql_Thread_Conn->GetField("next_chlg_time"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] not exist in tophero"
                        , __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(next_chlg_time > (unsigned int)time(NULL)) { //处于挑战冷却时间 不能挑战
        LogMsg("%s, line %d, hero[%u] challenge time cd, can not challenge"
                , __FILE__, __LINE__, main_hero_id);
        return false;
    }
    
    { //查询被挑战者排名
        char sql[1024];
        sprintf(sql, "select hero_order from hellgate.top_hero_list where hero_id=%u", chlg_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                comp_hero_order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(comp_hero_order == 0) {
        LogMsg("%s, line %d, hero[%u] not exist in tophero"
            , __FILE__, __LINE__, chlg_hero_id);
        return false;
    }

    if(main_hero_order < comp_hero_order) { //排名高于被挑战者 不能挑战
        LogMsg("%s, line %d, hero[%u] order higher than bechallenger[%u]"
            , __FILE__, __LINE__, main_hero_id, chlg_hero_id);
        return false;
    }

    //fight
    FightScript script_hero;
    {
        //查询我方上阵阵型
        unsigned int team_pos_vec[4] = {0, 0, 0, 0};
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //查询对方阵型
        unsigned int comp_pos_vec[4] = {0, 0, 0, 0};
        {
            std::vector<int> arr;
            
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , chlg_hero_id, chlg_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                    }
                    else
                    {
                        comp_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        //查询双方等级
        unsigned int hero_a_level = 0;
        unsigned int hero_b_level = 0;
        {
            HeroInfo info;
            GetHeroBasicInfo(main_hero_id,info);
            hero_a_level = info.level;
        }
        {
            HeroInfo info;
            GetHeroBasicInfo(chlg_hero_id,info);
            hero_b_level = info.level;
        }
       
        { //生成战斗脚本
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_TopHeroChallenge;
            f_sud.heroId = 0;
            f_sud.taskId = 0;
            f_sud.gridId = 0;
            f_sud.hero_a_level = hero_a_level;
            f_sud.hero_b_level = hero_b_level;
            FightScriptBuilder scriptBuild;
            f_sud.fightIndex = 1;

            FightScript script_comp;
        
            scriptBuild.genScript(team_pos_vec, comp_pos_vec
                , script_hero, script_comp
                , this
                , userData
                , FBB_BoardB
                , BATTLE_ROUND_LIMIT);

            
            std::vector<FightScript> script_vec;
            script_vec.push_back(script_hero);
            *fight_script = scriptBuild.FightScriptVec_2_CharArr(script_vec, script_len);
        }
    }

    //是否需要调整名次
    //std::vector<HeroAndOrder> other_hero_vec;
    if(script_hero.endResult.myResult == Result_Win) { 
        
        /* 2014.04.15  调整为挑战两者名次互换
        {//将main_hero_order到comp_hero_order的人全部下移一位
            char sql[1024];
            sprintf(sql, "update hellgate.top_hero_list "
                " set hero_order=hero_order+1"
                " where hero_order>=%u and hero_order<%u"
                , comp_hero_order, main_hero_order);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        */

        { //将chlg_hero_id自己改为main_hero_order
            char sql[1024];
            sprintf(sql, "update hellgate.top_hero_list "
                " set hero_order=%u"
                " where hero_id=%u"
                , main_hero_order, chlg_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        
        { //将hero自己改为comp_hero_order
            char sql[1024];
            sprintf(sql, "update hellgate.top_hero_list "
                " set hero_order=%u"
                " where hero_id=%u"
                , comp_hero_order, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //
        unsigned int tmp_main_order = main_hero_order;
        main_hero_order = comp_hero_order;
        comp_hero_order = tmp_main_order;
        //getSomeotherHeroInTopList(main_hero_order, other_hero_vec);
    }
    else { //失败，增加冷却时间
        next_chlg_time = (unsigned int)time(NULL) + TOP_HERO_CHALLENGE_LOSE_CD_Time;
        
        char sql[1024];
        sprintf(sql, "update hellgate.top_hero_list "
            " set next_chlg_time=%u"
            " where hero_id=%u"
            , next_chlg_time
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    order_after_fight = main_hero_order;

    {//插入新战报
        bool b_result = (script_hero.endResult.myResult == Result_Win);
        
        char sql[1024];
        sprintf(sql, "insert into hellgate.top_hero_report set "
            " challenger_id=%u, challenger_order=%u, "
		    " be_challenger_id=%u, be_challenger_order=%u, "
		    " is_result=%u, fight_time=%u "
		    , main_hero_id
		    , main_hero_order
		    , chlg_hero_id
		    , comp_hero_order //b_result ? (main_hero_order+1) : comp_hero_order
		    , b_result
            , (unsigned int)time(NULL));
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    //触发悬赏任务
    send_system_bonus_notify(main_hero_id, BonusType_Reward, BonusID_TopHeroList);
    
    return true;
}


bool ProcServerThread::clear_top_hero_cd_time(unsigned int hero_id, unsigned int &gold_balance, unsigned int &next_chlg_time)
{
    gold_balance = 0;
    next_chlg_time = 0;

    { //查询英雄冷却时间
        char sql[1024];
        sprintf(sql, "select next_chlg_time "
            " from hellgate.top_hero_list "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                next_chlg_time = atoi(Mysql_Thread_Conn->GetField("next_chlg_time"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] record not exist ", 
                    __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(next_chlg_time <= (unsigned int)time(NULL)) { // 冷却时间已过
        LogMsg("%s, line %d, hero[%u] have no cd time ", 
            __FILE__, __LINE__, hero_id);
        return false;
    }

    gold_balance = getItemCountInTeam(hero_id, ItemsType_Gold);

    unsigned int gold_need = CS::clearTopHeroCDTimeNeedGold();

    if(gold_balance < gold_need) {
        LogMsg("%s, line %d, hero[%u] gold[%u] not enough ", 
            __FILE__, __LINE__, hero_id, gold_balance);
        return false;
    }

    { //先清除cd
        next_chlg_time = (unsigned int)time(NULL) -1;
        char sql[1024];
        sprintf(sql, "update hellgate.top_hero_list set " 
            " next_chlg_time=%u "
            " where hero_id=%u "
            , next_chlg_time, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    gold_balance -= gold_need;
    { //再扣钱
        char sql[1024];
        sprintf(sql, "update hellgate.items_in_team set item_count=%u "
            " where hero_id=%u and item_type=%u"
            , gold_balance, hero_id, ItemsType_Gold);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


void ProcServerThread::self_challenge_timer()
{
    time_t cur_time = time(NULL);
    tm* p_tm = localtime(&cur_time);

    //每小时检查一次
    if(p_tm->tm_sec==1 && p_tm->tm_min==0) {
        clear_self_challenge_order();
    }
}


bool ProcServerThread::check_and_self_challenge(unsigned int main_hero_id, unsigned int difficulty, 
	unsigned int &energy, unsigned int &checkpoints, bool &is_have_box, unsigned int &silver,
	GiftBag &gift_bag, char **fight_script, int &script_len)
{
    energy = 0;
    checkpoints = 0;
    is_have_box = false;
    silver = 0;
    *fight_script = NULL;
    script_len = 0;
    memset(&gift_bag, 0, sizeof(GiftBag));

    if(difficulty < SelfChlgDiffType_Common || difficulty > SelfChlgDiffType_Nightmare) { 
        //难度不正确
        LogMsg("%s, line %d, difficulty[%u] is not right ", 
            __FILE__, __LINE__, difficulty);
        return false;
    }

    SelfChlgInfo info;
    unsigned int died_point = 0;
    bzero(&info, sizeof(SelfChlgInfo));
    { //查询英雄自我挑战状态
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.self_challenge_hero "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                info.times = atoi(Mysql_Thread_Conn->GetField("time_remainder"));
                info.b_on_the_way = (bool)atoi(Mysql_Thread_Conn->GetField("b_on_the_way"));
                
                info.energy = atoi(Mysql_Thread_Conn->GetField("energy"));
                info.hp_gain = atoi(Mysql_Thread_Conn->GetField("hp_gain"));
                info.attack_gain = atoi(Mysql_Thread_Conn->GetField("attack_gain"));
                info.defense_gain = atoi(Mysql_Thread_Conn->GetField("defense_gain"));
                
                info.difficulty = atoi(Mysql_Thread_Conn->GetField("difficulty"));
                info.checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));
                died_point = atoi(Mysql_Thread_Conn->GetField("died_point"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] record not exist ", 
                    __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);

    if(info.difficulty == 0) {
        info.difficulty = CS::getSelfChlgDifficulty(hero_info.level);

        if(info.difficulty == SelfChlgDiffType_NULL) {
            LogMsg("%s, line %d, hero[%u] level[%u] not enough ", 
                __FILE__, __LINE__, main_hero_id, hero_info.level);
            return false;
        }
    }
 
    if(info.difficulty != difficulty) {
        LogMsg("%s, line %d, difficulty[%u] be different from table[%u] ", 
            __FILE__, __LINE__, difficulty, info.difficulty);
        return false;
    }
    
    if(info.checkpoints >= 100) {
        LogMsg("%s, line %d, checkpoints[%u] over the max checkpoints", 
            __FILE__, __LINE__, info.checkpoints);
        return false;
    }

    if(info.times==0) {
        LogMsg("%s, line %d, hero[%u] have no challenge times", 
            __FILE__, __LINE__, main_hero_id);
        return false;
    }

    bool battle_win = false;
    std::vector<PowerPoint> power_vec;
    { //再挑战 生成战斗脚本
        unsigned int team_pos_vec[4] = {0, 0, 0, 0}; 
        { //查询我方上阵阵型
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                        return false;
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //获取怪物数据
        unsigned int monster_pos_vec[4] = {0, 0, 0, 0};
        get_self_challenge_monster(main_hero_id, info.checkpoints +1, monster_pos_vec);
        {//生成战斗脚本
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_SelfChallenge;
            f_sud.battle_kind = difficulty;
            
            HeroState teamHp;
            f_sud.heroId = main_hero_id;
            f_sud.taskId = 1;
            f_sud.gridId = 1;
            f_sud.hero_b_level = info.checkpoints +1;
            FightScriptBuilder scriptBuild;
            std::vector<FightScript> team_script_vec;

            unsigned int fight_index = 1;

            {
                //SpecialControl SControl = SC_NONE;
                FightScript team_script;
                FightScript monster_script;
                f_sud.fightIndex = fight_index;

                //初始化boss的剩余血量
                teamHp.currentHp_B[0] = 1;
                f_sud.heroHpAfterLastFight = teamHp;
                
                teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec
                    , team_script, monster_script
                    , this
                    , userData, FBB_BoardA
                    , BATTLE_ROUND_LIMIT);
                team_script_vec.push_back(team_script);

                battle_win = (team_script.endResult.myResult == Result_Win);
            }

            if(battle_win) {
                int ran_num = Utl::auto_random()%100;
                if(ran_num < 40) { 
                    PowerPoint pow;
                    pow.power = 5;
                    power_vec.push_back(pow);
                }
                
                team_script_vec[0].endResult.gettedPowerPoints = power_vec;
            }
            
            *fight_script = scriptBuild.FightScriptVec_2_CharArr(team_script_vec, script_len);
        }
    }

    for(int i=0; i<power_vec.size(); i++) {
        info.energy += power_vec[i].power;
    }

    if(battle_win){ 
        info.checkpoints++;
        info.energy += PASS_SELFCHLG_CHECKPOINT_ENERGY;

        if(info.checkpoints%5 == 0) { // 每5关生成宝箱
            is_have_box = true;
            update_self_challenge_box(main_hero_id, info.difficulty);
        }
        
        if(info.checkpoints%20 == 0) { // 每20关奖励银币
            silver = 100 * info.checkpoints * self_chlg_coefficient[info.difficulty -1];
            ObtainItem(main_hero_id, ItemsType_Silver, silver);

            if(info.checkpoints == 40) {
                gift_bag.id = 34;
                gift_bag.count = 1;
            }
            else if(info.checkpoints == 60) {
                gift_bag.id = 35;
                gift_bag.count = 1;
            }
            else if(info.checkpoints == 80) {
                gift_bag.id = 36;
                gift_bag.count = 1;
            }
            else if(info.checkpoints == 100) {
                gift_bag.id = 37;
                gift_bag.count = 1;
            }

            if(gift_bag.id > 0 && gift_bag.count > 0) { //礼包入库
                ObtainGiftBag(main_hero_id, gift_bag.id, gift_bag.count);
            }
        }

        { //更新相关难度排名表
            update_self_challenge_order(main_hero_id, info.difficulty, info.checkpoints);
        }

        if(info.checkpoints >= 50) { //触发悬赏任务
            send_system_bonus_notify(main_hero_id, BonusType_Reward, BonusID_SelfChallenge);
        }
    }
    else {
        info.times--;
        died_point = info.checkpoints;
        if(info.times > 0) {
            info.energy += 60;
        }
    }

    checkpoints = info.checkpoints;
    energy = info.energy;
    { //更新自我挑战状态表
        char sql[1024];
        sprintf(sql, "update hellgate.self_challenge_hero set "
            " time_remainder=%u, b_on_the_way=%u, "
            " energy=%u, difficulty=%u, checkpoints=%u, died_point=%u"
            " where hero_id=%u "
            , info.times, battle_win?1:0
            , energy, info.difficulty, checkpoints, died_point
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


void ProcServerThread::update_self_challenge_box(unsigned int hero_id, unsigned int difficulty)
{
    
    std::list<ItemInfo> item_list;
    std::list<unsigned int> weight_list;
    unsigned int weight_total = 0;
    {//先查询模板表的奖励宝箱
        char sql[1024];
        sprintf(sql, "select item_type, item_count, weight "
            " from hellgate.self_challenge_box_temp ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                ItemInfo item;
                item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                
                item_list.push_back(item);

                unsigned int weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                weight_list.push_back(weight);

                weight_total += weight;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(item_list.size() < 3)
        return;

    std::vector<ItemInfo> item_vec;
    //固定取出3个item
    for(int i=0; i<3; ++i)
    {
        int rand_weight = Utl::auto_random()%weight_total;

        std::list<ItemInfo>::iterator item_list_pos = item_list.begin();
        std::list<unsigned int>::iterator weight_list_pos = weight_list.begin();
        for(; item_list_pos!=item_list.end(); ++item_list_pos, ++weight_list_pos)
        {
            rand_weight -= *weight_list_pos;
            if(rand_weight < 0)
            {
                //就他了
                item_vec.push_back(*item_list_pos);

                item_list.erase(item_list_pos);
                weight_list.erase(weight_list_pos);
                weight_total -= *weight_list_pos;

                break;
            }
        }
        if(item_list_pos == item_list.end())
        {
            assert(false);
        }
    }

    
    if(item_vec.empty())
        return;
    
    if(difficulty > SelfChlgDiffType_Difficult) {
        int coff = (difficulty==SelfChlgDiffType_Hell ? 2 : 3);
        for(int i=0; i<item_vec.size(); i++) {
            item_vec[i].count *= coff;
        }
    }

    bool b_not_exist = false;
    {//查询自我挑战宝箱记录表
        char sql[1024];
        sprintf(sql, "select 1 from hellgate.self_challenge_box_hero "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            
            if(Mysql_Thread_Conn->FetchRow() == NULL)
            {
                b_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    {//更新记录
        char sql[1024];
        if(b_not_exist) {
            sprintf(sql, "insert into hellgate.self_challenge_box_hero set "
                " hero_id=%u, is_get=0, item_type_1=%u,  item_count_1=%u, "
                " item_type_2=%u,  item_count_2=%u, item_type_3=%u,  item_count_3=%u "
                , hero_id, item_vec[0].type, item_vec[0].count
                , item_vec[1].type, item_vec[1].count, item_vec[2].type, item_vec[2].count);
        }
        else {
            sprintf(sql, "update hellgate.self_challenge_box_hero set "
                " is_get=0, item_type_1=%u,  item_count_1=%u, "
                " item_type_2=%u,  item_count_2=%u, item_type_3=%u,  item_count_3=%u "
                " where hero_id=%u "
                , item_vec[0].type, item_vec[0].count
                , item_vec[1].type, item_vec[1].count, item_vec[2].type, item_vec[2].count
                , hero_id);
        }
        
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::clear_self_challenge_order(void)
{
    const char *table_arr[4] = {"self_challenge_order_common", "self_challenge_order_difficult",
        "self_challenge_order_hell", "self_challenge_order_nightmare"};
    unsigned int bonus_arr[4] = {EmailID_SelfChlgOrderCommon_1, EmailID_SelfChlgOrderDifficult_1,
        EmailID_SelfChlgOrderHell_1, EmailID_SelfChlgOrderNightmare_1};
    
    std::vector<SelfChlgOrder> order_vec;
    std::vector<unsigned int> time_vec;
    for (int i=0; i<4; i++) {
        order_vec.clear();
        time_vec.clear();

        {
            char sql[1024];
            sprintf(sql, "select * from hellgate.%s "
                " order by hero_order "
                , table_arr[i]);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL) {
                    SelfChlgOrder info;
                    bzero(&info, sizeof(SelfChlgOrder));
                    info.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                    info.order = atoi(Mysql_Thread_Conn->GetField("hero_order"));

                    unsigned int tmp_time = atoi(Mysql_Thread_Conn->GetField("pass_timestamp"));

                    if(info.hero_info.hero_id > 0) {
                        order_vec.push_back(info);
                        time_vec.push_back(tmp_time);
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        unsigned int min_time = time(NULL);
        for(int j=0; j<time_vec.size(); j++){ //找出最小的时间
            if(min_time < time_vec[j]) 
                min_time = time_vec[j];
        }

        
        if(isNeedSystemDailyRefresh(min_time, SystemDailyTask_Hour)) {
            //需要刷新
            unsigned int bonus_id = bonus_arr[i];
            for(int j=0; j<order_vec.size(); j++) {  //发放到系统奖励
                if(order_vec[j].order >= 4)
                    bonus_id += 3;
                else if(order_vec[j].order == 3) 
                    bonus_id += 2;
                else if(order_vec[j].order == 2) 
                    bonus_id += 1;
                    
                //先插入自我挑战排行榜奖励的邮件状态
                insert_into_email(order_vec[j].hero_info.hero_id, 0, EmailType_Bonus, bonus_id);
            }

            if(!order_vec.empty()){ //清空自我挑战排名表
                char sql[1024];
                sprintf(sql, "delete from hellgate.%s "
                    , table_arr[i]);
                try
                {
                    Mysql_Thread_Conn->Query(sql);            
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
    }
}


void ProcServerThread::update_self_challenge_order(unsigned int hero_id, 
    unsigned int difficulty, unsigned int checkpoints)
{
    char table_str[64];
    std::vector<SelfChlgOrder> order_vec;

    {
        if(difficulty == SelfChlgDiffType_Common)
            sprintf(table_str, "self_challenge_order_common");
        else if(difficulty == SelfChlgDiffType_Difficult)
            sprintf(table_str, "self_challenge_order_difficult");
        else if(difficulty == SelfChlgDiffType_Hell)
            sprintf(table_str, "self_challenge_order_hell");
        else
            sprintf(table_str, "self_challenge_order_nightmare");
    }

    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.%s "
            " order by hero_order desc "
            , table_str);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                SelfChlgOrder info;
                info.hero_info.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
                info.order = atoi(Mysql_Thread_Conn->GetField("hero_order"));
                info.checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));

                order_vec.push_back(info);
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if((order_vec.size() >= 10) && (order_vec[0].checkpoints >= checkpoints)) {
        //不需更新排名表
        return ;
    }
    
    bool b_found_old = false;  //查找在表中是否有此英雄的记录
    unsigned int old_order = 0;
    for(int i=0; i<order_vec.size(); i++) {
        if(hero_id == order_vec[i].hero_info.hero_id) {
            old_order = order_vec[i].order;
            b_found_old = true;
            break;
        }
    }

    unsigned int new_order = 11;
    bool b_found_new = false;   //查找最新的order标志位
    if(!order_vec.empty()) {
        if(checkpoints > order_vec[order_vec.size()-1].checkpoints) { //比第一名分数高
                new_order = order_vec[order_vec.size()-1].order;
                b_found_new = true;
        }
        else {
            for(int i=0; i<order_vec.size()-1; ++i) { //找到新的名次
                if(checkpoints > order_vec[i].checkpoints && 
                    checkpoints <= order_vec[i+1].checkpoints) {
                    
                    new_order = order_vec[i].order;
                    b_found_new = true;
                    break;
                }
            }
        }
    }

    if(b_found_new) { //找到新排名
        {//将old_order到now_order的人全部下移一位
            char sql[1024];
            sprintf(sql, "update hellgate.%s "
                " set hero_order=hero_order+1 "
                " where hero_order>=%u and hero_order<%u "
                , table_str
                , new_order, old_order);
            try
            {
                Mysql_Thread_Conn->Query(sql);         
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        { //将hero自己改为new_order
            char sql[1024];
            if(b_found_old) { //更新
                sprintf(sql, "update hellgate.%s "
                    " set checkpoints=%u, hero_order=%u, pass_timestamp=%u "
                    " where hero_id=%u"
                    , table_str
                    , checkpoints, new_order, (unsigned int)time(NULL)
                    , hero_id);
            }
            else { //插入新纪录
                sprintf(sql, "insert into hellgate.%s "
                    " set hero_id=%u, checkpoints=%u, hero_order=%u, pass_timestamp=%u "
                    , table_str
                    , hero_id, checkpoints, new_order, (unsigned int)time(NULL));
            }
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    else {
        char sql[1024];
        if(b_found_old){ //排名没有变化 更新关卡数
            sprintf(sql, "update hellgate.%s "
                " set checkpoints=%u, pass_timestamp=%u "
                " where hero_id=%u"
                , table_str
                , checkpoints, (unsigned int)time(NULL)
                , hero_id);
        }
        else { //排名最后插入新纪录
            sprintf(sql, "insert into hellgate.%s "
                " set hero_id=%u, checkpoints=%u, hero_order=%u, pass_timestamp=%u "
                , table_str
                , hero_id, checkpoints
                , order_vec.empty() ? 1 : order_vec[0].order +1
                , (unsigned int)time(NULL));
        }
        
        try
        {
            Mysql_Thread_Conn->Query(sql);         
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    { //删除超过10名以后的排名
        char sql[1024];
        sprintf(sql, "delete from hellgate.%s "
            " where hero_order>10"
            , table_str);
        try
        {
            Mysql_Thread_Conn->Query(sql);         
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return ;
}


bool ProcServerThread::check_and_gain_self_challenge(unsigned int main_hero_id, unsigned int type, unsigned int degree, 
    unsigned int &energy, unsigned int &hp_gain, unsigned int &attack_gain, unsigned int &defense_gain)
{
    energy = 0;
    hp_gain = 0;
    attack_gain = 0;
    defense_gain = 0;

    if(type < SelfChlgGainType_HP || type > SelfChlgGainType_Defense) { 
        //加成类型不对
        LogMsg("%s, line %d, gain type[%u] is not right ", 
            __FILE__, __LINE__, type);
        return false;
    }

    if(degree < SelfChlgGainDegree_Low || degree > SelfChlgGainDegree_High) { 
        //加成程度不对
        LogMsg("%s, line %d, gain degree[%u] is not right ", 
            __FILE__, __LINE__, degree);
        return false;
    }

    {//查询英雄自我挑战状态
        char sql[1024];
        sprintf(sql, "select hp_gain, attack_gain, defense_gain, energy "
            " from hellgate.self_challenge_hero "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                energy = atoi(Mysql_Thread_Conn->GetField("energy"));
                hp_gain = atoi(Mysql_Thread_Conn->GetField("hp_gain"));
                attack_gain = atoi(Mysql_Thread_Conn->GetField("attack_gain"));
                defense_gain = atoi(Mysql_Thread_Conn->GetField("defense_gain"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] record not exist ", 
                    __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int need_energy = 0;
    unsigned int gain = 0;

    CS::getSelfChlgGain(type, degree, need_energy, gain);
    if(energy < need_energy) {
        LogMsg("%s, line %d, energy is not enough ", 
            __FILE__, __LINE__, energy);
        return false;
    }

    char field[32];
    if(type == SelfChlgGainType_HP) {
        hp_gain += gain;
        sprintf(field, "hp_gain");
    }
    else if(type == SelfChlgGainType_Attack) {
        attack_gain += gain;
        sprintf(field, "attack_gain");
    }
    else {
        defense_gain += gain;
        sprintf(field, "defense_gain");
    }

    energy -= need_energy;
    { //更新
        char sql[1024];
        sprintf(sql, "update hellgate.self_challenge_hero set "
            " %s=%s+%u, energy=%u "
            " where hero_id=%u "
            , field, field, gain, energy
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


bool ProcServerThread::check_and_get_self_challenge_box(unsigned int hero_id, 
    ItemInfo &item, std::vector<ItemInfo> &item_vec)
{
    bzero(&item, sizeof(ItemInfo));
    item_vec.clear();

    
    unsigned int checkpoints = 0;
    {//查询英雄自我挑战状态
        char sql[1024];
        sprintf(sql, "select checkpoints "
            " from hellgate.self_challenge_hero "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] record not exist ", 
                    __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(checkpoints%5 != 0) {
        LogMsg("%s, line %d, checkpoints[%u] is not 5 times ", 
            __FILE__, __LINE__, checkpoints);
        return false;
    }
    
    std::vector<ItemInfo> tmp_item_vec;
    bool is_get = false;
    {//查询英雄自我挑战状态
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.self_challenge_box_hero "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));

                if(is_get) {
                    LogMsg("%s, line %d, box already get. ", __FILE__, __LINE__);
                    return false;
                }
                
                ItemInfo info;
                info.type = atoi(Mysql_Thread_Conn->GetField("item_type_1"));
                info.count = atoi(Mysql_Thread_Conn->GetField("item_count_1"));
                tmp_item_vec.push_back(info);
                
                info.type = atoi(Mysql_Thread_Conn->GetField("item_type_2"));
                info.count = atoi(Mysql_Thread_Conn->GetField("item_count_2"));
                tmp_item_vec.push_back(info);
                
                info.type = atoi(Mysql_Thread_Conn->GetField("item_type_3"));
                info.count = atoi(Mysql_Thread_Conn->GetField("item_count_3"));
                tmp_item_vec.push_back(info);
            }
            else {
                LogMsg("%s, line %d, hero[%u] record not exist ", 
                    __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    
    int ran_num= Utl::auto_random()%3;

    for(int i=0; i<tmp_item_vec.size(); i++) {
        if(i == ran_num) {
            item  = tmp_item_vec[i];
        }
        else {
            item_vec.push_back(tmp_item_vec[i]);
        }
    }

    //入库
    ObtainItem(hero_id, item.type, item.count);
    return true;
}


void ProcServerThread::get_self_challenge_monster(unsigned int hero_id, unsigned int checkpoints, unsigned int monster_vec[])
{
    unsigned int guanqia_id = 0, tmp_checkpoints = 0;
    bool b_not_exist = false;
    { //查询自我挑战的关卡id
        char sql[1024];
        sprintf(sql, "select checkpoints, guanqia_id from hellgate.self_challenge_monster "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                tmp_checkpoints = atoi(Mysql_Thread_Conn->GetField("checkpoints"));
                guanqia_id = atoi(Mysql_Thread_Conn->GetField("guanqia_id"));
            }
            else {
                b_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(checkpoints != tmp_checkpoints) { //闯过的关卡不同 更新
        if(checkpoints < 20) {
            unsigned int guanqia_arr[4] = {525, 526, 527, 528};
            int index = Utl::auto_random()%4;
            guanqia_id = guanqia_arr[index];
        }
        else if(checkpoints == 20) {
            guanqia_id = 537;
        }
        else if(checkpoints < 40) {
            unsigned int guanqia_arr[4] = {527, 528, 529, 530};
            int index = Utl::auto_random()%4;
            guanqia_id = guanqia_arr[index];
        }
        else if (checkpoints == 40) {
            guanqia_id = 538;
        }
        else if(checkpoints < 60) {
            unsigned int guanqia_arr[4] = {529, 530, 531, 532};
            int index = Utl::auto_random()%4;
            guanqia_id = guanqia_arr[index];
        }
        else if (checkpoints == 60) {
            guanqia_id = 539;
        }
        else if(checkpoints < 80) {
            unsigned int guanqia_arr[4] = {531, 532, 533, 534};
            int index = Utl::auto_random()%4;
            guanqia_id = guanqia_arr[index];
        }
        else if (checkpoints == 80) {
            guanqia_id = 540;
        }
        else if(checkpoints < 100) {
            unsigned int guanqia_arr[4] = {533, 534, 535, 536};
            int index = Utl::auto_random()%4;
            guanqia_id = guanqia_arr[index];
        }
        else {
            guanqia_id = 541;
        }

        {/* 更新自我挑战的关卡id */
            char sql[1024];
            if(b_not_exist) { //记录不存在, 插入新纪录
                sprintf(sql, "insert into hellgate.self_challenge_monster set "
                    " hero_id=%u, checkpoints=%u, guanqia_id=%u "
                    , hero_id, checkpoints, guanqia_id);
            }
            else {//记录不存在, 插入新纪录
                sprintf(sql, "update hellgate.self_challenge_monster set "
                    " checkpoints=%u, guanqia_id=%u "
                    " where hero_id=%u "
                    , checkpoints, guanqia_id
                    , hero_id);
            }
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    
    { //查询怪物队形
        char sql[1024];
        sprintf(sql, "select monster_id_3_1, monster_id_3_2, monster_id_3_3, monster_id_3_4 "
            " from hellgate.task_template_test "
            " where guanqia_id=%u "
            , guanqia_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                monster_vec[0]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_1"));
                monster_vec[1]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_2"));
                monster_vec[2]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_3"));
                monster_vec[3]= atoi(Mysql_Thread_Conn->GetField("monster_id_3_4"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return ;
}


bool ProcServerThread::query_protect_spirit(unsigned int hero_id, unsigned int chapter,
    HeroInfo &first_spirit, ProtectSpiritInfo &current_spirit, bool &is_worship, bool &is_loser)
{
    is_worship = false;
    is_loser = false;
    bzero(&first_spirit, sizeof(HeroInfo));
    bzero(&current_spirit, sizeof(ProtectSpiritInfo));

    if(chapter < 1 || chapter > MAX_CHAPTER_NUM) { //章节不对
        LogMsg("%s, line %d, chapter[%u] is not right ", 
            __FILE__, __LINE__, chapter);
        return false;
    }

    { //查询最初守护
        char sql[1024];
        sprintf(sql, "select hero_id "
            " from hellgate.protect_spirit_first where chapter=%u"
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                first_spirit.hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(first_spirit.hero_id > 0) {
        GetHeroBasicInfo(first_spirit.hero_id, first_spirit);
    }

    unsigned int type = 0;
    unsigned int refresh_timestamp = 0;
    unsigned int original_spirit = 0;
    { //查询当前守护
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.protect_spirit where chapter=%u"
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type = atoi(Mysql_Thread_Conn->GetField("type"));
                current_spirit.spirit_id = atoi(Mysql_Thread_Conn->GetField("spirit_id"));
                current_spirit.defend_time = atoi(Mysql_Thread_Conn->GetField("defend_timestamp"));
                current_spirit.is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
                original_spirit = atoi(Mysql_Thread_Conn->GetField("original_spirit"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(/*current_spirit.is_get && */isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour)) {
        //刷新领取状态
        current_spirit.is_get = false;
        
        char sql[1024];
        sprintf(sql, "update hellgate.protect_spirit set "
            " is_get=0, refresh_timestamp=%u " 
            " where chapter=%u"
            , (unsigned int)time(NULL)
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(type == 1) { //玩家
        HeroInfo tmp_info;
        GetHeroBasicInfo(current_spirit.spirit_id, tmp_info);

        //判断当前玩家等级是否超过此守护最高等级
        if(chapter != CS::getProtectSpiritChapter(tmp_info.level)) { //等级已超过
            type = 0;
            current_spirit.spirit_id = original_spirit;
            current_spirit.defend_time = (unsigned int)time(NULL);
            current_spirit.is_get= false;
            
            { //还原原始守护之灵的id
                char sql[1024];
                sprintf(sql, "update hellgate.protect_spirit set "
                    " type=%u, spirit_id=%u, is_get=0, defend_timestamp=%u " 
                    " where chapter=%u "
                    , type
                    , current_spirit.spirit_id
                    , current_spirit.defend_time
                    , chapter);
                try
                {
                    Mysql_Thread_Conn->Query(sql);
                    Mysql_Thread_Conn->FreeResult();
                }
                catch(CMysqlException& e)
                {
                    LogMsg("%s, line %d, mysql exception. [%s]"
                                , __FILE__, __LINE__, e.GetErrMsg());
                    //
                    exit(1);
                }
            }
        }
        else { //正常状态 
            current_spirit.profession_id = tmp_info.profession_id;
            current_spirit.level = tmp_info.level;
            strncpy(current_spirit.name, tmp_info.name, HeroNameMaxLen+1);

            if(current_spirit.spirit_id == hero_id) { //玩家为守护之灵
                return true;
            }
        }
    }

    if(type == 0) { //怪物
        char sql[1024];
        
        sprintf(sql, "select guaiwu_zhiye, guaiwu_level, profession_name "
            " from hellgate.guaiwu_list_new, hellgate.guaiwu_profession_list "
            " where guaiwu_id=%u and "
            "  hellgate.guaiwu_list_new.guaiwu_zhiye=hellgate.guaiwu_profession_list.profession_id "
            , current_spirit.spirit_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                current_spirit.profession_id = (Profession)atoi(Mysql_Thread_Conn->GetField("guaiwu_zhiye"));
                current_spirit.level = atoi(Mysql_Thread_Conn->GetField("guaiwu_level"));
                char *name = Mysql_Thread_Conn->GetField("profession_name");
                strncpy(current_spirit.name, name, HeroNameMaxLen+1);
            }
            else
            {
                LogMsg("%s, line %d, monster_id[%u] not exist", 
                    __FILE__, __LINE__, current_spirit.spirit_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    

    bool b_not_exist = false;
    refresh_timestamp = 0;
    { //查询膜拜状态
        char sql[1024];
        sprintf(sql, "select * "
            " from hellgate.protect_spirit_worship where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                is_worship = (bool)atoi(Mysql_Thread_Conn->GetField("is_worship"));
                refresh_timestamp = atoi(Mysql_Thread_Conn->GetField("refresh_timestamp"));
            }
            else {
                b_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(b_not_exist) { //记录不存在 插入新纪录
        char sql[1024];
        sprintf(sql, "insert into hellgate.protect_spirit_worship set "
            " hero_id=%u, is_worship=0, refresh_timestamp=%u " 
            , hero_id, (unsigned int)time(NULL));
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else if(/*is_worship && */isNeedSystemDailyRefresh(refresh_timestamp, SystemDailyTask_Hour)) {
        //刷新领取状态
        is_worship = false;
        
        char sql[1024];
        sprintf(sql, "update hellgate.protect_spirit_worship set "
            " is_worship=0, refresh_timestamp=%u " 
            " where hero_id=%u"
            , (unsigned int)time(NULL)
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    unsigned int lose_timestamp = 0;
    { //查询被挑战失败状态
        char sql[1024];
        sprintf(sql, "select lose_timestamp "
            " from hellgate.protect_spirit_loser "
            " where chapter=%u and hero_id=%u"
            , chapter, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                lose_timestamp = atoi(Mysql_Thread_Conn->GetField("lose_timestamp"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(lose_timestamp > 0) { 
        if(isNeedSystemDailyRefresh(lose_timestamp, SystemDailyTask_Hour)) { 
            //超过一天 删除此失败记录
            char sql[1024];
            sprintf(sql, "delete from hellgate.protect_spirit_loser "
            " where chapter=%u and hero_id=%u"
            , chapter, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
        else {
            is_loser = true;
        }
        
    }
    
    return true;
}


bool ProcServerThread::challenge_protect_spirit(unsigned int main_hero_id, unsigned int chapter,
    char **fight_script, int &script_len)
{
    *fight_script = NULL;
    script_len = 0;

    if(chapter < 1 || chapter > MAX_CHAPTER_NUM) { //章节不对
        LogMsg("%s, line %d, chapter[%u] is not right ", 
            __FILE__, __LINE__, chapter);
        return false;
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);

    if(chapter != CS::getProtectSpiritChapter(hero_info.level)) { //章节不对
        LogMsg("%s, line %d, level[%u], chapter[%u] is not right ", 
            __FILE__, __LINE__, hero_info.level, chapter);
        return false;
    }

    unsigned int star = 0;
    { //查询是否完美通关
        char sql[1024];
        sprintf(sql, "select star from hellgate.rate_chapter_stat "
            " where hero_id=%u and task_id=%u"
            , main_hero_id, chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                star = atoi(Mysql_Thread_Conn->GetField("star"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(star != 2) { //不是完美通关
        LogMsg("%s, line %d, hero[%d], chapter[%u] is not perfect pass ", 
            __FILE__, __LINE__, main_hero_id, chapter);
        return false;
    }

    unsigned int type = 0, spirit_id = 0;
    { //查询当前守护
        char sql[1024];
        sprintf(sql, "select type, spirit_id "
            " from hellgate.protect_spirit where chapter=%u"
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                type = atoi(Mysql_Thread_Conn->GetField("type"));
                spirit_id = atoi(Mysql_Thread_Conn->GetField("spirit_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(type == 1) { 
        if(spirit_id == main_hero_id) { //玩家为守护之灵
            LogMsg("%s, line %d, hero[%u] is protective spirit. ", 
                __FILE__, __LINE__, main_hero_id);
            return false;
        }
    }

    unsigned int loser_timestamp = 0;
    { //查询被挑战失败状态
        char sql[1024];
        sprintf(sql, "select lose_timestamp "
            " from hellgate.protect_spirit_loser "
            " where chapter=%u and hero_id=%u"
            , chapter, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                loser_timestamp = atoi(Mysql_Thread_Conn->GetField("loser_timestamp"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(loser_timestamp > 0) { //在当天被挑战下来 不能挑战
        if(!isNeedSystemDailyRefresh(loser_timestamp, SystemDailyTask_Hour)) { 
            LogMsg("%s, line %d, hero[%u] is loser today, can not challenge. ", 
                __FILE__, __LINE__, main_hero_id);
            return false;
        }
    }


    bool battle_win = false;
    std::vector<FightScript> team_script_vec;

    if(type == 1) { //玩家
        FightScript script_a, script_b;
                
        PvP(BattleType_ProtectSpirit, FBB_BoardA
            , main_hero_id, spirit_id
            , script_a, script_b);
        
        battle_win = (script_a.endResult.myResult == Result_Win);
                
        //a
        team_script_vec.clear();
        team_script_vec.push_back(script_a);
        
        FightScriptBuilder scriptBuild;
        *fight_script = scriptBuild.FightScriptVec_2_CharArr(team_script_vec, script_len);
    }
    else { //怪物
        unsigned int team_pos_vec[4] = {0, 0, 0, 0}; 
        { //查询我方上阵阵型
            char sql[1024];
            sprintf(sql, "select hero_id, position from hellgate.hero_infor "
                " where (parent_hero_id=%u or hero_id=%u) and position>0"
                , main_hero_id, main_hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                    unsigned int hero_id = atoi(Mysql_Thread_Conn->GetField("hero_id"));

                    if(pos <= 0 || pos > 4)
                    {
                        LogMsg("%s, line %d, parent_hero_id=[%u] pos=[%d]"
                            , __FILE__, __LINE__, main_hero_id, pos);
                        return false;
                    }
                    else
                    {
                        team_pos_vec[pos-1] = hero_id;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //真实的怪物数据在战斗脚本获取怪物数据时直接填入
        //必须放在1号位
        unsigned int monster_pos_vec_1[4] = {spirit_id, 0, 0, 0};
        
        {//生成战斗脚本
            ScriptBuilderUserData userData;
            FightSUD f_sud;
            userData.data = &f_sud;
            
            f_sud.battle_type = BattleType_ProtectSpirit;
            f_sud.battle_kind = 1;
            
            HeroState teamHp;
            f_sud.heroId = main_hero_id;
            f_sud.taskId = 1;
            f_sud.gridId = 1;
            FightScriptBuilder scriptBuild;
            std::vector<FightScript> team_script_vec;
            
            unsigned int fight_index = 1;
            {
                //SpecialControl SControl = SC_NONE;
                FightScript team_script;
                FightScript monster_script;
                f_sud.fightIndex = fight_index;

                //初始化boss的剩余血量
                teamHp.currentHp_B[0] = 1;
                f_sud.heroHpAfterLastFight = teamHp;
                
                teamHp = scriptBuild.genScript(team_pos_vec, monster_pos_vec_1
                    , team_script, monster_script
                    , this
                    , userData, FBB_BoardA
                    , BATTLE_ROUND_LIMIT);
                team_script_vec.push_back(team_script);

                battle_win = (team_script.endResult.myResult == Result_Win);
                *fight_script = scriptBuild.FightScriptVec_2_CharArr(team_script_vec, script_len);
            }
        }
    }
    

    if(battle_win){ //更新守护之灵表
        //守护之灵插入到跑马灯消息队列中
        insert_marquee_message(MarqueeType_ProtectSpirit, main_hero_id, chapter);

        char sql[1024];
        sprintf(sql, "update hellgate.protect_spirit set "
            " type=1, spirit_id=%u, "
            " defend_timestamp=%u, "
            " is_get=0, "
            " refresh_timestamp=%u "
            " where chapter=%u "
            , main_hero_id
            , (unsigned int)time(NULL)
            , (unsigned int)time(NULL)
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        bool b_not_exsit = false;
        { //查询初代守护之灵信息
            sprintf(sql, "select 1 from hellgate.protect_spirit_first "
                " where chapter=%u "
                , chapter);
            try
            {
                Mysql_Thread_Conn->Query(sql);   
                if(Mysql_Thread_Conn->FetchRow() == NULL) {
                    b_not_exsit = true;
                }
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(b_not_exsit) { //初代守护之灵不存在 插入新纪录
            sprintf(sql, "insert into hellgate.protect_spirit_first set "
                " chapter=%u, hero_id=%u, defend_timestamp=%u "
                , chapter
                , main_hero_id
                , (unsigned int)time(NULL));
            try
            {
                Mysql_Thread_Conn->Query(sql); 
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        if(type == 1) { //把失败者放入到失败表中去
            sprintf(sql, "insert into hellgate.protect_spirit_loser set "
                " chapter=%u, hero_id=%u, lose_timestamp=%u "
                , chapter
                , spirit_id
                , (unsigned int)time(NULL));
            try
            {
                Mysql_Thread_Conn->Query(sql); 
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }
    
    return true;
}


bool ProcServerThread::check_and_get_protect_spirit_bonus(unsigned int main_hero_id, 
    unsigned int chapter, std::vector<ItemInfo> &item_vec)
{
    item_vec.clear();
    
    if(chapter < 1 || chapter > MAX_CHAPTER_NUM) { //章节不对
        LogMsg("%s, line %d, chapter[%u] is not right ", 
            __FILE__, __LINE__, chapter);
        return false;
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);

    if(chapter != CS::getProtectSpiritChapter(hero_info.level)) { //章节不对
        LogMsg("%s, line %d, level[%u], chapter[%u] is not right ", 
            __FILE__, __LINE__, hero_info.level, chapter);
        return false;
    }

    unsigned int spirit_id = 0, defend_timestamp = 0;
    bool is_get = false;
    { //查询当前守护
        char sql[1024];
        sprintf(sql, "select spirit_id, defend_timestamp, is_get "
            " from hellgate.protect_spirit where chapter=%u"
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                is_get = (bool)atoi(Mysql_Thread_Conn->GetField("is_get"));
                defend_timestamp = atoi(Mysql_Thread_Conn->GetField("defend_timestamp"));
                spirit_id = atoi(Mysql_Thread_Conn->GetField("spirit_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(spirit_id != main_hero_id) { //玩家不是守护之灵
        LogMsg("%s, line %d, hero[%u] is not protective spirit. ", 
            __FILE__, __LINE__, main_hero_id);
        return false;
    }

    if(is_get) { //玩家已经领取过
        LogMsg("%s, line %d, hero[%u] already get the bonus. ", 
            __FILE__, __LINE__, main_hero_id);
        return false;
    }

    unsigned int days = pastSystemDays(defend_timestamp, SystemDailyTask_Hour);
    CS::getProtectSpiritBonus(chapter, days, item_vec);
    for(int i=0; i<item_vec.size(); i++) { //入库
        if(item_vec[i].count > 0)
            ObtainItem(main_hero_id, item_vec[i].type, item_vec[i].count);
    }
    
    {//更新领取状态
        char sql[1024];
        sprintf(sql, "update hellgate.protect_spirit set "
            " is_get=1 "
            " where chapter=%u"
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


bool ProcServerThread::check_and_worship_protect_spirit(unsigned int main_hero_id, unsigned int chapter,
    GiftBag &gift_bag)
{
    memset(&gift_bag, 0, sizeof(GiftBag));
    if(chapter < 1 || chapter > MAX_CHAPTER_NUM) { //章节不对
        LogMsg("%s, line %d, chapter[%u] is not right ", 
            __FILE__, __LINE__, chapter);
        return false;
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(main_hero_id, hero_info);

    if(chapter != CS::getProtectSpiritChapter(hero_info.level)) { //章节不对
        LogMsg("%s, line %d, level[%u], chapter[%u] is not right ", 
            __FILE__, __LINE__, hero_info.level, chapter);
        return false;
    }

    unsigned int spirit_id = 0;
    { //查询当前守护
        char sql[1024];
        sprintf(sql, "select spirit_id "
            " from hellgate.protect_spirit where chapter=%u"
            , chapter);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                spirit_id = atoi(Mysql_Thread_Conn->GetField("spirit_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(spirit_id == main_hero_id) { //玩家是守护之灵
        LogMsg("%s, line %d, hero[%u] is protective spirit. ", 
            __FILE__, __LINE__, main_hero_id);
        return false;
    }
    
    bool is_worship = false;
    { //查询膜拜状态
        char sql[1024];
        sprintf(sql, "select is_worship "
            " from hellgate.protect_spirit_worship where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                is_worship = (bool)atoi(Mysql_Thread_Conn->GetField("is_worship"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(is_worship) { //玩家已经膜拜过
        LogMsg("%s, line %d, hero[%u] already get worship. ", 
            __FILE__, __LINE__, main_hero_id);
        return false;
    }

    /* 2014.07.04 改为赠送id为33的礼包的东西
    std::vector<ItemInfo> item_vec;
    CS::worshiProtectSpirit(chapter, item_vec);

    for(int i=0; i<item_vec.size(); i++) { //入库
        if(item_vec[i].count > 0)
            ObtainItem(main_hero_id, item_vec[i].type, item_vec[i].count);
    }
    */
        
    { //填充礼包
        gift_bag.id = 33;
        gift_bag.count = 1;
        ObtainGiftBag(main_hero_id, gift_bag.id, gift_bag.count);
    }
    
    { //更新膜拜状态
        char sql[1024];
        sprintf(sql, "update hellgate.protect_spirit_worship set "
            " is_worship=1 "
            " where hero_id=%u"
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


int ProcServerThread::debuff_protect_spirit(unsigned int spirit_id)
{
    int debuff = 0;
    time_t defend_time, now_time;
    defend_time = now_time = time(NULL);
    { //查询最初时间
        char sql[1024];
        sprintf(sql, "select defend_timestamp "
            " from hellgate.protect_spirit where spirit_id=%u"
            , spirit_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                defend_time = atoi(Mysql_Thread_Conn->GetField("defend_timestamp"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
 
    if(defend_time > now_time) {
        return 0;
    }

    int days = pastSystemDays(defend_time, SystemDailyTask_Hour);
    if(days < 0) days = 0;
    else if(days > 5) days = 5;

    debuff = 10 * days;
    return debuff;
}


bool ProcServerThread::check_and_discover(unsigned int hero_id, bool akey_all, 
    bool &is_destroyed, unsigned int &remainder_times, 
    unsigned int &discovered_times, unsigned int &last_modify_timestamp, 
    std::vector<ItemInfo> &item_vec)
{
    is_destroyed = false;
    remainder_times = 0;
    discovered_times = 0;
    last_modify_timestamp = 0;
    item_vec.clear();

    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);

    if(akey_all && hero_info.vip_level < 3) { //VIP等级不够
        LogMsg("%s, line %d, hero[%u] vip[%u] not enough ", 
            __FILE__, __LINE__, hero_id, hero_info.vip_level);
        return false;
    }
    
    unsigned int destroy_seal = 0;
    unsigned int unlocked_seal = 0;
    bool tmp_is_destroyed = false;
    { //查询探索信息
        char sql[1024];
        sprintf(sql, "select remainder_times, discovered_times, is_destroyed, destroy_seal, unlocked_seal, "
            " last_modify_timestamp "
            " from hellgate.discover_hero where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                remainder_times = atoi(Mysql_Thread_Conn->GetField("remainder_times"));
                discovered_times = atoi(Mysql_Thread_Conn->GetField("discovered_times"));
                destroy_seal = atoi(Mysql_Thread_Conn->GetField("destroy_seal"));
                tmp_is_destroyed = (bool)atoi(Mysql_Thread_Conn->GetField("is_destroyed"));
                unlocked_seal = atoi(Mysql_Thread_Conn->GetField("unlocked_seal"));
                last_modify_timestamp = atoi(Mysql_Thread_Conn->GetField("last_modify_timestamp"));
            }
            else {
               LogMsg("%s, line %d, hero[%u] record not exist ", 
                    __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(remainder_times == 0) {
        LogMsg("%s, line %d, hero[%u] times not enough ", 
            __FILE__, __LINE__, hero_id);
        return false;
    }

    if(((destroy_seal %3) == 0)  && ((destroy_seal /3)>unlocked_seal)) {
        LogMsg("%s, line %d, hero[%u] always can unlocked the seal ", 
            __FILE__, __LINE__, hero_id);
        return false;
    }

    //如果剩余次数是满的 那么回复时间点就从现在开始计算
    if(remainder_times == CS::getDiscoverLimitTimes(hero_info.vip_level)) {
        last_modify_timestamp = (unsigned int)time(NULL);
    }

    unsigned int tmp_times = 0;
    if(akey_all) {
        tmp_times = remainder_times;
    }
    else {
        tmp_times = 1;
    }
    
    discovered_times += tmp_times;
    remainder_times -= tmp_times;
    if(destroy_seal < 6) { //未超过封印次数
        if(discovered_times >= 25 && !tmp_is_destroyed) {
            is_destroyed = true;
            tmp_is_destroyed = true;
            destroy_seal++;
            
            //触发悬赏任务
            send_system_bonus_notify(hero_id, BonusType_Reward, BonusID_Discover);
            
            //破坏封印插入到跑马灯消息队列中
            insert_marquee_message(MarqueeType_Discover_Destroy, hero_id, 0);
        }
    }

    if(is_destroyed) { //摧毁封印 奖励减少一个
        tmp_times--;
    }

    if(tmp_times > 0) {
        std::vector<ItemInfo> tmp_item_vec;
        std::vector<unsigned int> weight_vec;
        unsigned int weight_total = 0;
        {//查询探索奖励模板
            char sql[1024];
            sprintf(sql, "select * "
                " from hellgate.discover_bonus_temp "
                " order by weight desc");
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL) {
                    ItemInfo info;
                    info.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                    info.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                    unsigned int weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                    if(info.count > 0) {
                        tmp_item_vec.push_back(info);
                        weight_vec.push_back(weight);
                        weight_total += weight;
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        ItemInfo item_arr[3];
        bzero(item_arr, sizeof(ItemInfo)*3);
        item_arr[0].type = ItemsType_Gold;
        item_arr[1].type = ItemsType_Silver;
        item_arr[2].type = ItemsType_QianghuaNormal;
        
        for(int i=0; i<tmp_times; i++) { //获取奖励
            int ran_num= Utl::auto_random() % weight_total;

            for(int j=0; j<weight_vec.size(); j++) {
                if((ran_num -= weight_vec[j]) < 0){
                    if(tmp_item_vec[j].type == ItemsType_Gold) {
                        item_arr[0].count += tmp_item_vec[j].count;
                    }
                    else if(tmp_item_vec[j].type == ItemsType_Silver) {
                        item_arr[1].count += tmp_item_vec[j].count;
                    }
                    else if(tmp_item_vec[j].type == ItemsType_QianghuaNormal) {
                        item_arr[2].count += tmp_item_vec[j].count;
                    }
                    
                    break;
                }
            }
        }
        
        for(int i=0; i<3; i++) { //入库
            if(item_arr[i].count > 0) {
                ObtainItem(hero_id, item_arr[i].type, item_arr[i].count);
                item_vec.push_back(item_arr[i]);
            }
        }
    }


    { //更新状态
        char sql[1024];
        sprintf(sql, " update hellgate.discover_hero set "
            " remainder_times=%u, last_modify_timestamp=%u, discovered_times=%u, "
            " is_destroyed=%u, destroy_seal=%u "
            " where hero_id=%u"
            , remainder_times
            , last_modify_timestamp
            , discovered_times
            , tmp_is_destroyed
            , destroy_seal
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


bool ProcServerThread::check_and_unlock_discover_seal(unsigned int main_hero_id, unsigned int profession_id,
    unsigned int &destroy_seal, unsigned int &unlocked_seal, std::vector<__ZhuangbeiDetail> &zhuangbei_vec)
{
    destroy_seal = 0;
    unlocked_seal = 0;
    zhuangbei_vec.clear();
    if(profession_id <= 0 || profession_id >10){
        LogMsg("%s, line %d, hero[%u], profession_id[%u], profession is waring. "
            , __FILE__, __LINE__, main_hero_id, profession_id);
        return false;
    }

    if(profession_id > 3) {//查询站位
        char sql[1024];
        sprintf(sql, "select position from hellgate.hero_infor "
            " where parent_hero_id=%u and profession_id=%u "
            , main_hero_id, profession_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                
                unsigned int pos = atoi(Mysql_Thread_Conn->GetField("position"));
                if(pos == 0){
                    LogMsg("%s, line %d, hero[%u], profession_id[%u] not on battle "
                        , __FILE__, __LINE__, main_hero_id, profession_id);
                    return false;
                }
            } 
            else {
                LogMsg("%s, line %d, hero[%u], profession_id[%u] is not exist. "
                    , __FILE__, __LINE__, main_hero_id, profession_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    { //查询破坏封印
        char sql[1024];
        sprintf(sql, "select destroy_seal, unlocked_seal from hellgate.discover_hero "
            " where hero_id=%u "
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                destroy_seal = atoi(Mysql_Thread_Conn->GetField("destroy_seal"));
                unlocked_seal = atoi(Mysql_Thread_Conn->GetField("unlocked_seal"));
            } 
            else {
                LogMsg("%s, line %d, hero[%u] discover record is not exist. "
                    , __FILE__, __LINE__, main_hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if((destroy_seal %3) != 0) { //破坏封印数不是3的倍数
         LogMsg("%s, line %d, hero[%u] destroy_seal[%u] not enough. "
            , __FILE__, __LINE__, main_hero_id, destroy_seal);
        return false;
    }

    if(unlocked_seal >= (destroy_seal /3)) { //已经解封印了
         LogMsg("%s, line %d, hero[%u] destroy_seal[%u] always unlocked the seal. "
            , __FILE__, __LINE__, main_hero_id, destroy_seal);
        return false;
    }
    
    //查询本职业和该等级的蓝装和稀有以及5级传奇
    std::vector<__zb_type_group_id> fumo_vec;
    std::vector<__zb_type_group_id> xiyou_vec;
    std::vector<unsigned int> legend_vec;

    for(int i=0; i<m_shenbing_vec.size(); i++) {
        if(m_shenbing_vec[i].level == 5 && m_shenbing_vec[i].profession_id == profession_id){
            legend_vec.push_back(m_shenbing_vec[i].zb_group_id);
        }
    }

    if(legend_vec.empty()) { //没有5级传奇装备
         LogMsg("%s, line %d, hero[%u] not have legend zb. "
            , __FILE__, __LINE__, main_hero_id);
        return false;
    }

    {  //获取装备
        int index = Utl::auto_random()%legend_vec.size();
        unsigned int zb_name_id = chooseZhuangbeiNameIdFromGroupId(legend_vec[index]);
        //
        if(zb_name_id == 0) {
            LogMsg("%s, line %d, shit.", __FILE__, __LINE__);
            assert(false);
        }

        __ZhuangbeiDetail detail;
        if(!createZhuangbei(zb_name_id, legend_vec[index], main_hero_id, detail))
        {
            LogMsg("%s, line %d, createzhuangbei failed. zb_name_id[%u]"
                                    , __FILE__, __LINE__, zb_name_id);
            return false;
        }

        
        //解封印获取到传奇插入到跑马灯消息队列中
        insert_marquee_message(MarqueeType_Discover_Unlock, main_hero_id, legend_vec[index]);
        
        //入库
        detail.zhuangbei_id = ObtainZhuangbei(main_hero_id, zb_name_id, detail);

        zhuangbei_vec.push_back(detail);
    }


    if(destroy_seal == 6) { //重新更新点亮石碑和解锁装备数
        destroy_seal = 0;
        unlocked_seal = 0;
    }
    else {
        unlocked_seal = destroy_seal /3;
    }
    
    
    { //更新状态
        char sql[1024];
        sprintf(sql, "update hellgate.discover_hero set "
            " destroy_seal=%u, unlocked_seal=%u "
            " where hero_id=%u "
            , destroy_seal, unlocked_seal
            , main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


unsigned int ProcServerThread::calculate_fight_capacity(unsigned int hero_id)
{
    unsigned int n_value = 0;
    HeroDetail hero_detail;
    GetHeroDetail(hero_id,hero_detail);

    unsigned int body_id = 0;
    if(hero_detail.basic_info.is_yuanshen) { //获取真身id
        char sql[1024];
        sprintf(sql, "select zhenshen_id "
            " from hellgate.hero_infor where is_yuanshen=1 and hero_id=%u"
            , hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                body_id = atoi(Mysql_Thread_Conn->GetField("zhenshen_id"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]", __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    else {
        body_id = hero_id;
    }

    if(body_id == 0) {
        return n_value;
    }

    ScriptBuilderUserData userData;
    FightSUD f_sud;
    userData.data = &f_sud;
    userData.teamTag = 1;
    
    f_sud.battle_type = BattleType_TopHeroChallenge;
    f_sud.heroId = 0;
    f_sud.taskId = 0;
    f_sud.gridId = 0;
    f_sud.hero_a_level = 1;
    f_sud.hero_b_level = 1;
    f_sud.fightIndex = 1;

    short cd_time;
	getHeroCDTime(cd_time, body_id, userData);
    Hero* hero_ret = getBattleScriptHero(f_sud, body_id, cd_time);
       
    { //skill
        SkillType skill_type;
        unsigned int skill_level;
        getHeroSkill(body_id, skill_type, skill_level);
        SkillDataForFight skill_data(skill_type, skill_level);
        hero_ret->skilVec.push_back(skill_data);
    }

    PropertyCalculator calculator;
    float tmp_cal = calculator.calculateZhanDouLi(hero_ret->getCalculateData(), Range_Average);
    n_value = (unsigned int)tmp_cal;
                   
    { //入库
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set "
            " fight_capacity=%u "
            " where hero_id=%u "
            , n_value
            , body_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        } 
    }
    
    return n_value;
}


unsigned int ProcServerThread::get_unequipped_counts(unsigned int hero_id)
{
    unsigned int total_count = 0;
    { //获取装备总数
        char sql[1024];
        sprintf(sql, "select count(zhuangbei_id) as total_count "
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy where "
            " owner_hero_id=%u and zhuangbei_hero_id=0 and "
            " hellgate.zhuangbei_list.zhuangbei_name_id=hellgate.zhuangbei_name_list_copy.zhuangbei_name_id "
            " and hellgate.zhuangbei_name_list_copy.zhuangbei_colour!=%u"
            , hero_id, ZhuangbeiColour_Chuanqi);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                total_count = atoi(Mysql_Thread_Conn->GetField("total_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]", 
                __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    
    return total_count;
}


struct _RandomBoxAndWeight
{
    ItemInfo item;
    unsigned int weight;
};
int ProcServerThread::check_and_flop(unsigned int main_hero_id, unsigned int task, unsigned int grid,
    unsigned int &boss_stat, unsigned int &grid_stat, std::vector<ItemInfo> &item_vec)
{
    boss_stat = TaskGridStat_PreFlop;
    grid_stat = TaskGridStat_PreFlop;
    item_vec.clear();
     
    //判断task和grid是否当前可进入
    if(!canHeroEnterTaskGrid(main_hero_id, task, grid)) {
        LogMsg("%s, line %d, task[%u] is error"
            , __FILE__, __LINE__, task);
        return Error;
    }

    //首先获取棋盘的布局
    unsigned int grid_count_heng = 0;
    unsigned int grid_count_shu = 0;
    CS::getTaskChessboardFormat(task, grid_count_heng, grid_count_shu);
    unsigned int grid_count_total = grid_count_heng *grid_count_shu;
    
    //再判断grid是否合法
    if(grid == 0 || grid>grid_count_total) {
        LogMsg("%s, line %d, grid[%u] is error"
            , __FILE__, __LINE__, grid);
        return Error;
    }

    //棋盘，最大棋盘17个格子
    const int max_grid_count = 17;
    int grid_id = 0;
    unsigned int grid_stat_arr[max_grid_count];
    memset(grid_stat_arr, 0, max_grid_count);
    
    { //查询当前grid的状态
        char sql[1024], id_field[32], stat_field[32];
        sprintf(sql, "select * "
            " from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , main_hero_id, task);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                sprintf(id_field, "grid_id_%u", grid);
                grid_id = atoi(Mysql_Thread_Conn->GetField(id_field));

                for(int i=0; i<(grid_count_total+1); ++i) {
                    sprintf(stat_field, "grid_stat_%u", i);
                    grid_stat_arr[i] = atoi(Mysql_Thread_Conn->GetField(stat_field));
                }
            }
            else {
                LogMsg("%s, line %d, hero[%u], task[%u] chess board record is not exist"
                    , __FILE__, __LINE__, main_hero_id, task);
                return Error;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(grid_stat_arr[grid] != TaskGridStat_PreFlop) { //牌已经翻过
        LogMsg("%s, line %d, task[%u] grid[%u] already floped"
            , __FILE__, __LINE__, task, grid);
        return Error;
    }

    if(!subVitality(main_hero_id, Vitality_GuanQia_Floped)) { //消耗体力
        LogMsg("%s, line %d, hero[%u] vitality not enough"
            , __FILE__, __LINE__, main_hero_id, task);
        return TiliNotEnought;
    }


    if(grid_id == 0) { //空格子
        grid_stat = TaskGridStat_Folded;
    }
    else if(grid_id == -1) { //宝箱
        grid_stat = TaskGridStat_Folded;
        
        std::vector<_RandomBoxAndWeight> box_weight_vec;
        unsigned int weight_total=0;
        { //获取宝箱物品权重
            char sql[1024];
            sprintf(sql, "select item_type, item_count, weight from hellgate.random_box_temp "
                " order by id ");
            try
            {
                Mysql_Thread_Conn->Query(sql);
                while(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    _RandomBoxAndWeight tmp_item_weight;
                    
                    tmp_item_weight.item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                    tmp_item_weight.item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                    tmp_item_weight.weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                    
                    if(tmp_item_weight.item.count > 0) {
                        weight_total += tmp_item_weight.weight;
                        box_weight_vec.insert(box_weight_vec.end(), tmp_item_weight);
                    }
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
            
        int ran_num = Utl::auto_random()%weight_total;
        for(int i=0; i<box_weight_vec.size(); ++i) {
            ran_num -= box_weight_vec[i].weight;
            if(ran_num <= 0) {
                item_vec.push_back(box_weight_vec[i].item);
                break;
            }
        }
        
        if(item_vec.empty()) {
            LogMsg("%s, line %d, . shit" , __FILE__, __LINE__);
            return Error;
        }
            
        for(int i=0; i<item_vec.size(); ++i) {//把东西放入到包裹中
            ObtainItem(main_hero_id, item_vec[i].type, item_vec[i].count);
        }
        
    }
    else if(grid_id > 0) { //怪物
        grid_stat = TaskGridStat_Floped;
    }
    else {
        return Error;
    }

    boss_stat = grid_stat_arr[0];
    if(grid_id <= 0) { //在其为空牌或者宝箱牌的时候 更新boss状态
        grid_stat_arr[grid] = grid_stat; //置装态
        if(grid_stat_arr[0] == TaskGridStat_PreFlop) {
            boss_stat = TaskGridStat_Floped;
            for(int i=1; i<grid_count_total+1; ++i) {
                if(grid_stat_arr[i] != TaskGridStat_Folded) {
                    boss_stat = TaskGridStat_PreFlop;
                    break;
                }
            }
        }
    }

    
    { //改变状态
        char sql[1024], stat_field[32];
        sprintf(stat_field, "grid_stat_%u", grid);
        
        sprintf(sql, "update hellgate.task_chessboard set  "
            " grid_stat_0=%u, %s=%u "
            " where hero_id=%u and task_id=%u"
            , boss_stat, stat_field, grid_stat, main_hero_id, task);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return Success;
}


bool ProcServerThread::check_and_get_chess_box(unsigned int main_hero_id, unsigned int task, unsigned int grid,
		std::vector<ItemInfo> &item_vec)
{
    item_vec.clear();

     
    //判断task和grid是否当前可进入
    if(!canHeroEnterTaskGrid(main_hero_id, task, grid)) {
        LogMsg("%s, line %d, task[%u] is error"
            , __FILE__, __LINE__, task);
        return false;
    }

    //首先获取棋盘的布局
    unsigned int grid_count_heng = 0;
    unsigned int grid_count_shu = 0;
    CS::getTaskChessboardFormat(task, grid_count_heng, grid_count_shu);
    unsigned int grid_count_total = grid_count_heng *grid_count_shu;
    
    //再判断grid是否合法
    if(grid == 0 || grid>grid_count_total) {
        LogMsg("%s, line %d, grid[%u] is error"
            , __FILE__, __LINE__, grid);
        return false;
    }
    

    int grid_id = 0;
    unsigned int grid_stat = 0;
    char id_field[32], stat_field[32];
    sprintf(id_field, "grid_id_%u", grid);
    sprintf(stat_field, "grid_stat_%u", grid);
    { //查询当前grid的状态
        char sql[1024];
        sprintf(sql, "select %s, %s "
            " from hellgate.task_chessboard "
            " where hero_id=%u and task_id=%u"
            , id_field, stat_field, main_hero_id, task);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                grid_id = atoi(Mysql_Thread_Conn->GetField(id_field));
                grid_stat = atoi(Mysql_Thread_Conn->GetField(stat_field));
            }
            else {
                LogMsg("%s, line %d, hero[%u], task[%u] chess board record is not exist"
                    , __FILE__, __LINE__, main_hero_id, task);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(grid_id != 0) { //宝箱
        LogMsg("%s, line %d, task[%u], grid[%u] is not box"
            , __FILE__, __LINE__, task, grid);
        return false;
    }

    if(grid_stat != TaskGridStat_Floped) { //牌已经翻过
        LogMsg("%s, line %d, task[%u] grid[%u] already folded"
            , __FILE__, __LINE__, task, grid);
        return false;
    }
    
    std::vector<_RandomBoxAndWeight> box_weight_vec;
    unsigned int weight_total=0;
    { //获取宝箱物品权重
        char sql[1024];
        sprintf(sql, "select item_type, item_count, weight from hellgate.random_box_temp "
            " order by id ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL)
            {
                _RandomBoxAndWeight tmp_item_weight;
                
                tmp_item_weight.item.type = atoi(Mysql_Thread_Conn->GetField("item_type"));
                tmp_item_weight.item.count = atoi(Mysql_Thread_Conn->GetField("item_count"));
                tmp_item_weight.weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                
                if(tmp_item_weight.item.count > 0)
                {
                    weight_total += tmp_item_weight.weight;
                    box_weight_vec.insert(box_weight_vec.end(), tmp_item_weight);
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
        
    int ran_num = Utl::auto_random()%weight_total;
    for(int i=0; i<box_weight_vec.size(); ++i) {
        ran_num -= box_weight_vec[i].weight;
        if(ran_num <= 0) {
            item_vec.push_back(box_weight_vec[i].item);
            break;
        }
    }
    
    if(item_vec.empty()) {
        LogMsg("%s, line %d, . shit" , __FILE__, __LINE__);
        assert(false);
    }
        
    for(int i=0; i<item_vec.size(); ++i) {//把东西放入到包裹中
        ObtainItem(main_hero_id, item_vec[i].type, item_vec[i].count);
    }
    

    { //改变状态
        char sql[1024];
        
        sprintf(sql, "update hellgate.task_chessboard set  "
            " %s=%u "
            " where hero_id=%u and task_id=%u"
            , stat_field, TaskGridStat_Folded, main_hero_id, task);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


bool ProcServerThread::check_and_query_assess_weapon(unsigned int group_id, 
    std::vector<__DuanzaoGroupZBInfo> &zb_vec) 
{
    zb_vec.clear();
    
    std::map<unsigned int, unsigned int>::iterator it;
    it = m_assess_weapon_map.find(group_id);
    if(it == m_assess_weapon_map.end()) {
        LogMsg("%s, line %d, zb group[%u] can not assess"
            , __FILE__, __LINE__, group_id);
        return false;
    }

    __DuanzaoGroupZBInfo info;
    if(!query_duanzao_group_zb_info(it->second, info)) {
        LogMsg("%s, line %d, zb group[%u] is not exist"
            , __FILE__, __LINE__, it->second);
        return false;
    }

    zb_vec.push_back(info);
    return true;
}


bool ProcServerThread::check_and_assess_weapon(unsigned int hero_id, unsigned long long zb_id, 
    unsigned long long cailiao_zb_id, std::vector<ItemInfo> &cailiao_vec)
{
    cailiao_vec.clear();
    
    if(zb_id == cailiao_zb_id)
    {
        LogMsg("%s, line %d, zhuangbei_id[%llu] is the same id of cailiao_zb_id"
                            , __FILE__, __LINE__, zb_id);
        return false;
    }
    
    //检查装备
    unsigned int zhuangbei_hero_id = 0, zb_name_id = 0, group_id = 0, zb_colour = 0;
    bool is_unlocked = false;
    std::map<unsigned int, unsigned int>::iterator pos;
    {
        //
        {
            char sql[1024];
            sprintf(sql, "select zhuangbei_list.zhuangbei_name_id, zhuangbei_hero_id, group_id,"
                " zhuangbei_colour, is_unlocked "
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    zhuangbei_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    zb_name_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_name_id"));
                    group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    zb_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                    is_unlocked = (bool)atoi(Mysql_Thread_Conn->GetField("is_unlocked"));
                }
                else
                {
                    LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //检查是否是稀有
        if(zb_colour != ZhuangbeiColour_Xiyou) {
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not uncommon"
                , __FILE__, __LINE__, zb_id);
            return false;
        }
       
        if(is_unlocked) {  //已经解锁
            LogMsg("%s, line %d, zhuangbei_id[%llu] is unlocked"
                , __FILE__, __LINE__, zb_id);
            return false;
        }
        
        pos = m_assess_weapon_map.find(group_id);
        if(pos == m_assess_weapon_map.end()) { //检查是否需要鉴定
            LogMsg("%s, line %d, zhuangbei_id[%llu] is not need assess."
                , __FILE__, __LINE__, zb_id);
            return false;
        }
    }

    //检查升级材料装状态
    bool cailiao_zb_equip_by_hero = false;
    unsigned int equip_hero_id = 0;
    if(cailiao_zb_id > 0){
        unsigned int cailiao_group_id = 0;
        {
            char sql[1024];
            sprintf(sql, "select group_id, zhuangbei_hero_id, qianghua_cailiao_total_count, "
                " qianghua_cailiao_goldstar_count, diamond_type_1, diamond_type_2, diamond_type_3"
                " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
                " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
                " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
                , cailiao_zb_id, hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL)
                {
                    cailiao_group_id = atoi(Mysql_Thread_Conn->GetField("group_id"));
                    equip_hero_id = atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id"));
                    if(equip_hero_id != 0) {
                        cailiao_zb_equip_by_hero = true;
                    }
                    else {
                        cailiao_zb_equip_by_hero = false;
                    }

                    int qianghua_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_total_count"));
                    if(qianghua_count > 0) {
                        ItemInfo item;
                        item.type = ItemsType_QianghuaNormal;
                        item.count = qianghua_count;
                        cailiao_vec.push_back(item);
                    }
                    int qianghua_goldstar_count = atoi(Mysql_Thread_Conn->GetField("qianghua_cailiao_goldstar_count"));
                    if(qianghua_goldstar_count > 0) {
                        ItemInfo item;
                        item.type = ItemsType_GoldStar_Qianghua;
                        item.count = qianghua_goldstar_count;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_1 = atoi(Mysql_Thread_Conn->GetField("diamond_type_1"));
                    if(diamond_type_1 > 0) {
                        ItemInfo item;
                        item.type = diamond_type_1;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_2 = atoi(Mysql_Thread_Conn->GetField("diamond_type_2"));
                    if(diamond_type_2 > 0) {
                        ItemInfo item;
                        item.type = diamond_type_2;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                    int diamond_type_3 = atoi(Mysql_Thread_Conn->GetField("diamond_type_3"));
                    if(diamond_type_3 > 0) {
                        ItemInfo item;
                        item.type = diamond_type_3;
                        item.count = 1;
                        cailiao_vec.push_back(item);
                    }
                }
                else {
                    LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                            , __FILE__, __LINE__, zb_id, hero_id);

                    Mysql_Thread_Conn->FreeResult();

                    return false;
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }

        //
        /*if(cailiao_zb_equip_by_hero) {
            LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] has equiped to hero"
                , __FILE__, __LINE__, cailiao_zb_id);
            return false;
        }
        */

        if(cailiao_group_id != pos->second) {
            LogMsg("%s, line %d, cailiao_zhuangbei_id[%llu] group_id[%u] is not right "
                , __FILE__, __LINE__, cailiao_zb_id, cailiao_group_id);
            return false;
        }

    }

    
    //更新鉴定状态
    {
        char sql[1024];
        sprintf(sql, "update hellgate.zhuangbei_list set "
            " is_unlocked=1 "
            " where zhuangbei_id=%llu and owner_hero_id=%u"
            , zb_id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    //回收强化材料
    for(int i=0; i<cailiao_vec.size(); i++)
    {
        ObtainItem(hero_id, cailiao_vec[i].type, cailiao_vec[i].count);
    }
    
    //删除材料装
    if(cailiao_zb_id > 0){
        char sql[1024];
        sprintf(sql, "delete from hellgate.zhuangbei_list where zhuangbei_id=%llu"
            , cailiao_zb_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(equip_hero_id) {
        this->calculate_fight_capacity(equip_hero_id);
    }

    return true;
}


void ProcServerThread::arena_bubble_sort(std::vector<ArenaChlgerHeroInfo> &hero_vec)
{
    ArenaChlgerHeroInfo swap_info;
    for(int i=0; i<hero_vec.size()-1; ++i) {
        for(int j=0; j<hero_vec.size()-1-i; ++j) {
            if(hero_vec[j].hero_info.level < hero_vec[j+1].hero_info.level) {
                swap_info = hero_vec[j];
                hero_vec[j] = hero_vec[j+1];
                hero_vec[j+1] = swap_info;
            }
        }
    }
}


void ProcServerThread::load_assess_weapon(void)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::load_assess_weapon", __FILE__, __LINE__);
#endif //_DEBUG
    m_assess_weapon_map.clear();
    { //鉴定装备map为空 加载
        char sql[1024];
        sprintf(sql, "select sealed_group_id, material_group_id "
            " from hellgate.assess_weapon order by sealed_group_id ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                unsigned int sealed = atoi(Mysql_Thread_Conn->GetField("sealed_group_id"));
                unsigned int material = atoi(Mysql_Thread_Conn->GetField("material_group_id"));

                if(sealed > 0) {
                    m_assess_weapon_map.insert(make_pair(sealed, material));
                }
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


void ProcServerThread::load_purify_attr_temp(void)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::load_purify_attr_temp", __FILE__, __LINE__);
#endif //_DEBUG
    m_purify_attr_vec.clear();
    {
        char sql[1024];
        sprintf(sql, "select * from hellgate.purify_attr_weight order by star_level ");
        try
        {
            Mysql_Thread_Conn->Query(sql);
            while(Mysql_Thread_Conn->FetchRow() != NULL) {
                __PurifyAttr attr;
                attr.star_level = atoi(Mysql_Thread_Conn->GetField("star_level"));
                attr.weight = atoi(Mysql_Thread_Conn->GetField("weight"));
                attr.min_value = atoi(Mysql_Thread_Conn->GetField("min_value"));
                attr.max_value = atoi(Mysql_Thread_Conn->GetField("max_value"));

                if(attr.star_level > PurifyLevel_Error) {
                    m_purify_attr_vec.push_back(attr);
                }
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
}


bool ProcServerThread::check_and_purify_weapon(unsigned int hero_id, unsigned long long id, 
		unsigned int hole, unsigned int &purify_hole, std::vector<ZBAttr> &attr_vec)
{
    purify_hole = 0;
    attr_vec.clear();

    std::vector<ZBAttr> zb_def_attr_vec;
    unsigned int zb_type = 0, zb_colour = 0, zb_level = 0;
    { //查询装备属性
        char sql[1024];
        sprintf(sql, "select zhuangbei_type, zhuangbei_colour, zhuangbei_level, "
            " purify_hole,  purify_attr_type_1, purify_attr_value_1, "
            " purify_attr_type_2, purify_attr_value_2, purify_attr_type_3, purify_attr_value_3, "
            " purify_attr_type_4, purify_attr_value_4, purify_attr_type_5, purify_attr_value_5, "
            " attr_count, attr_type_1, attr_value_1, attr_type_2, attr_value_2, "
            " attr_type_3, attr_value_3, attr_type_4, attr_value_4, attr_type_5, attr_value_5, "
            " attr_type_6, attr_value_6, attr_type_7, attr_value_7, attr_type_8, attr_value_8, "
            " attr_type_9, attr_value_9, attr_type_10, attr_value_10, attr_type_11, attr_value_11, "
            " attr_type_12, attr_value_12, attr_type_13, attr_value_13, attr_type_14, attr_value_14 "
            " from hellgate.zhuangbei_list, hellgate.zhuangbei_name_list_copy "
            " where zhuangbei_list.zhuangbei_name_id=zhuangbei_name_list_copy.zhuangbei_name_id "
            " and zhuangbei_list.zhuangbei_id=%llu and owner_hero_id=%u"
            , id, hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                zb_type = atoi(Mysql_Thread_Conn->GetField("zhuangbei_type"));
                zb_colour = atoi(Mysql_Thread_Conn->GetField("zhuangbei_colour"));
                zb_level = atoi(Mysql_Thread_Conn->GetField("zhuangbei_level"));
                purify_hole = atoi(Mysql_Thread_Conn->GetField("purify_hole"));

                char field[32];
                for(int i=0; i<purify_hole; ++i) {
                    ZBAttr attr;
                    
                    sprintf(field, "purify_attr_type_%u", i+1);
                    attr.attr_type = atoi(Mysql_Thread_Conn->GetField(field));
                    sprintf(field, "purify_attr_value_%u", i+1);
                    attr.attr_value = atoi(Mysql_Thread_Conn->GetField(field));

                    attr.cuiqu_suc_ratio = 0;

                    attr_vec.push_back(attr);
                    
                }
                
                //atrr
                int attr_count = atoi(Mysql_Thread_Conn->GetField("attr_count"));
                for(int i=0; i<attr_count; ++i) {
                    ZBAttr attr;

                    sprintf(field, "attr_type_%d", i+1);
                    attr.attr_type = atoi(Mysql_Thread_Conn->GetField(field));
                    sprintf(field, "attr_value_%d", i+1);
                    attr.attr_value = atoi(Mysql_Thread_Conn->GetField(field));

                    attr.cuiqu_suc_ratio = 0;

                    zb_def_attr_vec.push_back(attr);
                }
            }
            else {
                LogMsg("%s, line %d, zhuangbei_id[%llu] not exist or not belong to hero[%u]"
                        , __FILE__, __LINE__, id, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) 
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    if(hole > purify_hole) { //锁定洗炼的孔大于现有打开的孔
        LogMsg("%s, line %d, zhuangbei_id[%llu] locked hole[%u] over the purify hole[%u]"
            , __FILE__, __LINE__, id, hole, purify_hole);
        return false;
    }

    unsigned int max_hole = CS::getPurifyMaxHoles(zb_type, zb_colour, zb_level);
    if(max_hole==0 || purify_hole>max_hole) { //无孔 或者打开的孔大于规定的最大打开孔数
        LogMsg("%s, line %d, zhuangbei_id[%llu] purify hole[%u] over the max hole[%u]"
            , __FILE__, __LINE__, id, purify_hole, max_hole);
        return false;
    }

    unsigned int purify_free_times = 0;     //洗炼免费次数
    unsigned int purify_scroll = 0;         //洗炼卷轴
    { // 查询剩余免费次数
        char sql[1024];
        sprintf(sql, "select purify_free_times "
            " from hellgate.purify_weapon_hero "
            " where hero_id=%u "
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                purify_free_times = atoi(Mysql_Thread_Conn->GetField("purify_free_times"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] purify free times record is not exist"
                    , __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    if(purify_free_times == 0) { //免费次数用完 直接用卷轴
        purify_scroll = getItemCountInTeam(hero_id, ItemsType_Purify_Scroll);

        if(purify_scroll == 0) { //洗炼卷轴不够
            LogMsg("%s, line %d, hero[%u] purify scroll is not enough"
                , __FILE__, __LINE__, hero_id);
            return false;
        }
    }

    //是否增加新孔的标志位 打开下一个孔则不洗炼那孔的数值
    bool is_added_hole = false;  
    if(purify_hole < max_hole) { //打开孔数未满 有几率打开下一个孔
        int ran_num = Utl::auto_random()%100;
        if(purify_hole == 1) {
            if(ran_num <= 10) { //开第2孔 10%几率
                ZBAttr attr;
                attr.attr_type = AttrType_tineng;
                attr.attr_value = 5;
                attr.cuiqu_suc_ratio = 0;
                attr_vec.push_back(attr);
                
                purify_hole ++ ;
                is_added_hole = true;
            }
        }
        else if(purify_hole == 2) {
            if(ran_num <= 5) { //开第3孔 5%几率
                ZBAttr attr;
                attr.attr_type = AttrType_skillresult;
                attr.attr_value = 5;
                attr.cuiqu_suc_ratio = 0;
                attr_vec.push_back(attr);
                
                purify_hole ++ ;
                is_added_hole = true;
            }

        }
        else if(purify_hole == 3) {
            if(ran_num <= 1) { //开第4孔 1%几率
                ZBAttr attr;

                for(int i=0; i<zb_def_attr_vec.size(); ++i) {
                    if(zb_def_attr_vec[i].attr_type <= AttrType_tineng) {
                        attr.attr_type = zb_def_attr_vec[i].attr_type;
                        break;
                    }
                }
                
                attr.attr_value = 5;
                attr.cuiqu_suc_ratio = 0;
                attr_vec.push_back(attr);
                
                purify_hole ++ ;
                is_added_hole = true;
            }
        }
    }

    if(!is_added_hole) { //未开新孔 洗数值
        PurifyLevel cur_level = CS::getPurifyLevel(attr_vec[hole-1].attr_value);
        if(cur_level == PurifyLevel_Error) { //锁定洗炼孔的数值 星级错误
            LogMsg("%s, line %d, zhuangbei_id[%llu] purify level error"
                , __FILE__, __LINE__, id);
            return false;
        }

        // 获取洗炼最低下限星级
        unsigned int low_level = PurifyLevel_IronStar;
        if(cur_level >= PurifyLevel_GoldStar) {
            low_level =  cur_level -2;
        }

        unsigned int upper_limit;
        PurifyLevel high_level = CS::getPurifyUpperLimitLevel(zb_colour, zb_level, upper_limit);
        if(attr_vec[hole-1].attr_value > upper_limit) {//已经超过当前装备洗炼的数值 错误
            LogMsg("%s, line %d, zhuangbei_id[%llu] purify value over upper limit"
                , __FILE__, __LINE__, id);
            return false;
        }

        // 计算洗炼属性权重
        unsigned total_weight = 0;
        for(unsigned i= low_level-1; i<high_level && i<m_purify_attr_vec.size(); ++i) {
            total_weight += m_purify_attr_vec[i].weight;
        }

        //定位
        __PurifyAttr *pos_attr;
        memset(&pos_attr, 0, sizeof(__PurifyAttr));
        int ran_num = Utl::auto_random()%total_weight;
        for(unsigned i= low_level-1; i<high_level && i<m_purify_attr_vec.size(); ++i) {
            if((ran_num -= m_purify_attr_vec[i].weight) < 0) { // 找到
                pos_attr = &m_purify_attr_vec[i];
                break;
            }
        }

        if(pos_attr->star_level == PurifyLevel_Error) { //未找到洗炼的等级
            LogMsg("%s, line %d, zhuangbei_id[%llu] not found purify level"
                , __FILE__, __LINE__, id);
            return false;
        }

        //随机洗炼数值
        int ragion = pos_attr->max_value - pos_attr->min_value +1;
        attr_vec[hole-1].attr_value = pos_attr->min_value + (Utl::auto_random()%ragion);
    }
    

    { //删除临时表以前有的数据
        char sql[1024];
        sprintf(sql, "delete from hellgate.purify_weapon_temp where zhuangbei_id=%llu"
            , id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    std::string str;
    char field_value[64];
    for(int i=0; i<purify_hole; ++i) {
        sprintf(field_value, ", purify_attr_type_%u=%u, purify_attr_value_%u=%u", 
            i+1, attr_vec[i].attr_type, i+1, attr_vec[i].attr_value);
        str += field_value;
    }
    
    { //写入临时表
        char sql[1024];
        sprintf(sql, "insert into hellgate.purify_weapon_temp set "
            " zhuangbei_id=%llu, purify_hole=%u %s "
            , id, purify_hole, str.c_str());
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }


    if(purify_free_times > 0){ // 扣免费次数
        char sql[1024];
        sprintf(sql, "update hellgate.purify_weapon_hero set "
            " purify_free_times=purify_free_times-1, purified_times=purified_times+1 "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    else { // 扣代购卷轴
        char sql[1024];
        sprintf(sql, "update hellgate.purify_weapon_hero set "
            " purified_times=purified_times+1 "
            " where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        
        sprintf(sql, "update hellgate.items_in_team set item_count=item_count-1 "
            " where hero_id=%u and item_type=%u"
            , hero_id, ItemsType_Purify_Scroll);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


bool ProcServerThread::check_and_confirm_purify(unsigned int hero_id, unsigned long long id, bool is_confirm)
{
    if(is_confirm) { //确认洗炼
        char sql[2048];
        sprintf(sql, "update hellgate.zhuangbei_list, hellgate.purify_weapon_temp set "
            " hellgate.zhuangbei_list.purify_hole=hellgate.purify_weapon_temp.purify_hole, "
            " hellgate.zhuangbei_list.purify_attr_type_1=hellgate.purify_weapon_temp.purify_attr_type_1, "
            " hellgate.zhuangbei_list.purify_attr_value_1=hellgate.purify_weapon_temp.purify_attr_value_1, "
            " hellgate.zhuangbei_list.purify_attr_type_2=hellgate.purify_weapon_temp.purify_attr_type_2, "
            " hellgate.zhuangbei_list.purify_attr_value_2=hellgate.purify_weapon_temp.purify_attr_value_2, "
            " hellgate.zhuangbei_list.purify_attr_type_3=hellgate.purify_weapon_temp.purify_attr_type_3, "
            " hellgate.zhuangbei_list.purify_attr_value_3=hellgate.purify_weapon_temp.purify_attr_value_3, "
            " hellgate.zhuangbei_list.purify_attr_type_4=hellgate.purify_weapon_temp.purify_attr_type_4, "
            " hellgate.zhuangbei_list.purify_attr_value_4=hellgate.purify_weapon_temp.purify_attr_value_4, "
            " hellgate.zhuangbei_list.purify_attr_type_5=hellgate.purify_weapon_temp.purify_attr_type_5, "
            " hellgate.zhuangbei_list.purify_attr_value_5=hellgate.purify_weapon_temp.purify_attr_value_5 "
            " where hellgate.zhuangbei_list.zhuangbei_id=%llu "
            " and hellgate.zhuangbei_list.zhuangbei_id= hellgate.purify_weapon_temp.zhuangbei_id "
            , id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }


        bool is_equip_stat = false;
        sprintf(sql, "select zhuangbei_hero_id from hellgate.zhuangbei_list  "
            " where zhuangbei_list.zhuangbei_id=%llu "
            , id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                if(atoi(Mysql_Thread_Conn->GetField("zhuangbei_hero_id")) > 0) {
                    is_equip_stat = true;
                }
            }
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }

        if(is_equip_stat) { //穿在英雄身上 重新计算战斗力
            calculate_fight_capacity(hero_id);
    }
    }

    { // 删除此装备临时表的洗炼数据
        char sql[1024];
        sprintf(sql, "delete from hellgate.purify_weapon_temp where zhuangbei_id=%llu"
            , id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    return true;
}


bool ProcServerThread::check_and_adjust_formation(unsigned int main_hero_id, const unsigned int id_arr[])
{
    unsigned int total_count = 0;
    { //获取在战阵中的个数
        char sql[1024];
        sprintf(sql, "select count(hero_id) as total_count "
            " from hellgate.hero_infor where "
            " (hero_id=%u or parent_hero_id=%u) and position>0 "
            , main_hero_id, main_hero_id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                total_count = atoi(Mysql_Thread_Conn->GetField("total_count"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]", 
                __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    if(FormationHeroAcountMax == total_count) {
        for(int i=0; i<FormationHeroAcountMax; ++i) {
            if(id_arr[i] == 0) {
                LogMsg("%s, line %d, persons is less than 4.", __FILE__, __LINE__);
                return false;
            }
        }
    }

    
    //检查合法性
    {
        //主英雄是否在阵中
        bool isMainHeroIn = false;
        
        for(int i=0; i<FormationHeroAcountMax; ++i) {
            if(id_arr[i] == main_hero_id) {
                isMainHeroIn = true;
                continue;
            }
            
            //英雄id不合法
            if((id_arr[i] != 0) && !isHeroBelong2Team(id_arr[i], main_hero_id)) {
                LogMsg("%s, line %d, hero_id[%u] not belong to team[%u]"
                    , __FILE__, __LINE__, id_arr[i], main_hero_id);
                return false;
            }
            
        }

        if(!isMainHeroIn) {
            LogMsg("%s, line %d, main_hero[%u] not in formation"
                , __FILE__, __LINE__, main_hero_id);
            return false;
        }
    }

    { //先清空postion
        char sql[1024];
        sprintf(sql, "update hellgate.hero_infor set position=0 "
            " where hero_id=%u or parent_hero_id=%u"
            , main_hero_id, main_hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
        }
        catch(CMysqlException& e)
        {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }

        //调整
        for(int i=0; i<FormationHeroAcountMax; ++i) {
            if(id_arr[i] == 0) {
                continue;
            }

            sprintf(sql, "update hellgate.hero_infor set position=%u "
                " where hero_id=%u"
                , i+1, id_arr[i]);
            try
            {
                Mysql_Thread_Conn->Query(sql);
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    }

    return true;
}


bool ProcServerThread::query_heart_beat_info(unsigned int hero_id, unsigned int &vitality,
    std::vector<MarqueeMessage> &msg_vec)
{
    vitality = 0;
    msg_vec.clear();
    
    { //查询当前体力值 
        char sql[1024]; 
        sprintf(sql, "select vit_current "
            " from hellgate.hero_infor where hero_id=%u"
            , hero_id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                vitality = atoi(Mysql_Thread_Conn->GetField("vit_current"));
            }
            else {
                LogMsg("%s, line %d, hero[%u] is not exist"
                    , __FILE__, __LINE__, hero_id);
                return false;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }

    { //删除一定时间之前的消息序列
        const unsigned int const_delete_time = 90;  
        unsigned int tt = (unsigned int)time(NULL);
        tt = tt & 0xFFFF;       //当前秒数的后16位
        int index = -1;         //定位
        for(int i=0; i<m_msg_vec.size(); ++i) {
            unsigned int to = ((m_msg_vec[i].uid >> 16) & 0xFFFF);  //消息时间秒数的后16位
            
            if((tt - to) >= const_delete_time) {
                index = i;
            }
            else {  //因为是顺序压入容器 所以后面不用比较了
                break;
            }
        }
        if(index >= 0) {
            m_msg_vec.erase(m_msg_vec.begin(), m_msg_vec.begin() + index +1);
        }
    }
    
    int total_size = m_msg_vec.size();
    int shift_size = m_msg_vec.size() - MAX_MARQUEE_MESSAGE_COUNT;
    if(total_size > MAX_MARQUEE_MESSAGE_COUNT) {
        msg_vec.insert(msg_vec.begin(), m_msg_vec.begin()+shift_size, m_msg_vec.end());
    }
    else {
        msg_vec = m_msg_vec;
    }

    return true;
}


bool ProcServerThread::insert_marquee_message(unsigned int type, unsigned int hero_id, 
    unsigned int other_info, unsigned int count/*=1*/)
{
#ifdef _DEBUG
LogMsg("%s, line %d,ProcServerThread::insert_marquee_message", __FILE__, __LINE__);
#endif //_DEBUG
    if(type == MarqueeType_Invalid) {
        return false;
    }

    static unsigned short id = 0;
    
    { //先插入到容器中
        MarqueeMessage msg;
        unsigned int tt = (unsigned int)time(NULL);
        msg.uid = ((tt & 0xFFFF) << 16) | ((unsigned int)(id++) & 0xFFFF);
        msg.type = type;
        HeroInfo hero_info;
        GetHeroBasicInfo(hero_id, hero_info);
        if(hero_id > 0)
            strncpy(msg.subject, hero_info.name, HeroNameMaxLen);

        switch(type) {
            case MarqueeType_ForgeLegend:
            case MarqueeType_Compound:
            case MarqueeType_Discover_Unlock:
                msg.object.group_id = other_info;
                break;
            case MarqueeType_VarietyStore:
                msg.object.item_type = other_info;
                break;
            case MarqueeType_TopArena:
                msg.object.round = other_info;
                break;
            case MarqueeType_TopList:
                msg.object.top_order = other_info;
                break;
            case MarqueeType_ProtectSpirit:
                msg.object.chapter_id = other_info;
                break;
        }

        msg.count = count;
        m_msg_vec.push_back(msg);
    }

    if(m_msg_vec.size() > MAX_MARQUEE_MESSAGE_COUNT) { //删除多余的
        m_msg_vec.erase(m_msg_vec.begin(), 
            m_msg_vec.begin() + (m_msg_vec.size()-MAX_MARQUEE_MESSAGE_COUNT));

        //重新压缩空间
        std::vector<MarqueeMessage>(m_msg_vec).swap(m_msg_vec);
    }

    return true;
}


bool ProcServerThread::query_market_info(unsigned int hero_id, std::vector<MarketItem> &market_vec)
{
    market_vec.clear();

    std::map<unsigned int, MarketItem>::iterator p = m_market_map.begin();
    while(p != m_market_map.end()) {
        MarketItem info = p->second; //复制一个结构体出来

        //查询此类商品购买次数
        query_statis_info(hero_id, StatisType_Market, info.id, info.bought_times);

        market_vec.push_back(info);
        p++;
    }
    
    return true;
}


bool ProcServerThread::check_and_buy_item(unsigned int hero_id, unsigned int id, unsigned int buy_times)
{
    if(buy_times == 0) {
        LogMsg("%s, line %d, hero[%u] is not buy item"
            , __FILE__, __LINE__, hero_id);
        return false;
    }
    
    std::map<unsigned int, MarketItem>::iterator p = m_market_map.find(id);
    if(p == m_market_map.end()) {
        LogMsg("%s, line %d, market is have not the item[%u]"
            , __FILE__, __LINE__, id);
        return false;
    }

    MarketItem &info = p->second;

    if((info.sale_time > 0) && (info.sale_time < (unsigned int)time(NULL))) { 
        //已经过了出售时间了
        LogMsg("%s, line %d, current time can not buy the item"
            , __FILE__, __LINE__);
        return false;
    }

    HeroInfo hero_info;
    GetHeroBasicInfo(hero_id, hero_info);
    if(info.level_type == LimitType_VIPLvl) {
        if(hero_info.vip_level < info.level) { //vip 等级不够
            LogMsg("%s, line %d, main hero vip level[%u] is not enough"
                , __FILE__, __LINE__, hero_info.vip_level);
            return false;
        }
    }
    else if(info.level_type == LimitType_MainHeroLvl) {
        if(hero_info.level < info.level) { //主角等级不够
            LogMsg("%s, line %d, main hero level[%u] is not enough"
                , __FILE__, __LINE__, hero_info.level);
            return false;
        }
    }
    else if(info.level_type == LimitType_MainSoulLvl) {
        unsigned int soul_level = 0;
        {
            char sql[1024];
            sprintf(sql, "select level from hellgate.hero_infor "
                " where is_yuanshen=1 and zhenshen_id=%u "
                , hero_id);
            try
            {
                Mysql_Thread_Conn->Query(sql);
                if(Mysql_Thread_Conn->FetchRow() != NULL) {
                    soul_level = atoi(Mysql_Thread_Conn->GetField("level"));
                }
                
                Mysql_Thread_Conn->FreeResult();
            }
            catch(CMysqlException& e)
            {
                LogMsg("%s, line %d, mysql exception. [%s]"
                            , __FILE__, __LINE__, e.GetErrMsg());
                //
                exit(1);
            }
        }
    
        if(soul_level < info.level) { //主角元神等级不够
            LogMsg("%s, line %d, main hero soul level[%u] is not enough"
                , __FILE__, __LINE__, soul_level);
            return false;
        }
    }
    
    if(!info.is_unlimit) { //购买次数有限
        unsigned bought_times = 0;
        query_statis_info(hero_id, StatisType_Market, id, bought_times);

        if((bought_times + buy_times) > info.sell_count) {
            LogMsg("%s, line %d, bought times is over the limit times[%u]"
                , __FILE__, __LINE__, info.sell_count);
            return false;
        }
    }
    
    //查询货币是否足够
    unsigned int price_balance = 0; //余额
    unsigned int need_count = 0; //需要多少
    need_count = info.need_item.item.count *buy_times *info.discount /100;
    if(info.need_type == AttachType_Gold) {
        price_balance = getItemCountInTeam(hero_id, ItemsType_Gold);
        if(price_balance < need_count) { //金币不足
            LogMsg("%s, line %d, hero_id[%u] gold balance is not enough"
                , __FILE__, __LINE__, hero_id);
            return false;
        }
    }
    else if(info.need_type == AttachType_Silver) {
        price_balance = getItemCountInTeam(hero_id, ItemsType_Silver);
        if(price_balance < need_count) { //银币不足
            LogMsg("%s, line %d, hero_id[%u] silver balance is not enough"
                , __FILE__, __LINE__, hero_id);
            return false;
        }
    }
    else {
        LogMsg("%s, line %d, currency type[%u] is error"
            , __FILE__, __LINE__, info.need_type);
        return false;
    }

    //先添加物品
    if(info.sell_type <= AttachType_Props) { // 道具
        ObtainItem(hero_id, info.sell_item.item.type, info.sell_item.item.count *buy_times);
    }
    else if(info.sell_type == AttachType_PropsDebris) { //道具碎片入库
        ObtainItemSuipian(hero_id, info.sell_item.item_debris.item_id, 
            info.sell_item.item_debris.suipian_id, info.sell_item.item_debris.suipian_count *buy_times);
    }
    else if(info.sell_type == AttachType_ArmsDebris) { //装备碎片入库
        ObtainZhuangbeiSuipian(hero_id, info.sell_item.zb_debris.zb_group_id, 
            info.sell_item.zb_debris.suipian_id, info.sell_item.zb_debris.suipian_count *buy_times);
    }
    else if(info.sell_type == AttachType_GiftBag) { //礼包入库
        ObtainGiftBag(hero_id, info.sell_item.gift.id, info.sell_item.gift.count *buy_times);
    }    
    else if(info.sell_type == AttachType_Vitality) { //体力
        addVitality(hero_id, info.sell_item.vitality *buy_times);
    }    
    else {
        LogMsg("%s, line %d, hero_id[%u] buy item type[%u] is not right"
            , __FILE__, __LINE__, hero_id, info.sell_type);
        return false;
    }

       
    { //再扣钱
        if(info.need_type == AttachType_Gold) {
            DeductItem(hero_id, ItemsType_Gold, need_count);
        }
        else{
            DeductItem(hero_id, ItemsType_Silver, need_count);
        }
    }

    { //新增购买物品统计信息
        statis_data(hero_id, StatisType_Market, id, buy_times);
    }

    return true;
}


bool ProcServerThread::query_statis_info(unsigned int hero_id, unsigned int type, unsigned int id, 
    unsigned int &count)
{
    count = 0;
    if(type == StatisType_Market) { //查询商城购买次数
        char sql[1024];
        sprintf(sql, "select times "
            " from hellgate.statis_info "
            " where hero_id=%u and type=%u and id=%u "
            , hero_id, type, id);
        try
        {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() != NULL) {
                count = atoi(Mysql_Thread_Conn->GetField("times"));
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]"
                        , __FILE__, __LINE__, e.GetErrMsg());
            //
            exit(1);
        }
    }
    
    return true;
}


bool ProcServerThread::statis_data(unsigned int hero_id, unsigned int type, unsigned int id, 
    unsigned int count)
{
    bool is_not_exist = false;
    { //查询信息是否存在
        char sql[1024];
        sprintf(sql, "select 1 from hellgate.statis_info "
            " where hero_id=%u and type=%u and id=%u "
            , hero_id, type, id);
        try {
            Mysql_Thread_Conn->Query(sql);
            if(Mysql_Thread_Conn->FetchRow() == NULL) {
                is_not_exist = true;
            }
            
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]", __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }

    { //插入新消息
        char sql[1024];
        if(is_not_exist) {
            sprintf(sql, "insert into hellgate.statis_info set "
                " hero_id=%u, type=%u, id=%u, times=%u, last_timestamp=%u "
                , hero_id, type, id, count, (unsigned int)time(NULL));
        }
        else {
            sprintf(sql, "update hellgate.statis_info set "
                " times=times+%u, last_timestamp=%u "
                " where hero_id=%u and type=%u and id=%u "
                , count, (unsigned int)time(NULL)
                , hero_id, type, id);
        }
        
        try {
            Mysql_Thread_Conn->Query(sql);
            Mysql_Thread_Conn->FreeResult();
        }
        catch(CMysqlException& e) {
            LogMsg("%s, line %d, mysql exception. [%s]", __FILE__, __LINE__, e.GetErrMsg());
            exit(1);
        }
    }
    
    return true;
}

